///////////////////////////////////////////////////////////////////////////////
// RelativeLayout.h : SFL Layout Manager
//
// Copyright (c) 1997-2012 Rogue Wave Software, Inc.  All Rights Reserved.
//
// This computer software is owned by Rogue Wave Software, Inc. and is protected by
// U.S. copyright laws and other laws and by international treaties. This
// computer software is furnished by Rogue Wave Software, Inc. pursuant to a written
// license agreement and may be used, copied, transmitted, and stored
// only in accordance with the terms of such license agreement and with
// the inclusion of the above copyright notice.  This computer software or
// any other copies thereof may not be provided or otherwise made available
// to any other person.
//
// U.S. Government Restricted Rights.  This computer software:
//      (a) was developed at private expense and is in all respects the
//          proprietary information of Rogue Wave Software, Inc.;
//      (b) was not developed with government funds;
//      (c) is a trade secret of Rogue Wave Software, Inc. for all purposes of the
//          Freedom of Information Act; and
//      (d) is a commercial item and thus, pursuant to Section 12.212
//          of the Federal Acquisition Regulations (FAR) and DFAR
//          Supplement Section 227.7202, Government’s use, duplication or
//          disclosure of the computer software is subject to the restrictions
//          set forth by Rogue Wave Software, Inc.
//
///////////////////////////////////////////////////////////////////////////////
//
// Author:       Gilberto Araya
// Description:  SFL Layout Manager: Relative layout algorithm
//

#pragma once

#if !defined(_SFL)
#define _SFL
#endif

#ifndef _SFL_NO_PRAGMA_WARNINGS
	#if 1200 <= _MSC_VER
		#pragma warning(push,3)
	#endif
	#pragma warning(disable: 4876 4284) // STL, not a UDT or reference to a UDT. Errors if infix notation used.
#endif

#include <foundation\stwarn.h>
#include <map>
#include <list>
#include <foundation\stwarnp.h>
#include <foundation\Layout\LayoutNode.h>
#include <StingrayExportDefs.h>

namespace stingray {
namespace foundation {

// Disable the warning that complains about the symbols name length 
#pragma warning(disable: 4786 4275)

//@doc


//@enum ConstraintType |
// Types of constraints that can be applied to nodes
// in a Relative layout arrangement.
enum ConstraintType { 
	RelDefault	= 0,		//@emem Default constraint: no constraint.
	RelLeft,				//@emem Adjust node rectangle's left side
	RelRight,				//@emem Adjust node rectangle's right side
	RelTop,					//@emem Adjust node rectangle's top side
	RelBottom,				//@emem Adjust node rectangle's bottom side
	RelWidth,				//@emem Adjust node rectangle's width
	RelHeight,				//@emem Adjust node rectangle's height
	RelCenterHorizontal,	//@emem Center node rectangle with respect to width
	RelCenterVertical,		//@emem Center node rectangle with respect to height
	RelMoveLeft,			//@emem Move node rectangle, with respect to left
	RelMoveRight,			//@emem Move node rectangle, with respect to right
	RelMoveTop,				//@emem Move node rectangle, with respect to top
	RelMoveBottom			//@emem Move node rectangle, with respect to bottom
};


struct FOUNDATION_API  CRelativeConstraint
{
	// Node to which the constraint is applied
	ILayoutNode* pNodeFrom;

	// Type of constraint applied to m_pNodeFrom
	ConstraintType constraintFrom;

	// Position m_pNodeFrom relative to this node. Use NULL for absolute position.
	ILayoutNode* pNodeTo;

	// Target constraint for relatively positioned node.
	ConstraintType constraintTo;

	// Additive modifier applied to relative constraint
	int nAdditiveModifier;

	// Multiplicative modifier applied to relative constraint
	float fMultiplicativeModifier;

	CRelativeConstraint()
		: pNodeFrom(NULL), constraintFrom(RelDefault), pNodeTo(NULL), constraintTo(RelDefault),
		nAdditiveModifier(0), fMultiplicativeModifier(0)
	{}


	// Autogenerated copy constructor and assignment operator suffice for this particular structure
};



//@interface IRelativeLayout |
// Additional functionality required to implement a relative layout
// algorithm. Allows the programmer set constraints on the relative position
// of this node's children.
//@base public | ILayoutNode
interface  __declspec(uuid("DBDB26B1-5195-11d3-9D94-00C04F91E286")) IRelativeLayout:
	public ILayoutNode
{
	//@meth,method bool | SetConstraint |
	// Defines a constraint on a child node of this node.
	//@@rdesc true if application of the constraint can be performed successfully, 
	// false otherwise.
	//@@parm ILayoutNode* | pNodeFrom | Node the constraint will be applied to.
	//@@parm ConstraintType | constraintFrom | Constraint to be applied against pNodeFrom. Takes a value from the <t ConstraintType> enumeration. 
	//@@parm ILayoutNode* | pNodeTo | Node relative to which the constraint will be applied.
	//@@parm ConstraintType | constraintTo | Constraint to be applied relative to pNodeTo. Takes a value from the <t ConstraintType> enumeration. Default is RelDefault.
	//@@parm int | nModifier | Additive modifier, usually used to indicate a positive or negative displacement. Default is 0.
	//@@parm float | fModifier | Multiplicative modifier, usually used to scale the effect of the constraint. Default is 1.0.
	/*@@ex 		
		This example says: "Set the left side of the node pSplitter to the right side of the pNameNode node plus 20 units." |
	    pRelative->SetConstraint(pSplitter, RelLeft, pNameNode, RelRight, 20);<nl>
	*/
	/*@@ex
		This example says: "Move (without resizing it) the node pOkNode, such that its bottom is 30 pixels up of the Root node bottom." |
		pRelative->SetConstraint(pOkNode, foundation::RelMoveBottom, pRootNode, foundation::RelBottom, -30);<nl>
	*/
	virtual bool SetConstraint(
			ILayoutNode* pNodeFrom, ConstraintType constraintFrom,
			ILayoutNode* pNodeTo, ConstraintType constraintTo = RelDefault,
			int nModifier = 0, float fModifier = 1.0) = 0;

	//@meth,method void | RemoveAllConstraints | 
	//  Remove all constraints that have been previously defined on this node.
	virtual void RemoveAllConstraints() = 0;
};



//@class CRelativeLayout |
/* 
   Implementation of the Relative layout algorithm.<nl>
   The Relative Layout allows a logical organization of layout nodes where the 
   arrangement of child windows is specified as a set of constraints which are 
   constructed using English-like semantics. For example:
	- "Set the left side of node 1 equal to the right side of node 2 plus 10 pixels," or 
	- "Set the bottom of node 1 to 25 percent of the height of node 2," or
	- "Move node 1 such that its bottom is equal to the top of node 2 - 10 pixels."
   Use the SetConstraint() method in the IRelativeLayout interface to specify the constraints 
   to be used by an object.
*/
//@base public | CLayoutNode<IRelativeLayout>
//@supint ILayoutNode | Basic layout node interface.
//@supint IRelativeLayout | Functionality specific to the Relative layout algorithm.
class __declspec(uuid("DBDB26B2-5195-11d3-9D94-00C04F91E286")) CRelativeLayout:
	public CLayoutNode<CRelativeLayout, IRelativeLayout>
{
public:
	// ILayoutNode interface
	inline virtual CRect OnRecalcLayout(const CRect& rcDesired,
								 bool bChildNegotiate, bool bStrictRecalc);

	// IRelativeLayout interface
	inline virtual bool SetConstraint(
			ILayoutNode* pNodeFrom, ConstraintType constraintFrom,
			ILayoutNode* pNodeTo, ConstraintType constraintTo = RelDefault,
			int nModifier = 0, float fModifier = 1.0);

	inline virtual void RemoveAllConstraints();


private:

	typedef std::map<ILayoutNode*, CRect> NodeRectMap;
	typedef std::list<CRelativeConstraint> ConstraintMap;
	ConstraintMap m_Constraints;


protected:
	// Relative layout implementation

	inline void ApplyAllConstraints(NodeRectMap& mapNodeRects);
	inline void ApplyConstraint(CRelativeConstraint& aConstr, CRect& rcFrom, CRect& rcTo);
	inline bool ApplyConstraintPosition(long& nRectPos, CRelativeConstraint& aConstr, CRect& rcTo); 
	inline bool ApplyConstraintSizing(long& nBoundStart, long& nBoundStop, CRelativeConstraint& aConstr, CRect& rcTo);
	inline bool ApplyConstraintCentering(long& nBoundStart, long& nBoundStop, long& nRectToBase,
									CRelativeConstraint& aConstr, CRect& rcTo);

	inline virtual CRelativeConstraint* FindConstraint(ILayoutNode* pNodeFrom, ConstraintType constraint);
	inline virtual void ResolveDefaultConstraints(ConstraintType& constraintFrom, ConstraintType& constraintTo);

	// Temp Node rectangle storage/utilization
	inline void GetNodeRects(NodeRectMap& mapNodeRects);
	inline CRect ApplyNodeRects(NodeRectMap& mapNodeRects, bool bChildNegotiate, bool bStrictRecalc);

};

#define MODIFY_CONSTRAINT(x, n, f)	( static_cast<long>(f * static_cast<float>(x) + 0.5) + n )

bool CRelativeLayout::SetConstraint (
									 ILayoutNode* pNodeFrom, 
									 ConstraintType constraintFrom,
									 ILayoutNode* pNodeTo, 
									 ConstraintType constraintTo,
									 int nModifier,
									 float fModifier
									 )
{
	// pNodeTo can be NULL (absolute position)
	if (!pNodeFrom) {
		return false;
	}

	// "Default" is no more than a keyword to identify unitialized constraints.
	// If either constraint is default, set to an appropriate initial state.
	ResolveDefaultConstraints(constraintFrom, constraintTo);

	CRelativeConstraint aNewConstraint;

	// If constraint object already exists, modify existing
	CRelativeConstraint* pConstr;
	pConstr = FindConstraint(pNodeFrom, constraintFrom);
	bool bExistent = (pConstr != 0);
	if (!bExistent) {
		// Modify existing:
		pConstr = &aNewConstraint;
	}

	pConstr->pNodeFrom = pNodeFrom;
	pConstr->constraintFrom = constraintFrom;
	pConstr->pNodeTo = pNodeTo;
	pConstr->constraintTo = constraintTo;
	pConstr->nAdditiveModifier = nModifier;
	pConstr->fMultiplicativeModifier = fModifier;

	if (!bExistent) {
		// Add to the list
		m_Constraints.push_back(aNewConstraint);
	}

	return true;
}


void CRelativeLayout::RemoveAllConstraints (
	)
{
	m_Constraints.clear();
}


struct ConstraintCompare:
	public std::unary_function<const CRelativeConstraint&, bool>
{
	ConstraintCompare(ILayoutNode* pNode, ConstraintType nType)
		: m_pNode(pNode), m_nType(nType)
	{}

	ILayoutNode* m_pNode;
	ConstraintType m_nType;

	bool operator () (const CRelativeConstraint& aConstraint) const
	{
		return (aConstraint.pNodeFrom == m_pNode) && 
			(aConstraint.constraintFrom == m_nType);
	}
};


CRelativeConstraint* CRelativeLayout::FindConstraint (
	ILayoutNode* pNodeFrom, 
	ConstraintType constraint
	)
{
	if (!pNodeFrom) {
		return NULL; 
	}
	ConstraintCompare aComparator(pNodeFrom, constraint);
	ConstraintMap::iterator posConstr = std::find_if(m_Constraints.begin(), m_Constraints.end(), aComparator);
	CRelativeConstraint* pConstr = NULL;
	if (posConstr != m_Constraints.end()) {
		pConstr = &(*posConstr);
	}
	return pConstr;
}


CRect CRelativeLayout::OnRecalcLayout (
									   const CRect& rcDesired,
									   bool bChildNegotiate, 
									   bool bStrictRecalc
									   )
{
	// must apply the rect before ApplyConstraints for proper parent rect query
	SetCurrentRect(rcDesired);

	// Store a temp copy of all child node rectangles for quick manipulation
	NodeRectMap mapNodeRects;
	GetNodeRects(mapNodeRects);

	// Edit the child rects in one swoop. Do not use node RecalcLayout yet as
	// that could be a potentially CPU intensive operation
	ApplyAllConstraints(mapNodeRects);

	// Rectangles positioned, now iterate through and issue the node RecalcLayouts
	CRect rcCurrent = ApplyNodeRects(mapNodeRects, bChildNegotiate, bStrictRecalc);
	SetCurrentRect(rcCurrent);

	return rcCurrent;
}




void CRelativeLayout::ApplyAllConstraints (
	NodeRectMap& mapNodeRects
	)
{
	ConstraintMap::iterator posConstraint;
	for (posConstraint = m_Constraints.begin(); posConstraint != m_Constraints.end(); ++posConstraint) {
		CRelativeConstraint& aConstraint = *posConstraint;

		CRect& rcFrom = mapNodeRects[aConstraint.pNodeFrom];
		CRect& rcTo = (aConstraint.pNodeTo)? mapNodeRects[aConstraint.pNodeTo] : rcFrom;

		ApplyConstraint(aConstraint, rcFrom, rcTo);
	}
}


void CRelativeLayout::ApplyConstraint (
									   CRelativeConstraint& aConstr, 
									   CRect& rcFrom, 
									   CRect& rcTo
									   )
{
	// establish the constraint
	long lHeight;
	long lWidth;

	switch (aConstr.constraintFrom) {
case RelLeft:
	ApplyConstraintPosition(rcFrom.left, aConstr, rcTo);
	break;
case RelRight:
	ApplyConstraintPosition(rcFrom.right, aConstr, rcTo);
	break;
case RelTop:
	ApplyConstraintPosition(rcFrom.top, aConstr, rcTo);
	break;
case RelBottom:
	ApplyConstraintPosition(rcFrom.bottom, aConstr, rcTo);
	break;
case RelWidth:
	ApplyConstraintSizing(rcFrom.left, rcFrom.right, aConstr, rcTo);
	break;
case RelHeight:
	ApplyConstraintSizing(rcFrom.top, rcFrom.bottom, aConstr, rcTo);
	break;
case RelCenterHorizontal:
	ApplyConstraintCentering(rcFrom.left, rcFrom.right, rcTo.left, aConstr, rcTo);
	break;
case RelCenterVertical:
	ApplyConstraintCentering(rcFrom.top, rcFrom.bottom, rcTo.top, aConstr, rcTo);
	break;
case RelMoveLeft:
	// Position to left, and adjust right to maintain size
	lWidth = rcFrom.Width();
	if (ApplyConstraintPosition(rcFrom.left, aConstr, rcTo)) {
		rcFrom.right = rcFrom.left + lWidth;
	}
	break;
case RelMoveRight:
	// Position to right, and adjust left to maintain size
	lWidth = rcFrom.Width();
	if (ApplyConstraintPosition(rcFrom.right, aConstr, rcTo)) {
		rcFrom.left = rcFrom.right - lWidth;
	}
	break;
case RelMoveTop:
	// Position to top, and adjust bottom to maintain size
	lHeight = rcFrom.Height();
	if (ApplyConstraintPosition(rcFrom.top, aConstr, rcTo)) {
		rcFrom.bottom = rcFrom.top + lHeight;
	}
	break;
case RelMoveBottom:
	// Position to bottom, and adjust top to maintain size
	lHeight = rcFrom.Height();
	if (ApplyConstraintPosition(rcFrom.bottom, aConstr, rcTo)) {
		rcFrom.top = rcFrom.bottom - lHeight;
	}
	break;
default:
	// constraint not found!
	break;
	}
}


bool CRelativeLayout::ApplyConstraintPosition (
	long& nRectPos, 
	CRelativeConstraint& aConstr, 
	CRect& rcTo
	)
{
	// If target node is NULL, use absolute positioning
	if (!aConstr.pNodeTo) {
		nRectPos = aConstr.nAdditiveModifier;
		return true;
	}

	// establish the constraint
	int nMod = aConstr.nAdditiveModifier;
	float fMod = aConstr.fMultiplicativeModifier;
	switch (aConstr.constraintTo) {
case RelLeft:
	nRectPos = MODIFY_CONSTRAINT(rcTo.left, nMod, fMod);
	break;
case RelRight:
	nRectPos = MODIFY_CONSTRAINT(rcTo.right, nMod, fMod);
	break;
case RelTop:
	nRectPos = MODIFY_CONSTRAINT(rcTo.top, nMod, fMod);
	break;
case RelBottom:
	nRectPos = MODIFY_CONSTRAINT(rcTo.bottom, nMod, fMod);
	break;
case RelWidth:
	nRectPos = MODIFY_CONSTRAINT(rcTo.Width(), nMod, fMod);
	break;
case RelHeight:
	nRectPos = MODIFY_CONSTRAINT(rcTo.Height(), nMod, fMod);
	break;
case RelDefault: {
	// Default constraints should be resolved by SetDefaultConstraint!
	// If overriding and providing custom constraints, make sure you
	// issue this call on SetConstraint.
	_ASSERTE(false);
	return false;
	break;
				 }
default:
	// Didn't handle constraint here!
	return false;
	break;
	}
	return true;
}


bool CRelativeLayout::ApplyConstraintSizing (
	long& nBoundStart, 
	long& nBoundStop, 
	CRelativeConstraint& aConstr, 
	CRect& rcTo
	)
{
	// If target node is NULL, use absolute positioning
	if (!aConstr.pNodeTo) {
		nBoundStop = nBoundStart + aConstr.nAdditiveModifier;
		return true;
	}

	// Establish the constraint
	int nMod = aConstr.nAdditiveModifier;
	float fMod = aConstr.fMultiplicativeModifier;
	switch (aConstr.constraintTo) {
case RelLeft:
	nBoundStop = nBoundStart + MODIFY_CONSTRAINT(rcTo.left, nMod, fMod);
	break;
case RelRight:
	nBoundStop = nBoundStart + MODIFY_CONSTRAINT(rcTo.right, nMod, fMod);
	break;
case RelTop:
	nBoundStop = nBoundStart + MODIFY_CONSTRAINT(rcTo.top, nMod, fMod);
	break;
case RelBottom:
	nBoundStop = nBoundStart + MODIFY_CONSTRAINT(rcTo.bottom, nMod, fMod);
	break;
case RelWidth:
	nBoundStop = nBoundStart + MODIFY_CONSTRAINT(rcTo.Width(), nMod, fMod);
	break;
case RelHeight:
	nBoundStop = nBoundStart + MODIFY_CONSTRAINT(rcTo.Height(), nMod, fMod);
	break;
case RelDefault: {
	// Default constraints should be resolved by SetDefaultConstraint!
	// If overriding and providing custom constraints, make sure you
	// issue this call on SetConstraint.
	_ASSERTE(false);
	return false;
	break;
				 }
default:
	// Didn't handle constraint here!
	return false;
	break;
	}
	return true;
}


bool CRelativeLayout::ApplyConstraintCentering (
	long& nBoundStart, 
	long& nBoundStop, 
	long& nRectToBase,
	CRelativeConstraint& aConstr, 
	CRect& rcTo
	)
{
	// establish the constraint
	long lCenterRelativeTo = 0;
	switch (aConstr.constraintTo) {
case RelLeft:
	lCenterRelativeTo = rcTo.left;
	break;
case RelRight:
	lCenterRelativeTo = rcTo.right;
	break;
case RelTop:
	lCenterRelativeTo = rcTo.top;
	break;
case RelBottom:
	lCenterRelativeTo = rcTo.bottom;
	break;
case RelWidth:
	lCenterRelativeTo = rcTo.Width();
	break;
case RelHeight:
	lCenterRelativeTo = rcTo.Height();
	break;
case RelDefault: {
	// Default constraints should be resolved by SetDefaultConstraint!
	// If overriding and providing custom constraints, make sure you
	// issue this call on SetConstraint.
	_ASSERTE(false);
	return false;
				 }
default:
	// Didn't handle constraint here!
	return false;
	}

	// Perform center operation
	long lBoundSize = nBoundStop - nBoundStart;
	long lOffset = (lCenterRelativeTo - lBoundSize) / 2;
	nBoundStart = nRectToBase + MODIFY_CONSTRAINT(lOffset, aConstr.nAdditiveModifier, aConstr.fMultiplicativeModifier);
	nBoundStop = nBoundStart + lBoundSize;
	return true;
}


void CRelativeLayout::ResolveDefaultConstraints (
	ConstraintType& constraintFrom, 
	ConstraintType& constraintTo
	)
{

	// Set the default "from" constraint to "MoveLeft"
	if (constraintFrom == RelDefault) {
		constraintFrom = RelMoveLeft;
	}

	// Set the default "to" constraint based on the "from" constraint
	if (constraintTo == RelDefault) {
		switch (constraintFrom) {
case RelTop: 
case RelBottom: 
case RelLeft:
case RelRight:
case RelWidth:
case RelHeight:
	constraintTo = constraintFrom;
	break;
case RelCenterHorizontal:
	constraintTo = RelWidth;
	break;
case RelCenterVertical:
	constraintTo = RelHeight;
	break;
case RelMoveLeft:
	constraintTo = RelLeft;
	break;
case RelMoveRight:
	constraintTo = RelRight;
	break;
case RelMoveTop:
	constraintTo = RelTop;
	break;
case RelMoveBottom:
	constraintTo = RelBottom;
	break;
case RelDefault:
	// Defaults should be resolved by now!
	_ASSERTE(false);
default:
	// Custom constraints? You need to override.
	break;
		}
	}
}


void CRelativeLayout::GetNodeRects (
									NodeRectMap& mapNodeRects
									) 
{
	// Insert the rect for the root node
	mapNodeRects.insert(NodeRectMap::value_type(this, GetCurrentRect()));

	// Iterate through all nodes in the children list, querying
	// and saving the current rect for each
	Children::iterator posChild;
	for (posChild = m_Children.begin(); posChild != m_Children.end(); ++posChild) {
		ILayoutNode* pChildNode = (*posChild);
		CRect rcNode = pChildNode->GetCurrentRect();

		mapNodeRects.insert(NodeRectMap::value_type(pChildNode, rcNode));
	}
}


CRect CRelativeLayout::ApplyNodeRects (
									   NodeRectMap& mapNodeRects, 
									   bool bChildNegotiate, 
									   bool bStrictRecalc
									   )
{
	NodeRectMap::iterator posNode;
	for (posNode = mapNodeRects.begin(); posNode != mapNodeRects.end(); ++posNode) {
		ILayoutNode* pChildNode = (*posNode).first;
		CRect rcDesired = (*posNode).second;
		CRect rcUsed;

		// constraint map contains both child nodes and their
		// reference nodes (not necessarily children). Only
		// reposition child nodes!
		if (pChildNode->GetParentNode() != guid_cast<ILayoutNode*>(this)) {
			continue;
		}

		rcUsed = pChildNode->RecalcLayout(rcDesired, bChildNegotiate, bStrictRecalc);

		// if child suggested an alternate sizing, and we allow child negotiation,
		// process the requested size as desired. Do nothing if size is ok.
		if (bChildNegotiate && (rcUsed != rcDesired)) {

			// massage rectUsed here

			// If rectUsed has been changed, apply again, with no child negotiation
			pChildNode->RecalcLayout(rcUsed, false, bStrictRecalc);
		}
	}

	return GetCurrentRect();
}

};	// namespace stingray::foundation
};	// namespace stingray


#ifndef _SFL_NO_PRAGMA_WARNINGS
	#if 1200 <= _MSC_VER
		#pragma warning (pop)
	#endif
#endif

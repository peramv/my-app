//******************************************************************************
//
// COPYRIGHT:
//
//    The computer systems, procedures, data bases and
//    programs created and maintained by International Financial Data Services,
//    are proprietary in nature and as such are confidential.
//    Any unauthorized use or disclosure of such information
//    may result in civil liabilities.
//
//    Copyright 2000 by International Financial Data Services
//
//
//******************************************************************************
//
// ^FILE   : Trade.cpp
// ^AUTHOR : Serban Popescu   
// ^DATE   : September, 2004
//
// ^CLASS    : Trade
// ^SUBCLASS :
//
// ^CLASS DESCRIPTION :
//
//******************************************************************************

#include "stdafx.h"
#include "trade.hpp"

#include "acctcategorylist.hpp"
#include "accountentityxref.hpp"
#include "address.hpp"
#include "addresslist.hpp"
#include "accshrnumcheck.hpp"
#include "acctroundingrule.hpp"
#include "acctroundingrulelist.hpp"
#include "acctsettlementinstr.hpp"
#include "acctsettlementinstrlist.hpp"
#include "agent.hpp"
#include "agentlist.hpp"
#include "amsmstrinfo.hpp"
#include "amsmstrlist.hpp"
#include "amsfundalloc.hpp"
#include "amsfundalloclist.hpp"
#include "amsacctlvllist.hpp"
#include "amsacctlvl.hpp"
#include "batchinfolist.hpp"
#include "bankinstructions.hpp"
#include "branch.hpp"
#include "branchlist.hpp"
#include "broker.hpp"
#include "brokerlist.hpp"
#include "contractinfo.hpp"
#include "contractinfolist.hpp"
#include "currency.hpp"
#include "currencylist.hpp"
#include "datevalidation.hpp"
#include "deffundalloclist.hpp"
#include "deffundalloc.hpp"
#include "dilutionalloc.hpp"
#include "dilutionalloclist.hpp"
#include "distributorbankinstructionslist.hpp"
#include "distributorrepository.hpp"
#include "dynamicsublistholder.hpp"
#include "entity.hpp"
#include "mfaccount.hpp"
#include "entityidslist.hpp"
#include "errmsgruleslist.hpp"
#include "eusdvalidation.hpp"
#include "exchratelist.hpp"
#include "externalinstitutionlist.hpp"
#include "fundbrokerdefault.hpp"
#include "fundbrokerelig.hpp"
#include "fundbroker.hpp"
#include "fundbrokerlist.hpp"
#include "funddetail.hpp"
#include "funddetaillist.hpp"
#include "fundfeelist.hpp"
#include "fundlist.hpp"
#include "fundlmtoverride.hpp"
#include "fundlmtoverridelist.hpp"
#include "fundmgmtsettlementinstr.hpp"
#include "fundmgmtsettlementinstrlist.hpp"
#include "fundmaster.hpp"
#include "fundmasterlist.hpp"
#include "fundsponsorfeemodellist.hpp"
#include "fundsponsorslist.hpp"
#include "fundtranstype.hpp"
#include "fundtranstypelist.hpp"
#include "fundtolist.hpp"
#include "giainvattriblist.hpp"
#include "giamaturitydateinq.hpp"
#include "investmenthistorylist.hpp"
#include "investmenthistory.hpp"
#include "intermediary.hpp"
#include "intermediarylist.hpp"
#include "mfaccount.hpp"
#include "mfaccountholdinglist.hpp"
#include "mgmtco.hpp"
#include "mgmtcooptions.hpp"
#include "paytoentity.hpp"
#include "paytoentitylist.hpp"
#include "pendingtradebankinstructionslist.hpp"
#include "progressiveintratelist.hpp"
#include "pseeaplist.hpp"
#include "redemptionvalidation.hpp"
#include "residency.hpp"
#include "respinfoupdatevalidationlist.hpp"
#include "respbeneficiaryallocation.hpp"
#include "respbeneficiaryallocationlist.hpp"
#include "resptransferlist.hpp"
#include "resptradevalidation.hpp"
#include "resptradevalidationList.hpp"
#include "resptradeconstantinquiry.hpp"
#include "segtrxvalidationlist.hpp"
#include "segtradeentryvalidation.hpp"
#include "seqfundvalidation.hpp"
#include "shareholder.hpp"
#include "shareholderbankinstructionslist.hpp"
#include "splitcommission.hpp"
#include "splitcommissionlist.hpp"
#include "supportedproductslist.hpp"
#include "syslvlsettlementinstr.hpp"
#include "syslvlsettlementinstrlist.hpp"
#include "taxtyperule.hpp"
#include "taxtyperulelist.hpp"
#include "tradebankinstructions.hpp"
#include "tradebankinstructionslist.hpp"
#include "tradeacctalloc.hpp"
#include "tradeacctalloclist.hpp"
#include "tradefromfundalloclist.hpp"
#include "tradefundalloc.hpp"
#include "tradefundalloclist.hpp"
#include "tradepayinstruct.hpp"
#include "tradepayinstructlist.hpp"
#include "transactionlist.hpp"
#include "translationtable.hpp"
#include "transfeecontext.hpp"
#include "transfee.hpp"
#include "transfeelist.hpp"
#include "TransactionList.hpp"
#include "TransactionDetails.hpp"
#include "TradeSearchCriteria.hpp"
#include "trademinamtcheck.hpp"
#include "tradesettlementlocationslist.hpp"
#include "tradesettlementlocations.hpp"
#include "tradedunitposition.hpp"
#include "worksessiontradeslist.hpp"
#include "addressentitylist.hpp"
#include "matsweepinstrlist.hpp"
#include "giinvestmentdetailslist.hpp"
#include "giinvestmentdetails.hpp"
#include "agentbankinstructionslistrepository.hpp"
#include "regagentbankinstructionslist.hpp"
#include "estateallocationlist.hpp"
#include "rdradvice.hpp"
#include "DefaultSysConfigDetailList.hpp"
#include "FundLmtOverrideList.hpp"
#include "AccountMailingList.hpp"
#include "NetworkConfigDetailList.hpp"
#include "NetworkConfigDetail.hpp"
#include "TradeLevelOverrideRules.hpp"
#include "TransSettlementInstr.hpp"
#include "TradeTransTypeSetFromMiscInfoList.hpp"
#include "RegulatoryValidationErrorList.hpp"
#include "TrxnFee.hpp"
#include "UnusualTradingValidation.hpp"
#include "fundgrouptypelist.hpp"
#include "accountentityxrefobject.hpp"
#include "FundSuspensionValidation.h"
#include "RDSPTradeValidation.hpp"
#include "IntraDayPricing.h"
#include "rdsptransfer.hpp"

//new batch name
#include <ifastdataimpl\dse_dstc0124_req.hpp>
#include <ifastdataimpl\dse_dstc0124_vw.hpp>
//transaction number retrieval
#include <ifastdataimpl\dse_dstc0127_req.hpp>
#include <ifastdataimpl\dse_dstc0127_vw.hpp>
//trade date lag
#include <ifastdataimpl\dse_dstc0181_req.hpp>
#include <ifastdataimpl\dse_dstc0181_vw.hpp>
#include <ifastdataimpl\dse_dstc0344_vw.hpp>
#include <ifastdataimpl\dse_dstc0149_vw.hpp>
#include <ifastdataimpl\dse_dstc0401_vw.hpp>
#include <ifastdataimpl\dse_dstc0421_vwrepeat_record.hpp>
#include <ifastdataimpl\dse_dstc0423_vw.hpp>
#include <ifastdataimpl\dse_dstc0423_vwrepeat_record.hpp>
#include <ifastdataimpl\dse_dstc0436_vw.hpp>
#include <ifastdataimpl\dse_dstc0486_req.hpp>

#include <ifastdataimpl\dse_dstc0487_req.hpp>
#include <ifastdataimpl\dse_dstc0487_vw.hpp>

#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_err_unit_trading_not_allowed.h>
#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_warn_unit_trading_not_allowed.h>

#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_err_Invalid_institution_code.h>
#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_warn_Invalid_institution_code.h>

#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_err_ExtInstitution_name_not_provided.h>
#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_warn_ExtInstitution_name_not_provided.h>

#include <conditions\iFastLayer\iFast\ifastcbo\IFast_IFast_ifastcbo_err_invalid_payment_method.h>

namespace
{
   //Trace literals
   const I_CHAR * const CLASSNAME             = I_ ( "Trade" );
   const I_CHAR * const CLIENT                = I_ ( "1" );
   const I_CHAR * const YES                   = I_ ( "Y" );
   const I_CHAR * const NO                    = I_ ( "N" );
   const I_CHAR * const NA                    = I_ ( "99" );
   const I_CHAR * const STANDARD_MATHEMATICAL = I_ ( "00" );
   const I_CHAR * const TFSA_TAX_TYPE         = I_ ( "V" );
   const I_CHAR * const UNVERIFIED            = I_ ( "02" );
   const I_CHAR * const BANKING_LEVEL         = I_ ( "1" );
   const I_CHAR * const SHAREHOLDER           = I_ ( "10" );
   const I_CHAR * const VERIFIED              = I_ ( "01" );
   const I_CHAR * const SHRHLDR_LEVEL         = I_ ( "01" );
   const I_CHAR * const SHRHLDR_CATEGORY      = I_ ( "3" );
   const I_CHAR * const TUP_AMOUNT_TYPES      = I_("U,D,P,S");
   const I_CHAR * const TUP_TRANS_TYPES       = I_("PW,TR,XR,AF,AW,EO,MF,AT,AF91,AFTR,TO04,TO08,PW71,PW72,PW98");
   const I_CHAR * const TUP_REDEMPTIONS       = I_("PW,AF,AW,MF,AF91,PW71,PW72");
   const I_CHAR * const TUP_TRANSFERS         = I_("TR,AFTR,TO04,AT,TO08");
   const I_CHAR * const TUP_EXCHANGES         = I_("XR,EO");
   const I_CHAR * const TUP_UNITS             = I_("tupunits");
   const I_CHAR * const PERCENT               = I_("PERCENT");
   const I_CHAR * const TOLUNITS              = I_("TOLUNITS");
   const I_CHAR * const ESTIMATED_UNITS       = I_("ESTUNITS");
   const I_CHAR * const TUP_SHARES1           = I_("TUPSHARES1");
   const I_CHAR * const TUP_SHARES2           = I_("TUPSHARES2");
   const I_CHAR * const FAMILY_RESP_TAX_TYPE        = I_( "M" );
   const I_CHAR * const INDIVIDUAL_RESP_TAX_TYPE    = I_( "9" ); 
   const I_CHAR * const RESP_BENEFICIARY_ENTITY_TYPE = I_( "50" ); 
   const I_CHAR * const ACCOUNTHOLDER_ENTITY_TYPE    = I_( "01" );
   const I_CHAR * const DEPTYPE_CESG_GRANT          = I_( "20" );
   const I_CHAR * const REPAY_REASON_ONLY_QESI_LIST = I_( "Q01,Q02,Q11,Q22,Q23,Q24,Q31,Q32,Q41,Q51,Q91" );
   const I_CHAR * const BLANK_SUBSTITUTION          = I_( " = ;");
   const I_CHAR * const LIFETIME_LIMIT              = I_("LIFETIMELIMIT");
   const I_CHAR * const ANNUAL_LIMIT                = I_("ANNUALLIMIT");
   const I_CHAR * const TO_DATE                     = I_("TODATE");
   const I_CHAR * const REDCODE_CLB_RETURN            = I_( "75" );
   const I_CHAR * const REDCODE_ACES_RETURN           = I_( "76" );   
   const I_CHAR * const REDCODE_CESG_RETURN           = I_( "83" );
   const I_CHAR * const JOINT_ACCOUNT                 = I_( "2" );
   const I_CHAR * const PRIMARY_ACCT_OWNER_SEQ_NUM    = I_( "1" );
   const I_CHAR * const UNASSIGNED_TAX_JURIS          = I_( "0000" );
   const I_CHAR * const INVESTMENT_TYPE_FIX           = I_( "F" );
   const I_CHAR * const INVESTMENT_TYPE_PROGESSIVE    = I_( "P" );
   const I_CHAR * const FORCED_RATE_CONFIG_DERIVED    = I_( "1" );
   const I_CHAR * const FORCED_RATE_FORCED            = I_( "2" );
   //P0186486FN09 - Employee and Agent Account Gap#8A
   const I_CHAR * const EMPLOYEE                      = I_("08"); 
   const I_CHAR * const AGENT                         = I_("09");
   const I_CHAR * const ACCTCAT_ROUTINGCLIENT         = I_("60");
   const I_CHAR * const SWIFT_PAYMENT_METHOD          = I_( "38" );
   
   const int AUTO_BATCHING = 2;
   const I_CHAR * const PEND_TRD_CONTRACT_SUB_LIST    = I_( "00,01,02,03,04,05,06" );
   const I_CHAR * const RDR_ADVICE_PROVIDED           = I_ ("02");
   const I_CHAR * const REDEMPTION_CODE_UC            = I_("UC");	
   const I_CHAR * const DEPOSIT_CODE_UC               = I_("90");

   const I_CHAR * const MODEL_PARENT_FUND_CLASS       = I_("01");
   const I_CHAR * const BLANK_SUBSTITUTION_VALUE      = I_("= ;");
   const I_CHAR * const BASIC_TARNS_TYPE              = I_("ED,ID,TI,TO,AF,PW,AW,TR,XR,EI,EO");
   const I_CHAR * const TRANS_TYPE_TO_BE_FILTERED_BASED_ON_MISC_INFO = I_("ED98,PW98");
   const I_CHAR * const ENT_REGULATION                = I_("ERG");  
   const I_CHAR * const UNIT_TRADE_NOT_ALLOWED        = I_("37");
   const I_CHAR * const GROUPCODE                     = I_("OPT");
   const I_CHAR * const RDSP_TAX_TYPE				  = I_("RS");
   const I_CHAR * const RDSP_BENEFICIARY			  = I_("79");
   const I_CHAR * const CALLING_TYPE                  = I_( "IntraPrice" );
}

namespace PAYMENT_ROUTING
{
   const I_CHAR * const MT103      = I_("01");
   const I_CHAR * const MT202      = I_("02");
   const I_CHAR * const ACH        = I_("05");
}

namespace ACCOUNT_TYPE
{
   const I_CHAR * const INDIVIDUAL_ACCT_LIKE = I_("0,1,2,3");
   const I_CHAR * const CORPORATE_ACCT_LIKE  = I_("4,5,6,7,8,9,F,G");   
}

namespace SETL_LOC_FIELDS
{
   extern CLASS_IMPORT const  BFFieldId SttlInstrReadOnlyAlways[];
   extern CLASS_EXPORT const int numSttlInstrReadOnlyAlways; 
   //From
   extern CLASS_IMPORT const  BFFieldId SttlInstrFrReadOnlyFields[];
   extern CLASS_IMPORT const int numSttlInstrFrReadOnlyFields;
   extern CLASS_IMPORT const  STTL_INSTR_FIELD_MAPPING SttlInstrFrMapping[];
   extern CLASS_IMPORT const int numSttlInstrFrMapping ;
   //To
   extern CLASS_IMPORT const  BFFieldId SttlInstrToReadOnlyFields[];
   extern CLASS_IMPORT const int numSttlInstrToReadOnlyFields;
   extern CLASS_IMPORT const  STTL_INSTR_FIELD_MAPPING SttlInstrToMapping[];
   extern CLASS_IMPORT const int numSttlInstrToMapping ;
}

namespace ifds
{
//substitution sets
   extern CLASS_IMPORT const BFTextFieldId AllTradesTransType;
//BEGIN management company options
   extern CLASS_IMPORT const BFTextFieldId AllFundsTransfers;
   extern CLASS_IMPORT const BFDateFieldId CurrBusDate;
   extern CLASS_IMPORT const BFTextFieldId RepByBranch;
   extern CLASS_IMPORT const BFTextFieldId BrokerBranch;
   extern CLASS_IMPORT const BFTextFieldId ManualSettleDates;
   extern CLASS_IMPORT const BFTextFieldId WireNumDefault;
   extern CLASS_IMPORT const BFTextFieldId CharWireNum;
   extern CLASS_IMPORT const BFTextFieldId WireNumMandatory;
   extern CLASS_IMPORT const BFTextFieldId ValueDateApplic;
   extern CLASS_IMPORT const BFTextFieldId MultiCurrency;
   extern CLASS_IMPORT const BFTextFieldId EFTPurchFuture;
   extern CLASS_IMPORT const BFTextFieldId SrcOfFundMandatory;
   extern CLASS_IMPORT const BFTextFieldId DealDateTime;
   extern CLASS_IMPORT const BFTextFieldId BankSrcAcct;
   extern CLASS_IMPORT const BFTextFieldId CotClient;
   extern CLASS_IMPORT const BFTextFieldId SegClient;
   extern CLASS_IMPORT const BFTextFieldId TradeCutOff;
   extern CLASS_IMPORT const BFTextFieldId SplitAcCode;
   extern CLASS_IMPORT const BFTextFieldId AccountableMandatory;
   extern CLASS_IMPORT const BFTextFieldId InvAdvice;
   extern CLASS_IMPORT const BFTextFieldId TradeDateLag;
   extern CLASS_IMPORT const BFTextFieldId AllowMultiFundTransfer;
   extern CLASS_IMPORT const BFIntegerFieldId CommissionType;
   extern CLASS_IMPORT const BFTextFieldId SysCurrency;
   extern CLASS_IMPORT const BFTextFieldId DefSetlCurrency;
   extern CLASS_IMPORT const BFTextFieldId FundEligSlsRepLvl;
   extern CLASS_IMPORT const BFTextFieldId BrokerFund;
   extern CLASS_IMPORT const BFTextFieldId CurrChkByTaxType;
   extern CLASS_IMPORT const BFTextFieldId CanSuppressConfirm;
   extern CLASS_IMPORT const BFTextFieldId TRExclRedCodes;
   extern CLASS_IMPORT const BFTextFieldId TaxTypeByCurrChk;
   extern CLASS_IMPORT const BFTextFieldId InvalidCurr;
   extern CLASS_IMPORT const BFTextFieldId FundBrokerApplicable;
   extern CLASS_IMPORT const BFTextFieldId BusRounding;
   extern CLASS_IMPORT const BFTextFieldId ValidNetworkType;
   extern CLASS_IMPORT const BFTextFieldId NetworkTypeUpd;
   extern CLASS_IMPORT const BFTextFieldId ROATransType;
   extern CLASS_IMPORT const BFTextFieldId EUSDOption;
   extern CLASS_IMPORT const BFTextFieldId CSSStopSINMatch;
   extern CLASS_IMPORT const BFDateFieldId PSE_EAPEditDate;
   extern CLASS_IMPORT const BFTextFieldId FundSERVClient;
//trade fee defaults
   extern CLASS_IMPORT const BFTextFieldId TransTypeDefault;
   extern CLASS_IMPORT const BFTextFieldId TradeAmtTypeDefault;
   extern CLASS_IMPORT const BFTextFieldId TradePayTypeDefault;
   extern CLASS_IMPORT const BFTextFieldId TradeClearMethodDefault;
   extern CLASS_IMPORT const BFTextFieldId TradeFileProcessorDefault;
   extern CLASS_IMPORT const BFIntegerFieldId TrxSettCurrRefresh;
   extern CLASS_IMPORT const BFDecimalFieldId Rate;
//END management company options
//acount check fields
   extern CLASS_IMPORT const BFTextFieldId DataFound;
//broker/branch/sales rep related fields
   extern CLASS_IMPORT const BFTextFieldId NetAllowed;
   extern CLASS_IMPORT const BFTextFieldId Slsrep;
   extern CLASS_IMPORT const BFTextFieldId VolSettleType;
   extern CLASS_IMPORT const BFTextFieldId AddPerm;
   extern CLASS_IMPORT const BFTextFieldId ValidationPassed;
   extern CLASS_IMPORT const BFTextFieldId FundAllow;
   extern CLASS_IMPORT const BFTextFieldId RoutingType;
   extern CLASS_IMPORT const BFTextFieldId BrokCompliantNW;
   extern CLASS_IMPORT const BFTextFieldId BrokCssStatus;
//fund related fields
   extern CLASS_IMPORT const BFTextFieldId FromFundNumber;
   extern CLASS_IMPORT const BFTextFieldId FundISIN;
   extern CLASS_IMPORT const BFTextFieldId FundWKN;
   extern CLASS_IMPORT const BFTextFieldId FundLFC;
   extern CLASS_IMPORT const BFTextFieldId CUSIP;
   extern CLASS_IMPORT const BFTextFieldId FromCurrency;
   extern CLASS_IMPORT const BFTextFieldId ToCurrency;
   extern CLASS_IMPORT const BFTextFieldId ToFundNumber;
   extern CLASS_IMPORT const BFTextFieldId FundToISIN;
   extern CLASS_IMPORT const BFTextFieldId FundToWKN;
   extern CLASS_IMPORT const BFTextFieldId FundToLFC;
   extern CLASS_IMPORT const BFTextFieldId ToCUSIP;
   extern CLASS_IMPORT const BFTextFieldId WireElig;
   extern CLASS_IMPORT const BFTextFieldId IssueCerts;
   extern CLASS_IMPORT const BFDateFieldId NextNightRun;
   extern CLASS_IMPORT const BFDateFieldId NextSettleDate;
   extern CLASS_IMPORT const BFDateFieldId NextValDate;
   extern CLASS_IMPORT const BFDateFieldId LastValDate;
   extern CLASS_IMPORT const BFTextFieldId Currency;
   extern CLASS_IMPORT const BFDecimalFieldId UnitsPrecision;
   extern CLASS_IMPORT const BFDecimalFieldId UnitValue;
   extern CLASS_IMPORT const BFDecimalFieldId USDollar;
   extern CLASS_IMPORT const BFTextFieldId FundType;
   extern CLASS_IMPORT const BFTextFieldId DividentType;
   extern CLASS_IMPORT const BFTextFieldId IntFromDateType;
   extern CLASS_IMPORT const BFTextFieldId IntToDateType;
   extern CLASS_IMPORT const BFTextFieldId rxFundCode;
   extern CLASS_IMPORT const BFTextFieldId rxClassCode;
   extern CLASS_IMPORT const BFDecimalFieldId SettledUnits;
   extern CLASS_IMPORT const BFDecimalFieldId UnsettledUnits;
   extern CLASS_IMPORT const BFDecimalFieldId SettledValue;
   extern CLASS_IMPORT const BFDecimalFieldId UnsettledValue;
   extern CLASS_IMPORT const BFDecimalFieldId FundNAV;
   extern CLASS_IMPORT const BFTextFieldId ValidSettleCurr;
   extern CLASS_IMPORT const BFTextFieldId FundGroup;
   extern CLASS_IMPORT const BFTextFieldId FundCurrency;
   extern CLASS_IMPORT const BFTextFieldId FundIDType;
   extern CLASS_IMPORT const BFTextFieldId FundIDValue;
   extern CLASS_IMPORT const BFTextFieldId LoadType;
   extern CLASS_IMPORT const BFTextFieldId OverrideDSCAllow;
//account fields
   extern CLASS_IMPORT const BFTextFieldId AcctDesignation;
   extern CLASS_IMPORT const BFTextFieldId InterCode;
   extern CLASS_IMPORT const BFTextFieldId TransFound;
   extern CLASS_IMPORT const BFTextFieldId TaxType;
   extern CLASS_IMPORT const BFTextFieldId DeathStat;
   extern CLASS_IMPORT const BFTextFieldId DeathClaim;
   extern CLASS_IMPORT const BFTextFieldId AcctCommExists;
   extern CLASS_IMPORT const BFTextFieldId DTAType;
   extern CLASS_IMPORT const BFTextFieldId FeeWaived;
   extern CLASS_IMPORT const BFTextFieldId AcctType;
   extern CLASS_IMPORT const BFTextFieldId ClearingID;
   extern CLASS_IMPORT const BFTextFieldId FeeModelCode;
   extern CLASS_IMPORT const BFTextFieldId AcctCategoryExist;
//shareholder fields
   extern CLASS_IMPORT const BFNumericFieldId ShrNum;
   extern CLASS_IMPORT const BFTextFieldId ResProvCode;
   extern CLASS_IMPORT const BFTextFieldId TaxJurisCode;
//AMS fields
   extern CLASS_IMPORT const BFTextFieldId AMSCode;
   extern CLASS_IMPORT const BFTextFieldId WireEleg;
//settle instructions/location fields
   extern CLASS_IMPORT const BFTextFieldId SettlementInstrCode;
   extern CLASS_IMPORT const BFTextFieldId SettleLocationDesc;
   extern CLASS_IMPORT const BFTextFieldId SettleLocationCode;
   extern CLASS_IMPORT const BFTextFieldId Default;
   extern CLASS_IMPORT const BFTextFieldId DeliveryTo;
   extern CLASS_IMPORT const BFTextFieldId InFavourOf;
   extern CLASS_IMPORT const BFTextFieldId ForAccount;
   extern CLASS_IMPORT const BFTextFieldId DefaultSettlementInstr;
   extern CLASS_IMPORT const BFTextFieldId AcctClearingMethod;
   extern CLASS_IMPORT const BFTextFieldId CSDLocation;
   extern CLASS_IMPORT const BFTextFieldId CSDAcctNum;

//unrelated fields
   extern CLASS_IMPORT const BFTextFieldId ProvSales;
   extern CLASS_IMPORT const BFTextFieldId BankAcctCurrency;
   extern CLASS_IMPORT const BFTextFieldId AcctUseCode;
   extern CLASS_IMPORT const BFTextFieldId DepositTypeList;
   extern CLASS_IMPORT const BFTextFieldId RedCodeList;
   extern CLASS_IMPORT const BFDateFieldId SpouseBirth;
   extern CLASS_IMPORT const BFTextFieldId CreateRep;
   extern CLASS_IMPORT const BFTextFieldId InitPurch;
   extern CLASS_IMPORT const BFTextFieldId TransModPerm;   
   extern CLASS_IMPORT const BFTextFieldId CustomScheduleList;
   extern CLASS_IMPORT const BFTextFieldId DftOrdType;
   extern CLASS_IMPORT const BFTextFieldId ForcedRate;
   extern CLASS_IMPORT const BFTextFieldId FundServBroker;
   extern CLASS_IMPORT const BFTextFieldId SplitComm;

//cross-edits
   extern CLASS_IMPORT const BFTextFieldId WireOrdFndCls;
   extern CLASS_IMPORT const BFTextFieldId OrderSourceOrderType;
   extern CLASS_IMPORT const BFTextFieldId NetOrdType;
   extern CLASS_IMPORT const BFTextFieldId AddrCodeEffDate;
   extern CLASS_IMPORT const BFTextFieldId AcctableTradeDate;
   extern CLASS_IMPORT const BFTextFieldId CashDateXEdit;
   extern CLASS_IMPORT const BFTextFieldId AmtTypeGrossNet;
   extern CLASS_IMPORT const BFTextFieldId FromFundClass;
   extern CLASS_IMPORT const BFTextFieldId ToFundClass;
   extern CLASS_IMPORT const BFTextFieldId FromToFundClass;
   extern CLASS_IMPORT const BFTextFieldId AmountAmtType;
   extern CLASS_IMPORT const BFTextFieldId MinFromFundAmount;
   extern CLASS_IMPORT const BFTextFieldId MinToFundAmount;
   extern CLASS_IMPORT const BFTextFieldId AmountPrecision;
   extern CLASS_IMPORT const BFTextFieldId DuplicateTrade;
   extern CLASS_IMPORT const BFTextFieldId FundCodeRedCodeAmount;
   extern CLASS_IMPORT const BFTextFieldId PayTypeBankNum;
   extern CLASS_IMPORT const BFTextFieldId FromSoftCapCheck;
   extern CLASS_IMPORT const BFTextFieldId ToSoftCapCheck;
   extern CLASS_IMPORT const BFTextFieldId SettleSourceNetworkSettleXEdit;
   extern CLASS_IMPORT const BFTextFieldId SettleTypeNetworkSettleXEdit;

//substitution sets
   extern CLASS_IMPORT const BFTextFieldId TradeAttributesFields;
   extern CLASS_IMPORT const BFTextFieldId TradeFeesFields;
//fees fields
   extern CLASS_IMPORT const BFTextFieldId FeeCharge;
//entity id/ids list
   extern CLASS_IMPORT const BFTextFieldId IdType;
   extern CLASS_IMPORT const BFTextFieldId IdValue;
//API fields
   extern CLASS_IMPORT const BFTextFieldId ParticipantID;
   extern CLASS_IMPORT const BFTextFieldId AllowWire;
   extern CLASS_IMPORT const BFTextFieldId MMWire;
   extern CLASS_IMPORT const BFIntegerFieldId SettlePurDays;
   extern CLASS_IMPORT const BFTextFieldId DefaultExchRate;
   extern CLASS_IMPORT const BFTextFieldId FieldAssignment;
// rebook
   extern CLASS_IMPORT const BFNumericFieldId SplitCommRebookTransID;
// ESG Settlement
   extern CLASS_IMPORT const BFTextFieldId ESGSettle;
   extern CLASS_IMPORT const BFTextFieldId SWPSettleESGElig;
   extern CLASS_IMPORT const BFTextFieldId CashIDSettleESGElig;
//EUSD
   extern CLASS_IMPORT const BFTextFieldId EUSDParticip;
//payment instructions related fields
   extern CLASS_IMPORT const BFTextFieldId PaymentFor;
   extern CLASS_IMPORT const BFTextFieldId PayToEntity;

   extern CLASS_IMPORT const BFDateFieldId SettleInDate;
   extern CLASS_IMPORT const BFTextFieldId MFCurrentInvoice;
   extern CLASS_IMPORT const BFTextFieldId DeliveryMethod2;   

   extern CLASS_IMPORT const BFTextFieldId ToSettlCurrency;
   extern CLASS_IMPORT const BFTextFieldId FrSettlCurrency;
   extern CLASS_IMPORT const BFTextFieldId RcptStatus;
   extern CLASS_IMPORT const BFTextFieldId DepTypeTradeDate;
   extern CLASS_IMPORT const BFDateFieldId TradeStartDate;
   extern CLASS_IMPORT const BFDateFieldId TradeStopDate;
   //extern CLASS_IMPORT const BFTextFieldId UnitRoundingApplicable;//Blackrock unit rounding project
   extern CLASS_IMPORT const BFTextFieldId FirstName;
   extern CLASS_IMPORT const BFTextFieldId LastName;
   extern CLASS_IMPORT const BFTextFieldId IsClosedCountryResident;
   extern CLASS_IMPORT const BFTextFieldId TradePayTypeFundClass;
   extern CLASS_IMPORT const BFDecimalFieldId FCFundRate;
   extern CLASS_IMPORT const BFDecimalFieldId FCFundToRate;
   extern CLASS_IMPORT const BFTextFieldId FromHistoryTrade;

   // bank verification
   extern CLASS_IMPORT const BFTextFieldId VerifyStat;
   extern CLASS_IMPORT const BFDecimalFieldId BnkAcctIDLink;

   //value date overriden
   extern CLASS_IMPORT const BFTextFieldId ValueDateOverriden;

   //RESP - QESI / Trading / Association to Beneficiary
   extern CLASS_IMPORT const BFTextFieldId GRRepayReasonQESI;
   extern CLASS_IMPORT const BFTextFieldId GRRepayReasonCommon;
   extern CLASS_IMPORT const BFTextFieldId TaxJuris;
   extern CLASS_IMPORT const BFTextFieldId Residency1;
   extern CLASS_IMPORT const BFTextFieldId Residency2;
   extern CLASS_IMPORT const BFTextFieldId Residency3;
   extern CLASS_IMPORT const BFTextFieldId FlatPrcnt;
   extern CLASS_IMPORT const BFIntegerFieldId WarnCode;
   extern CLASS_IMPORT const BFTextFieldId WarnParam1;
   extern CLASS_IMPORT const BFTextFieldId WarnParam2;
   extern CLASS_IMPORT const BFTextFieldId RESPAcctInfoExists;
   extern CLASS_IMPORT const BFTextFieldId AmtTypeRedCode;
   extern CLASS_IMPORT const BFTextFieldId AmountRedCode;
   extern CLASS_IMPORT const BFTextFieldId PSEProgramLenList;
   extern CLASS_IMPORT const BFTextFieldId PSEProgramTypeList;
   extern CLASS_IMPORT const BFTextFieldId PSEProgramYearList;

   extern CLASS_IMPORT const BFTextFieldId AcctGuarGuardExists;
   extern CLASS_IMPORT const BFNumericFieldId SeqNumber;
   extern CLASS_IMPORT const BFDecimalFieldId AcAmt10Prcnt;
   extern CLASS_IMPORT const BFTextFieldId FundAmtType;
   extern CLASS_IMPORT const BFTextFieldId CommRedRateList;
   extern CLASS_IMPORT const BFDecimalFieldId EstimatedRate;
   extern CLASS_IMPORT const BFDateFieldId InvHisLastIntCrdDate;
   extern CLASS_IMPORT const BFDateFieldId GIMaturityDate;
   extern CLASS_IMPORT const BFTextFieldId AmtOrdType;
   extern CLASS_IMPORT const BFTextFieldId FromSegTradeEntryCheck;
   extern CLASS_IMPORT const BFTextFieldId FromToSegTradeEntryCheck;
   extern CLASS_IMPORT const BFTextFieldId FundRelnCode;
   extern CLASS_IMPORT const BFTextFieldId IsAllocationChanged;
   extern CLASS_IMPORT const BFTextFieldId TaxTypeRuleCurrSet;
   extern CLASS_IMPORT const BFTextFieldId RegAgentCode;
   extern CLASS_IMPORT const BFTextFieldId SrcOfFunds_IA; //P0186486_FN15_The Source of Funds
   extern CLASS_IMPORT const BFTextFieldId RightToCancel;
   extern CLASS_IMPORT const BFTextFieldId RDRAdvice;
   extern CLASS_IMPORT const BFTextFieldId RDREnv;
   extern CLASS_IMPORT const BFTextFieldId RDRApplic;
   extern CLASS_IMPORT const BFTextFieldId RDRDefault;
   extern CLASS_IMPORT const BFDecimalFieldId ForcedRateAmt;
   extern CLASS_IMPORT const BFTextFieldId AWDFieldFlag;
   extern CLASS_IMPORT const BFTextFieldId PymtRoutingMthd;
   extern CLASS_IMPORT const BFTextFieldId TradelevelOveride;
   extern CLASS_IMPORT const BFTextFieldId CatValue;
   extern CLASS_IMPORT const BFTextFieldId AcctCategory;
   extern CLASS_IMPORT const BFTextFieldId XEditEventRecieptDateTime;
   extern CLASS_IMPORT const BFTextFieldId IntCalcMthdList;
   extern CLASS_IMPORT const BFDecimalFieldId TradeAmount;   
   extern CLASS_IMPORT const BFTextFieldId ParentFndClsTrdg;
   extern CLASS_IMPORT const BFTextFieldId AssocFund;
   extern CLASS_IMPORT const BFTextFieldId AssocClass;
   extern CLASS_IMPORT const BFTextFieldId AMSModelType;
   extern CLASS_IMPORT const BFTextFieldId DefaultAlloc;
   extern CLASS_IMPORT const BFDecimalFieldId Level;  
   extern CLASS_IMPORT const BFTextFieldId TimeFactor; 
   extern CLASS_IMPORT const BFTextFieldId NegMoneyMktInt;
   extern CLASS_IMPORT const BFTextFieldId RoundCalcToCents;
   extern CLASS_IMPORT const BFTextFieldId PrcsSpDiv;
   extern CLASS_IMPORT const BFDecimalFieldId NumUnitEligDividends;
   extern CLASS_IMPORT const BFDecimalFieldId NumUnitDividends;
   extern CLASS_IMPORT const BFDecimalFieldId ReinvestmentRate;
   extern CLASS_IMPORT const BFDecimalFieldId DivRate;
   extern CLASS_IMPORT const BFTextFieldId FromFundClassValid;
   extern CLASS_IMPORT const BFTextFieldId ToFundClassValid;
   extern CLASS_IMPORT const BFNumericFieldId UnitId;
   extern CLASS_IMPORT const BFBigDecimalFieldId GAV;
   extern CLASS_IMPORT const BFDecimalFieldId MultiPriceUsageID;
   extern CLASS_IMPORT const BFNumericFieldId DivUnitId;
   extern CLASS_IMPORT const BFNumericFieldId ReInvUnitId;
   extern CLASS_IMPORT const BFTextFieldId DivChqAddr;
   extern CLASS_IMPORT const BFTextFieldId NetworkConfigType;
   extern CLASS_IMPORT const BFTextFieldId NetworkConfigValue;
   extern CLASS_IMPORT const BFTextFieldId IsNetworkSettleEligible;
   extern CLASS_IMPORT const BFTextFieldId Cancelled;
   extern CLASS_IMPORT const BFTextFieldId Reversal;
   extern CLASS_IMPORT const BFTextFieldId AdvisorFeeAppl;
   extern CLASS_IMPORT const BFTextFieldId TradeTransTypeOverrideDescription;
   extern CLASS_IMPORT const BFTextFieldId SiblingOnly;
   extern CLASS_IMPORT const BFTextFieldId SettleAccountNum;
   extern CLASS_IMPORT const BFTextFieldId InternalSettlementAccount;
   extern CLASS_IMPORT const BFTextFieldId ContractType;
   extern CLASS_IMPORT const BFTextFieldId G1G2UnitsXEdit;
   extern CLASS_IMPORT const BFTextFieldId NotApplicable;
   extern CLASS_IMPORT const BFTextFieldId StopFlagSeverityCode;
   extern CLASS_IMPORT const BFTextFieldId DepTypeExternalInstitution;
   extern CLASS_IMPORT const BFTextFieldId RedCodeExternalInstitution;
   extern CLASS_IMPORT const BFTextFieldId InterClassSwitch;
   extern CLASS_IMPORT const BFTextFieldId Deconversion;
   extern CLASS_IMPORT const BFIntegerFieldId UnitsPrecisionAcct;
   extern CLASS_IMPORT const BFDateFieldId EligDateforCLB;
   extern CLASS_IMPORT const BFTextFieldId PriceTypes;
   extern CLASS_IMPORT const BFDateFieldId TaxJurisDeff;
   extern CLASS_IMPORT const BFDateFieldId DofBirth;
   extern CLASS_IMPORT const BFTextFieldId GRRepayReasonRDSP;
   extern CLASS_IMPORT const BFTextFieldId FullMoneyOutIndc;
   extern CLASS_IMPORT const BFTextFieldId ExtAccount;
   extern CLASS_IMPORT const BFTextFieldId ExtSpecimenPlanNo;
   extern CLASS_IMPORT const BFDecimalFieldId NontaxContrib;
   extern CLASS_IMPORT const BFDecimalFieldId Rollovers;
   extern CLASS_IMPORT const BFDecimalFieldId CDSGrant;
   extern CLASS_IMPORT const BFDecimalFieldId CDSBond;
   extern CLASS_IMPORT const BFDecimalFieldId CurrYrFMV;
   extern CLASS_IMPORT const BFDecimalFieldId PrevYrGrantBond;
   extern CLASS_IMPORT const BFDecimalFieldId PrevYrContrib;
   extern CLASS_IMPORT const BFDecimalFieldId PrevYrNonTaxRedAmt;
   extern CLASS_IMPORT const BFDecimalFieldId PrevYrTaxRedAmt;
   extern CLASS_IMPORT const BFDecimalFieldId CurrYrNonTaxRedAmt;
   extern CLASS_IMPORT const BFDecimalFieldId CurrYrTaxRedAmt;
   extern CLASS_IMPORT const BFDateFieldId RDSPPaymtDate;
   extern CLASS_IMPORT const BFTextFieldId LiqRedFeeExist;
}

namespace CND
{  // Conditions used
//account
   extern const long ERR_INVALID_ACCOUNT_NUMBER;
//wire order, order type
   extern const long ERR_WIRE_NUM_NOT_NUMERIC;
   extern const long AMS_ERR_TRADE_WIRE_ORDER_NOT_ALLOWED;
   extern const long ERR_ONLY_10_CHARATERS_ALLOWED; 
   extern const long WARN_ONLY_10_CHARATERS_ALLOWED;
   extern const long ERR_ONLY_20_CHARATERS_ALLOWED;
   extern const long ERR_WIRE_ORDER_NOT_ALLOWED_FOR_FUND;
   extern const long ERR_INVALID_ORDERSRC_FOR_ACCT_DESIGNATION;
   extern const long ERR_WARN_INVALID_ORDERSRC_FOR_ACCT_DESIGNATION;
   extern const long ERR_ORDERSRC_INVALID_FOR_WIRE_ORDER;
   extern const long ERR_WIRE_ORDER_NUMBER_REQUIRED;
   extern const long WARN_WIRE_ORDER_NUMBER_REQUIRED;
//banking
   extern const long ERR_MISS_BANK_ACCT_INFO;
   extern const long WARN_SHAREHOLDER_HAS_MULTIPLE_ACTIVE_BANK_ACCOUNTS;
   extern const long ERR_EFT_FULL_REDEMPTION_NOT_ALLOWED;
//clearing/settlement location
   extern const long ERR_TRADE_PAY_TYPE_INVALID_FOR_NON_CLEARING_ACCOUNT;
   extern const long ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_CLEARING_ACCOUNT;
   extern const long ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_TRANSACTION_TYPE;
   extern const long ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_FUNDSETTLE_ACCOUNT;
   extern const long ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_VESTIMA_ACCOUNT;
   extern const long ERR_TRADING_SETTLEMENT_LOCATION_INVALID_CODE_FOR_CLEARING_ACCOUNT;
   extern const long ERR_CLEARING_METHOD_REALIGNMENT_APPLICABLE_TO_FROM_AND_TO_CLEARING_ACCOUNTS;
   extern const long ERR_FROM_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_FUND;
   extern const long ERR_TO_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_FUND;
   extern const long ERR_FROM_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_CLASS;
   extern const long ERR_TO_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_CLASS;
   extern const long ERR_FROM_CLEARING_METHOD_CCY_ONLY_FOR_SAME_SETTLE_CURR_FUND_CURR;
   extern const long ERR_TO_CLEARING_METHOD_CCY_ONLY_FOR_SAME_SETTLE_CURR_FUND_CURR;
   extern const long WARN_TRADE_SETTLEMENT_INSTRUCTIONS_MISSING_ACCT_LEVEL_DEFAULT;
   extern const long ERR_SETTLEMENT_LOCATION_CODE_FOR_ACCOUNT_DOES_NOT_EXIST_AT_SYSTEM_LEVEL;
//account validation   
   extern const long ERR_RESP_TRADE_NOT_ALLOW;
   extern const long WARN_RESP_TRADE_NOT_ALLOW;
   extern const long ERR_ACCT_NOT_DTA_ELIGIBLE;
   extern const long ERR_CONTRACT_ACCT_STATUS_INACTIVE;
   extern const long ERR_WARN_CONTRACT_ACCT_STATUS_INACTIVE;
   extern const long ERR_TRADING_NOT_ALLOWED_WITHOUT_ACCT_SPLIT_COMM;
   extern const long ERR_ACCTHOLDER_DOFB_MISSING;
   extern const long ERR_WARN_ACCTHOLDER_BIRTHDAY_MISSING;
   extern const long ERR_TRADING_SETTLEMENT_LOCATION_HAS_NOT_BEEN_SETUP_FOR_CLEARING_ACCOUNT;
   extern const long ERR_SPOUSE_BIRTHDAY_MISSING;
   extern const long ERR_WARN_SPOUSE_BIRTHDAY_MISSING;
   extern const long WARN_NO_TRADING_SETTLEMENT_LOCATION;
//funds validation
   extern const long ERR_INVALID_FUND_CLASS_CODES;
   extern const long ERR_WARN_FUND_IN_FOREIGN_CURRENCY;
   extern const long ERR_ERR_FUND_IN_FOREIGN_CURRENCY;
   extern const long ERR_FUND_CLASS_NOT_AVAILABLE_FOR_BROKER;
   extern const long ERR_FUND_CLASS_NOT_AVAILABLE_FOR_SALESREP;
   extern const long WARN_INVALID_FUND_NUMBER;
   extern const long WARN_INVALID_ISIN_NUMBER;
   extern const long WARN_INVALID_WKN_NUMBER;
   extern const long WARN_INVALID_LFC_NUMBER;
   extern const long WARN_INVALID_CUSIP_NUMBER;
   extern const long ERR_INVALID_ISIN_NUMBER;
   extern const long ERR_INVALID_WKN_NUMBER;
   extern const long ERR_INVALID_LFC_NUMBER;
   extern const long ERR_INVALID_CUSIP_NUMBER;
   extern const long ERR_TRANSFER_NOT_ALLOWED;
   extern const long ERR_FUND_NOT_PUEV_CAPABLE;
   extern const long ERR_NET_TRADE_NOT_ALLOWED_FOR_THIRD_PARTY_FUNDS;
   extern const long ERR_Net_SETTLEMENT_NOT_ALLOWED;
   extern const long WARN_Net_SETTLEMENT_NOT_ALLOWED;
// funds validation for backdated trades
   extern const long ERR_TRADE_BACKDATED_SUBSEQUENT_OUT_EXISTS;
   extern const long WARN_TRADE_BACKDATED_SUBSEQUENT_OUT_EXISTS;
//deposit type
   extern const long ERR_DEPOSIT_TYPE_23_NOT_SUPPORT;
   extern const long ERR_DEPOSIT_TYPE_24_NOT_SUPPORTED;
//exch rate
   extern const long ERR_EXCH_RATE_MUST_BE_NUMERIC;
   extern const long ERR_NEGATIVE_EXCH_RATE_NOT_ALLOW;
//dates, deal time
   extern const long ERR_INVALID_TIME;
   extern const long ERR_BACKDATE_TRADE_NOT_ALLOWED;
   extern const long ERR_TRADE_DATE_IN_PRIOR_YEAR;
   extern const long ERR_FUTURE_DATED_TRADE;
   extern const long ERR_SETTLEDATE_EARLIER_THAN_TRADEDATE;
   extern const long ERR_SETTLEDATE_EARLIER_THAN_NEXT_CYCLEDATE;
   extern const long ERR_DEPOSIT_DATE_AFFECT_MIN_MAX_AMT;
   extern const long ERR_FUTURE_DEAL_DATE;
//accountability,back dated reason
   extern const long ERR_ACCOUNTABILITY_FOR_BACKDATE_TRADE;
   extern const long ERR_BACKDATEDREASON_FOR_BACKDATE_TRADE;
   extern const long ERR_ACCOUNTABILITY_ONLY_FOR_BACKDATE_TRADE;
//certificate required
   extern const long ERR_CERT_NOT_FOR_FUND_CLASS;
//settle type
   extern const long ERR_INVALID_SETTLEMENT_TYPE_FOR_DEALER_OR_INTERMEDIARY;
   extern const long ERR_WARN_INVALID_SETTLEMENT_TYPE_FOR_DEALER_OR_INTERMEDIARY;
//broker / sales rep validation /fund broker
   extern const long ERR_NON_HOUSE_BROKER_CAN_NOT_DO_DIRECT_TRADING;
   extern const long ERR_SALS_CODE_HAS_TO_BE_5;
   extern const long WAR_SALS_CODE_HAS_TO_BE_5;
   extern const long ERR_SALES_CODE_CAN_NOT_LONGER_THAN_6;
   extern const long ERR_FUND_BROKER_IS_NOT_EFFECTIVE;
   extern const long ERR_FUND_BROKER_NOT_ELIGIBLE_TO_TRADE_FUND;
   extern const long ERR_FUND_INVESTRO_CAPABLE_WHILE_FUND_BROKER_IS_NOT;
   extern const long WARN_FUND_INVESTRO_CAPABLE_WHILE_FUND_BROKER_IS_NOT;
   extern const long ERR_FUND_BROKER_INVESTRO_CAPABLE_WHILE_FUND_IS_NOT;
   extern const long WARN_FUND_BROKER_INVESTRO_CAPABLE_WHILE_FUND_IS_NOT;
//amount,  amt type, gross net validation
   extern const long ERR_UNIT_NOT_FOR_ALLOCATION;
   extern const long ERR_INVALID_NEGATIVE_AMOUNT;
   extern const long ERR_AMOUNT_EXCEED_MAX_LIMIT;
   extern const long ERR_PERCENTAGE_HOLDINGS_OVER_100;
   extern const long ERR_ZERO_AMOUNT_ALL_FREE_UNITS;
   extern const long ERR_FULL_WITHDRAW_FOR_OMNIBUS_ACCT;
   extern const long ERR_TWO_DECIMAL_POINT_ONLY;
   extern const long ERR_AMOUNT_TYPE_INVALID_FOR_3_RD_PARTY_FUNDS_WITH_FUNDBROKER;
   extern const long ERR_AMOUNT_TYPE_INVALID_FOR_3_RD_PARTY_FUNDS_VIA_NETWORK;
   extern const long ERR_AMOUNT_TYPE_INVALID_FOR_DEPOT_FUNDS;
   extern const long ERR_AMOUNT_TYPE_INVALID_FOR_SPECIAL_FUNDS;
//currency
   extern const long ERR_TAX_TYPE_CANNOT_TRADE_IN_THE_CURRENCY;
   extern const long ERR_FROM_TO_CURRENCIES_DO_NOT_MATCH;
//red code validation
   extern const long ERR_WARN_SPOUSAL_CONSENT_WAIVER_REQUIRED;
   extern const long ERR_SPOUSAL_CONSENT_WAIVER_REQUIRED;
   extern const long ERR_WARN_SPOUSAL_CONSENT_REQUIRED;
   extern const long ERR_SPOUSAL_CONSENT_REQUIRED;
   extern const long ERR_SIN_MISSING_FOR_SPOUSE;
   extern const long ERR_SIN_MISSING_SPOUSAL_TRANSFEREE;
//
   extern const long WARN_RESP_SPECIFIC_EDIT_CHECK_NOT_PERFORMED;
   extern const long ERR_RESP_SPECIFIC_EDIT_CHECK_NOT_PERFORMED;
//other confirm type
   extern const long ERR_CONFIRM_TYPE_ONLY_VALID_FOR_SWIFT;
   extern const long ERR_ACCOUNT_FUND_NOT_PUEV_CAPABLE;
   extern const long ERR_INVALID_CONFIRM_TYPE_FOR_NETWORKID;
   extern const long ERR_NETWORKID_NOT_VALID_FOR_MANUAL_TRADES;
//api specific condition codes
   extern const long ERR_NO_MATCHING_BIC_CODE_FOUND;
   extern const long WARN_NO_MATCHING_BIC_CODE_FOUND;
   extern const long ERR_SENDER_REF_NUM_REQUIRED;
   extern const long WARN_SENDER_REF_NUM_REQUIRED;
   extern const long ERR_FUND_CURRENCIES_NOT_MATCHING;

   extern const long ERR_SETTLEMENT_SOURCE_NOT_FOR_ACCT_DESIGNATION;
   extern const long ERR_WARN_SETTLEMENT_SOURCE_NOT_FOR_ACCT_DESIGNATION;
   extern const long ERR_INVALID_INTERMEDIARY_FOR_WIRE_ORDERS;
   extern const long ERR_WARN_INVALID_INTERMEDIARY_FOR_WIRE_ORDERS;
   extern const long ERR_INVALID_INTERMEDIARY_FOR_MONEY_MARKET_WIRE_ORDERS;
   extern const long ERR_WARN_INVALID_INTERMEDIARY_FOR_MONEY_MARKET_WIRE_ORDERS;
   extern const long ERR_INVALID_BROKER_FOR_MONEY_MARKET_WIRE_ORDERS;
   extern const long WARN_INVALID_BROKER_FOR_MONEY_MARKET_WIRE_ORDERS;
   extern const long ERR_INVALID_DEALER_FOR_ORDER_SETTLEMENT_BY_INTERMEDIARY;
   extern const long ERR_WARN_INVALID_DEALER_FOR_ORDER_SETTLEMENT_BY_INTERMEDIARY;
   extern const long ERR_DEALER_INFO_MISSING_FOR_BROKER;
   extern const long WARN_DEALER_INFO_MISSING_FOR_BROKER;  
   extern const long ERR_EXCLUDE_IS_NOT_ALLOWED;
   extern const long ERR_ONLY_EXCLUDE_MCH_FOR_THIRDPARTYFUNDS;
   extern const long ERR_INVALID_SETTLEINDATE;

   extern const long ERR_INVALID_MF_PAYMENT;
   extern const long WARN_INVALID_MF_PAYMENT;
   extern const long ERR_INVALID_PAYMENT_METHOD;

   extern const long ERR_SETTLEMENT_INSTRUCTIONS_EXPIRED_AS_OF;
   extern const long WARN_NON_RESIDENT_TAX_JURID;
   extern const long ERR_NON_RESIDENT_TAX_JURID;
   extern const long ERR_CONTRIBUTION_NOT_ALLOWED_FOR_NON_RESIDENT ;
   extern const long WARN_CONTRIBUTION_NOT_ALLOWED_FOR_NON_RESIDENT ;
   extern const long ERR_TRADE_DATE_OUTSIDE_MIN_MAX;
   extern const long WARN_ASSOCIATED_ENTITY_NOT_PROVIDED;
   extern CLASS_IMPORT const long ERR_NO_BRANCH_FOUND;
   extern const long ERR_AGENT_NOT_FOUND_FOR_BROKER_BRANCH;
   extern const long ERR_CLOSED_COUNTRY_RESIDENT_FOR_MONEY_IN;
   extern const long ERR_AMOUNT_MISMATCH;
   extern const long ERR_SETTL_LOC_IS_MISSING;
   extern const long WARN_SETTL_LOC_IS_MISSING;
   extern const long ERR_UNVERIFIED_BANK;
   extern const long WARN_UNVERIFIED_BANK;
   extern const long ERR_ADDRESS_NOT_VERIFY;
   extern const long WARN_ADDRESS_NOT_VERIFY;
   // Money out validations
   extern const long ERR_TUP_CALCULATION_ERROR;
   extern const long WARN_TUP_CALCULATION_ERROR;
   extern const long ERR_TRADED_UNIT_POSITION;
   extern const long WARN_TRADED_UNIT_POSITION;
   extern const long WARN_TUP_TOLERANCE_PERCENT;
   extern const long WARN_TUP_TOLERANCE_UNITS;
   extern const long WARN_TUP_ESTIMATED_UNITS;
   extern const long ERR_TUP_ESTIMATED_UNITS;
   extern const long ERR_TUP_SHARES;
   extern const long WARN_TUP_SHARES;
   extern const long WARN_TUP_FULLMONEYOUT_PENDING_TRADE_EXISTS;
   extern const long ERR_RESP_BENEF_ALLOCATIONS_MISSING;  
   extern const long ERR_INVALID_CESG_REPAYMENT_REASON_CODE;
   extern const long WARN_INVALID_CESG_REPAYMENT_REASON_CODE; 
   extern const long ERR_SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED;
   extern const long WARN_SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED;
   extern const long ERR_REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES;
   extern const long WARN_REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES;
   extern const long WARN_INELIG_RESP_TRANSFER_TRIGGER_GRANT_REPAYMENT;
   extern const long ERR_REDEMPTION_CODE_IS_INVALID_BENEFICIARY_IS_NON_RESIDENT;
   extern const long WARN_REDEMPTION_CODE_IS_INVALID_BENEFICIARY_IS_NON_RESIDENT;
   extern const long ERR_REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES;
   extern const long WARN_REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES;
   extern const long ERR_RESP_PLAN_LIMIT_EXCEEDED;
   extern const long WARN_RESP_PLAN_LIMIT_EXCEEDED;
   extern const long ERR_RESP_YEAR_LIMIT_EXCEEDED;
   extern const long WARN_RESP_YEAR_LIMIT_EXCEEDED;

   extern const long WARN_NO_RESP_BENEFICIARY_SELECTED;
   extern const long ERR_NO_RESP_BENEFICIARY_SELECTED; 
   extern const long ERR_NO_ORIGINATING_CONTRIBUTION_SELECTED;
   extern const long WARN_NO_ORIGINATING_CONTRIBUTION_SELECTED; 
   extern const long ERR_RESP_REDEMPTION_EXCEED_CONTRIBUTION;
   extern const long ERR_RESP_REDEMPTION_EXCEED_EARNINGS;
   extern const long ERR_REDEMPTION_EXCEEDS_GRANT_PLUS_EARNINGS;
   extern const long ERR_CESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION;
   extern const long WARN_RESP_REDEMPTION_EXCEED_CONTRIBUTION;
   extern const long WARN_RESP_REDEMPTION_EXCEED_EARNINGS;
   extern const long WARN_REDEMPTION_EXCEEDS_GRANT_PLUS_EARNINGS;
   extern const long WARN_CESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION;
   extern const long ERR_RESP_ACCOUNT_INFO_MISSING;
   extern const long ERR_AMOUNT_TYPE_NOT_VALID_FOR_REDCODE;
   extern const long ERR_SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED;
   extern const long WARN_SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED;
   extern const long WARN_RESP_TRANSACTION_AMT_EQ_LESS_FIFTHY_THSND;
   extern const long WARN_RESP_TRANSACTION_MIGHT_TRIGGER_GRANT_REPAYMENT;
   extern const long ERR_YTD_CONTRIBUTION_WILL_BE_NEGATIVE;
   extern const long WARN_YTD_CONTRIBUTION_WILL_BE_NEGATIVE;
   extern const long ERR_EAP_AMOUNT_EXCEEDS_MARKET_VALUE;
   extern const long WARN_EAP_AMOUNT_EXCEEDS_MARKET_VALUE;
   extern const long ERR_NOT_ENOUGH_GRANT_AMOUNT_FOR_RETURN;    
   extern const long WARN_NOT_ENOUGH_GRANT_AMOUNT_FOR_RETURN;     
   extern const long ERR_INSUFFICIENT_QESI_GRANTS;       
   extern const long WARN_INSUFFICIENT_QESI_GRANTS;   		
   extern const long ERR_NO_LIFETIME_CONTRIB_LIMIT_SET_UP;
   extern const long WARN_NO_LIFETIME_CONTRIB_LIMIT_SET_UP;
   extern const long ERR_REDEMPTION_EXCEED_REMAINING_CONTRIB;
   extern const long WARN_REDEMPTION_EXCEED_REMAINING_CONTRIB;
   extern const long ERR_COURSE_LEN_BETWEEN_1_AND_52_WEEKS;
   extern const long ERR_COURSE_START_DATE_MANDATORY;
   extern const long ERR_QESI_LIFE_TIME_GRANT_LIMIT_EXCEEDED;
   extern const long WARN_QESI_LIFE_TIME_GRANT_LIMIT_EXCEEDED;
   extern const long ERR_REFUND_OF_SPECIAL_TAXES_EXCEED_REDEMPTION;
   extern const long WARN_REFUND_OF_SPECIAL_TAXES_EXCEED_REDEMPTION;
   extern const long ERR_COURSE_LEN_BETWEEN_1_AND_52_WEEKS;
   extern const long ERR_COURSE_START_DATE_MANDATORY;
   extern const long WARN_UPDATE_NOTIONAL_DATA;
   extern const long ERR_TAX_YEAR_EMPTY;
   extern const long ERR_TAX_YEAR_FUTURE_DATED;
   extern const long ERR_BENEFICIARY_NOT_QUEBEC_RESIDENT;
   extern const long WARN_BENEFICIARY_NOT_QUEBEC_RESIDENT;
   extern const long ERR_BENEFICIARY_IS_OVER_18;
   extern const long WARN_BENEFICIARY_IS_OVER_18;
   extern const long ERR_NET_ANNUAL_CONTRIBUTION_IS_ZERO;
   extern const long WARN_NET_ANNUAL_CONTRIBUTION_IS_ZERO;
   extern const long ERR_QESI_BASIC_LIMIT_EXCEEDED_FOR_YEAR;
   extern const long WARN_QESI_BASIC_LIMIT_EXCEEDED_FOR_YEAR;
   extern const long ERR_QESI_INCREASE_LIMIT_EXCEEDED_FOR_YEAR;
   extern const long WARN_QESI_INCREASE_LIMIT_EXCEEDED_FOR_YEAR;
   extern const long ERR_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_BASIC_HAS_EXCEEDED;
   extern const long WARN_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_BASIC_HAS_EXCEEDED;
   extern const long ERR_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_INCREASE_HAS_EXCEEDED;
   extern const long WARN_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_INCREASE_HAS_EXCEEDED;
   extern const long ERR_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_UNASSISTED_AMOUNT;
   extern const long WARN_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_UNASSISTED_AMOUNT;
   extern const long ERR_BENEFICIARY_NOT_ELIGIBLE_FOR_QESI_INCREASE_NOT_SIBLINGONLY;
   extern const long WARN_BENEFICIARY_NOT_ELIGIBLE_FOR_QESI_INCREASE_NOT_SIBLINGONLY;
   extern const long ERR_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_AVAILABLE_ASSISTED_AMOUNT;
   extern const long WARN_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_AVAILABLE_ASSISTED_AMOUNT;
   extern const long ERR_QESI_GRANT_REQUEST_NOT_AVAILABLE_FOR_BENEFICIARY;
   extern const long WARN_QESI_GRANT_REQUEST_NOT_AVAILABLE_FOR_BENEFICIARY;
   extern const long ERR_QESI_AMOUNT_GREATER_THAN_10_PRCNT_OF_EXISTING_QESI_UNASSISTED_AMOUNT;
   extern const long WARN_QESI_AMOUNT_GREATER_THAN_10_PRCNT_OF_EXISTING_QESI_UNASSISTED_AMOUNT;
   extern const long WARN_ASSISTED_AMT_IS_ZERO;
   extern const long ERR_NOT_APPLICABLE_DEPTYPE_REDCODE;
   extern const long ERR_QESI_DP_RD_NOT_ALLOWED;
   extern const long WARN_QESI_DP_RD_NOT_ALLOWED;
   extern const long ERR_ACADEMIC_YEAR_LENGTH_REQUIRED;
   extern const long ERR_EDUCATION_INST_POST_CODE_AND_COUNTRY_NAME_REQUIRED;
   extern const long ERR_ACADEMIC_DAY_MUST_BE_01;
   extern const long ERR_PSE_YEAR_INVALID;
   extern const long ERR_PSE_LEN_INVALID;
   extern const long ERR_PSE_TYPE_INVALID;
   extern const long ERR_DEPTYPE_REDCODE_CAN_NOT_BE_USED_WITH_CURR_YEAR;
   extern const long ERR_REDEMP_CONTRARY_CLIENT_GUAGUARD_PROTECTION;
   extern const long WARN_REDEMP_CONTRARY_CLIENT_GUAGUARD_PROTECTION;
   extern const long ERR_TRANSFER_CONTRARY_CLIENT_GUAGUARD_PROTECTION;
   extern const long WARN_TRANSFER_CONTRARY_CLIENT_GUAGUARD_PROTECTION;
   extern const long ERR_GUAGUARD_NOT_SAME_BETWEEN_TO_TI;
   extern const long WARN_GUAGUARD_NOT_SAME_BETWEEN_TO_TI;
   extern const long ERR_ASSOCIATED_ENTITY_NOT_PROVIDED;
   extern const long ERR_AIP_ENTITY_NOT_CANADIEN;
   // AIP
   extern const long ERR_ENTITY_ADDRESS_IS_MISSING;
   extern const long WARN_ENTITY_ADDRESS_IS_MISSING;
   extern const long ERR_AIP_TO_NONRESIDENT_NOT_ALLOWED;
   extern const long WARN_AIP_TO_NONRESIDENT_NOT_ALLOWED;
   extern const long ERR_TAX_JURIS_NOT_FOUND_FOR_OWNER;
   extern const long WARN_TAX_JURIS_NOT_FOUND_FOR_OWNER;
   extern const long ERR_SYS_TRIG_AMEND_AND_RECAL_QESI_NOTIONAL_BALANCE;
   extern const long WARN_SYS_TRIG_AMEND_AND_RECAL_QESI_NOTIONAL_BALANCE;
   // IN2291872
   extern const long ERR_REDEMPT_AMT_EXCEEDED_QESI_AMT_RECEIVED;
   extern const long WARN_REDEMPT_AMT_EXCEEDED_QESI_AMT_RECEIVED;

   extern const long ERR_FUND_CLASS_AMOUNT_TRADE_STOP_FLAG_ON;
   extern const long WARN_FUND_CLASS_AMOUNT_TRADE_STOP_FLAG_ON;
   //EAP: P0185010.FN02.R02.01 - Delivering EAP written notice and tax info return
   extern const long ERR_BENEF_ADDRESS_IS_MISSING;
   extern const long WARN_BENEF_ADDRESS_IS_MISSING;
   extern CLASS_IMPORT const long ERR_FEE_PARAMS_NOT_AVAILABLE;
   extern const long ERR_VALUE_BETWEEN_0_AND_100;
   extern const long WARN_INTEREST_EXCEEDS_FIFTEEN;
   extern const long ERR_DEPOSIT_TYPE_40_CANNOT_BE_PLACED;
   extern const long WARN_DEPOSIT_TYPE_40_CANNOT_BE_PLACED;
   extern const long ERR_RED_CODE_40_CANNOT_BE_PLACED;
   extern const long WARN_RED_CODE_40_CANNOT_BE_PLACED;
   extern const long ERR_CONTRACT_TYPE_AND_VERSION_REQUIRED;
   extern const long WARN_CONTRACT_TYPE_AND_VERSION_REQUIRED;
   extern const long ERR_FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT;
   extern const long WARN_FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT;
   extern const long ERR_VARIABLE_DSC_FEE_AMOUNT;
   extern const long WARN_VARIABLE_DSC_FEE_AMOUNT;
   extern const long ERR_TRADE_NOT_ALLOWED_TO_CANCEL;
   extern const long WARN_TRADE_NOT_ALLOWED_TO_CANCEL;
   extern const long ERR_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE;
   extern const long WARN_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE;
   extern const long ERR_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA;
   extern const long WARN_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA;
   extern const long ERR_SEG_VALIDATION_BACKDATED_NOT_ALLOWED;
   extern const long ERR_LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE;
   extern const long WARN_LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE;
   extern const long ERR_USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM;
   extern const long WARN_USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM;
   extern const long ERR_LWA_OPTION_NOT_MATCH;
   extern const long WARN_LWA_OPTION_NOT_MATCH;
   extern const long ERR_LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE;
   extern const long WARN_LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE;
   extern const long ERR_TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED;
   extern const long WARN_TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED;
   extern const long ERR_LWA_AGE_RATE_IS_NOT_APPLICABLE;
   extern const long WARN_LWA_AGE_RATE_IS_NOT_APPLICABLE;
   extern const long ERR_ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME;
   extern const long WARN_ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME;
   //P0186486FN09 - Employee and Agent Account Gap#8A
   extern const long ERR_CHANGE_REPS_IS_NOT_APPLICABLE;
   extern const long WARN_CHANGE_REPS_IS_NOT_APPLICABLE;
   extern const long ERR_REFERENCE_NO_IS_MANDATORY_FOR_SOURCE_OF_FUND;//P0186486_FN15_The Source of Funds
   extern const long WARN_REFERENCE_NO_IS_MANDATORY_FOR_SOURCE_OF_FUND;
   extern const long ERR_SUPPRESS_PAYTYPE_REQUIRED_FOR_FUND_SOURCE; //P0186486_FN15_The Source of Funds
   extern const long WARN_SUPPRESS_PAYTYPE_REQUIRED_FOR_FUND_SOURCE; 
   extern const long ERR_REG_AGENT_NOT_ASSOCIATED;
   extern const long ERR_REGAGENT_BANKING_UNAVILABLE;
   extern const long WARN_REGAGENT_BANKING_UNVERIFIED;
   extern const long ERR_DEFAULT_FUND_BRKR_REQUIRED_FOR_TRADE;
   extern const long WARN_DEFAULT_FUND_BRKR_REQUIRED_FOR_TRADE;
   extern const long WARN_RDR_ADVICE_UPDATED;
   extern const long WARN_DATA_UPDATE_IMPACTS_EXTERNAL_ENV_SICAV;
   extern const long WARN_DATA_UPDATE_IMPACTS_EXTERNAL_ENV_OEIC;
   extern const long ERR_FIRST_TRADE_MUST_BE_TRANSFER;
   extern const long WARN_FIRST_TRADE_MUST_BE_TRANSFER;
   extern const long ERR_EVENT_RECIEPT_DATE_AND_TIME_EMPTY;
   extern const long WARN_EVENT_RECIEPT_DATE_AND_TIME_EMPTY;
   extern const long ERR_FUTURE_DATE;
   extern const long ERR_REQ_FIELD_EMPTY; 
   extern const long ERR_INVALID_TIME_FORMAT;
   extern const long ERR_EAP_REDEMPT_EXCEEDED_EARNING;
   extern const long WARN_EAP_REDEMPT_EXCEEDED_EARNING;
   extern const long ERR_REDEMPTION_DEPOSIT_CODE_NOT_VALID;
   extern const long ERR_INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES;
   extern const long WARN_INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES;
   extern const long ERR_FUND_CLASS_MUST_BE_PARENT_CHILD;
   extern const long ERR_FUND_CLASS_MUST_BE_CHILD;
   extern const long ERR_FUND_CLASS_MUST_BE_PARENT;
   extern const long ERR_TRANSFER_NOT_ALLOWED_CONTRACT_TYPE_AND_OR_VERSION_NOT_THE_SAME;
   extern const long WARN_TRANSFER_NOT_ALLOWED_CONTRACT_TYPE_AND_OR_VERSION_NOT_THE_SAME;

   extern const long ERR_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION;
   extern const long WARN_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION;
   extern const long ERR_SETTLE_TYPE_INDIVIDUAL_NOT_ALLOW_THROUGH_FUNDSERV;
   extern const long WARN_SETTLE_TYPE_INDIVIDUAL_NOT_ALLOW_THROUGH_FUNDSERV;
   extern const long ERR_SETTLE_TYPE_BLOCK_NOT_ALLOW_NOT_THROUGH_FUNDSERV;
   extern const long WARN_SETTLE_TYPE_BLOCK_NOT_ALLOW_NOT_THROUGH_FUNDSERV;
   extern const long WARN_BROKER_DIFFERENT_THAN_ACCOUNT_BROKER;
   extern const long ERR_BROKER_DIFFERENT_THAN_ACCOUNT_BROKER;
   extern const long WARN_BRANCH_DIFFERENT_THAN_ACCOUNT_BRANCH;
   extern const long ERR_BRANCH_DIFFERENT_THAN_ACCOUNT_BRANCH;
   extern const long WARN_SLSREP_DIFFERENT_THAN_ACCOUNT_SLSREP;
   extern const long ERR_SLSREP_DIFFERENT_THAN_ACCOUNT_SLSREP;
   extern const long ERR_SETTLE_NETWORK_APPLIED_TO_CANCELLATION_AND_REBOOK;
   extern const long WARN_SETTLE_NETWORK_APPLIED_TO_CANCELLATION_AND_REBOOK;
   extern const long ERR_TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_SAGESDEFF;
   extern const long WARN_TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_SAGESDEFF;
   extern const long ERR_BENEFICIARY_NOT_SASKATCHEWAN_RESIDENT;
   extern const long WARN_BENEFICIARY_NOT_SASKATCHEWAN_RESIDENT;
   extern const long ERR_SAGES_AMOUNT_TO_BE_RETURNED_BECAUSE_REDEMPTION;
   extern const long WARN_SAGES_AMOUNT_TO_BE_RETURNED_BECAUSE_REDEMPTION;
   extern const long ERR_TERMINATION_NOT_ALLOWED_SAGES_BALANCE_GREATER_THAN_ZERO;
   extern const long WARN_TERMINATION_NOT_ALLOWED_SAGES_BALANCE_GREATER_THAN_ZERO;
   extern const long ERR_INVALID_OR_MISSING_ANNUITANT_SEX;
   extern const long WARN_INVALID_OR_MISSING_ANNUITANT_SEX;
   extern const long ERR_RESP_TRANSACTION_DATE_MUST_BE_GREATER_THAN_PROGRAM_START_DATE;
   extern const long WARN_RESP_TRANSACTION_DATE_MUST_BE_GREATER_THAN_PROGRAM_START_DATE;
   extern const long ERR_RESP_RESIDUAL_GRANT_TRANSFER_NOT_ALLOWED;
   extern const long WARN_RESP_RESIDUAL_GRANT_TRANSFER_NOT_ALLOWED;
   extern const long ERR_AMOUNT_EXCEEDS_BCTESG_BALANCE;
   extern const long WARN_AMOUNT_EXCEEDS_BCTESG_BALANCE;
   extern const long ERR_BENEFICIARY_NOT_BC_RESIDENT;
   extern const long WARN_BENEFICIARY_NOT_BC_RESIDENT;
   extern const long ERR_PSE_INFORMATION_REQUIRED;
   extern const long WARN_PSE_INFORMATION_REQUIRED;
   extern const long ERR_EXTINSTITUTION_NAME_NOT_PROVIDED;
   extern const long WARN_EXTINSTITUTION_NAME_NOT_PROVIDED;
   extern const long ERR_CESG_ADCESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION;
   extern const long WARN_CESG_ADCESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION;
    //seg event
   extern const long ERR_SEG_EVENT_DURING_CREATE_TRADE;
   extern const long WARN_SEG_EVENT_DURING_CREATE_TRADE;
   //Cash Date mandatory
   extern const long ERR_CASH_DATE_MANDATORY;
   extern const long WARN_CASH_DATE_MANDATORY;
   extern const long ERR_BENEF_NOT_ELIGIBLE_FOR_CLB;
   extern const long WARN_BENEF_NOT_ELIGIBLE_FOR_CLB;

   extern const long ERR_INVALID_TRADEINDATE;

   //extern const long ERR_RDSP_BENEFICIARY_MUST_BE_RESIDENT_OF_CANADA;
   //extern const long WARN_RDSP_BENEFICIARY_MUST_BE_RESIDENT_OF_CANADA;
   //extern const long ERR_RDSP_BENEFICIARY_OVER_AGE_OF_CONTRIBUTION;
   //extern const long WARN_RDSP_BENEFICIARY_OVER_AGE_OF_CONTRIBUTION;
   //Pending Trade Allocation
   extern const long ERR_PENDING_ALLOCATION_TRADE; //INC0039323
   extern const long WAR_PENDING_ALLOCATION_TRADE;//INC0039323
   extern const long ERR_FUND_SUBJECT_TO_LIQUIDITY_FEE_MEASURE;
   extern const long WARN_FUND_SUBJECT_TO_LIQUIDITY_FEE_MEASURE;
   extern const long ERR_TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_PURCHASE_DATE;	
   extern const long ERR_INVALID_CASH_DATE;
   extern const long WARN_INVALID_CASH_DATE;
   extern const long ERR_CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE;
   extern const long WARN_CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE;
   extern const long ERR_CASH_DATE_WILL_REMAIN_AS_ASSIGNED;
   extern const long WARN_CASH_DATE_WILL_REMAIN_AS_ASSIGNED;
}

namespace IFASTERR
{
   extern CLASS_IMPORT I_CHAR * const INVALID_SETTLEMENT_SOURCE_FOR_ACCOUNT_DESIGNATION;
   extern CLASS_IMPORT I_CHAR * const DEALER_CANNOT_SETTLE_ORDERS_PLACED_BY_INTERMEDIARY;
   extern CLASS_IMPORT I_CHAR * const INTERMEDIARY_IS_NOT_PERMITTED_TO_ENTER_WIRE_ORDERS;
   extern CLASS_IMPORT I_CHAR * const NOT_PERMITTED_TO_ENTER_MONEY_MARKET_WIRE_ORDERS;
   extern CLASS_IMPORT I_CHAR * const AN_AS_PENSION_PLAN_ACCOUNT;
   extern CLASS_IMPORT I_CHAR * const MAXIMUM_PAYOUT_AMOUNT_IS_EXCEEDED;
   extern CLASS_IMPORT I_CHAR * const TOTAL_REDEMPTION_EXCEEDS_MAXIMUM;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_AMOUNT_IS_GREATER_THAN_ACCOUNT_BALANCE;
   extern CLASS_IMPORT I_CHAR * const REMAINING_MINIMUM_AMOUNT_MUST_BE_PAID_FIRST;
   extern CLASS_IMPORT I_CHAR * const SCHEDULED_PAYMENT_INFORMATION_NOT_AVAILABLE;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_CODE_RULES_NOT_SETUP;
   extern CLASS_IMPORT I_CHAR * const REMAINING_ACCT_BALANCE_IS_INSUFFICIENT;
   extern CLASS_IMPORT I_CHAR * const CONTRACT_ACCOUNT_STATUS_IS_ACTIVE;
   extern CLASS_IMPORT I_CHAR * const MUST_ENTER_A_DEATH_CLAIM_REDEMPTION_CODE;
   extern CLASS_IMPORT I_CHAR * const NO_DEALER_INFORMATION_AVAILABLE_FOR_BROKER_CODE;
   extern CLASS_IMPORT I_CHAR * const MONEY_OUT_TXN_SHOULD_BE_CANCELELD_FIRST;
   extern CLASS_IMPORT I_CHAR * const MATCHING_BIC_CODE_NOT_FOUND;
   extern CLASS_IMPORT I_CHAR * const INVALID_MF_PAYMENT;
   extern CLASS_IMPORT I_CHAR * const NON_RESIDENT_TAX_JURID;
   extern CLASS_IMPORT I_CHAR * const NON_RESIDENT_TAX_JURISD_CONTR_NOT_ALLOWED;
   extern CLASS_IMPORT I_CHAR * const SETTL_LOC_IS_MISSING;
   extern CLASS_IMPORT I_CHAR * const UNVERIFIED_BANK_TRADE;
   extern CLASS_IMPORT I_CHAR * const SHAREHOLDER_ADDRESS_NOT_VERIFIED_FOR_TRADE;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_TUP_OVERSELL;
   extern CLASS_IMPORT I_CHAR * const TRANSFER_TUP_OVERSELL;
   extern CLASS_IMPORT I_CHAR * const EXCHANGE_TUP_OVERSELL;
   extern CLASS_IMPORT I_CHAR * const TUP_CALCULATION_ERROR;
   extern CLASS_IMPORT I_CHAR * const TRADING_ON_RESPACCT_NOT_ALLOWED;
   extern CLASS_IMPORT I_CHAR * const RESP_SPECIFIC_EDIT_CHECK_NOT_PERFORMED;
   // QESI project
   extern CLASS_IMPORT I_CHAR * const NO_RESP_BENEFICIARY_SELECTED;
   extern CLASS_IMPORT I_CHAR * const INVALID_CESG_REPAYMENT_REASON_CODE;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_CODE_IS_INVALID_BENEFICIARY_IS_NON_RESIDENT;   
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES;
   extern CLASS_IMPORT I_CHAR * const RESP_PLAN_LIMIT_EXCEEDED;
   extern CLASS_IMPORT I_CHAR * const RESP_YEAR_LIMIT_EXCEEDED;
   extern CLASS_IMPORT I_CHAR * const RESP_REDEMPTION_EXCEED_CONTRIBUTION;
   extern CLASS_IMPORT I_CHAR * const RESP_REDEMPTION_EXCEED_EARNINGS;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_EXCEEDS_GRANT_PLUS_EARNINGS;
   extern CLASS_IMPORT I_CHAR * const CESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION;
   extern CLASS_IMPORT I_CHAR * const NO_RESP_BENEFICIARY_SELECTED;
   extern CLASS_IMPORT I_CHAR * const NO_ORIGINATING_CONTRIBUTION_SELECTED;
   extern CLASS_IMPORT I_CHAR * const SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED;
   extern CLASS_IMPORT I_CHAR * const YTD_CONTRIBUTION_WILL_BE_NEGATIVE;
   extern CLASS_IMPORT I_CHAR * const EAP_AMOUNT_EXCEEDS_MARKET_VALUE;
   extern CLASS_IMPORT I_CHAR * const NOT_ENOUGH_GRANT_AMT_FOR_RETURN;
   extern CLASS_IMPORT I_CHAR * const INSUFFICIENT_QESI_GRANTS;
   //extern CLASS_IMPORT I_CHAR * const NO_LIFETIME_CONTRIB_LIMIT_SET_UP;
   extern CLASS_IMPORT I_CHAR * const LIFETIME_CONTRIB_LIMITS_NOT_SETUP;
   extern CLASS_IMPORT I_CHAR * const QESI_LIFE_TIME_GRANT_LIMIT_EXCEEDED;
   extern CLASS_IMPORT I_CHAR * const REFUND_OF_SPECIAL_TAXES_EXCEED_REDEMPTION;
   extern CLASS_IMPORT I_CHAR * const BENEFICIARY_NOT_QUEBEC_RESIDENT;
   extern CLASS_IMPORT I_CHAR * const BENEFICIARY_IS_OVER_18;
   extern CLASS_IMPORT I_CHAR * const NET_ANNUAL_CONTRIBUTION_IS_ZERO;
   extern CLASS_IMPORT I_CHAR * const QESI_BASIC_LIMIT_EXCEEDED_FOR_YEAR;
   extern CLASS_IMPORT I_CHAR * const QESI_INCREASE_LIMIT_EXCEEDED_FOR_YEAR;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_BASIC_HAS_EXCEEDED;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_INCREASE_HAS_EXCEEDED;
   extern CLASS_IMPORT I_CHAR * const ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_UNASSISTED_AMOUNT;
   extern CLASS_IMPORT I_CHAR * const BENEFICIARY_NOT_ELIGIBLE_FOR_QESI_INCREASE_NOT_SIBLINGONLY;
   extern CLASS_IMPORT I_CHAR * const ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_AVAILABLE_ASSISTED_AMOUNT;
   extern CLASS_IMPORT I_CHAR * const QESI_GRANT_REQUEST_NOT_AVAILABLE_FOR_BENEFICIARY;
   extern CLASS_IMPORT I_CHAR * const QESI_AMOUNT_GREATER_THAN_10_PRCNT_OF_EXISTING_QESI_UNASSISTED_AMOUNT;
   extern CLASS_IMPORT I_CHAR * const QESI_DP_RD_NOT_ALLOWED;
   extern CLASS_IMPORT I_CHAR * const REDEMP_CONTRARY_CLIENT_GUAGUARD_PROTECTION;
   extern CLASS_IMPORT I_CHAR * const TRANSFER_CONTRARY_CLIENT_GUAGUARD_PROTECTION;
   extern CLASS_IMPORT I_CHAR * const GUAGUARD_NOT_SAME_BETWEEN_TO_TI;
   extern CLASS_IMPORT I_CHAR * const SYS_TRIG_AMEND_AND_RECAL_QESI_NOTIONAL_BALANCE; 
   extern CLASS_IMPORT I_CHAR * const REDEMPT_AMT_EXCEEDED_QESI_AMT_RECEIVED;
   extern CLASS_IMPORT I_CHAR * const RED_CODE_40_CANNOT_BE_PLACED;
   extern CLASS_IMPORT I_CHAR * const DEPOSIT_TYPE_40_CANNOT_BE_PLACED;
   extern CLASS_IMPORT I_CHAR * const CONTRACT_TYPE_AND_VERSION_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT;
   extern CLASS_IMPORT I_CHAR * const VARIABLE_DSC_FEE_AMOUNT;
   extern CLASS_IMPORT I_CHAR * const TRADE_NOT_ALLOWED_TO_CANCEL;
   extern CLASS_IMPORT I_CHAR * const BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE;
   extern CLASS_IMPORT I_CHAR * const BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA;
   extern CLASS_IMPORT I_CHAR * const LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE;
   extern CLASS_IMPORT I_CHAR * const USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM;
   extern CLASS_IMPORT I_CHAR * const LWA_OPTION_NOT_MATCH;
   extern CLASS_IMPORT I_CHAR * const LWA_AGE_RATE_IS_NOT_APPLICABLE;
   extern CLASS_IMPORT I_CHAR * const TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED;
   extern CLASS_IMPORT I_CHAR * const ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME;
   extern CLASS_IMPORT I_CHAR * const CHANGE_REPS_IS_NOT_APPLICABLE;
   extern CLASS_IMPORT I_CHAR * const SUPPRESS_PAYTYPE_REQUIRED_FOR_FUND_SOURCE;
   extern CLASS_IMPORT I_CHAR * const REFERENCE_NO_IS_MANDATORY_FOR_SOURCE_OF_FUND; //P0186486_FN15_The Source of Funds
   extern CLASS_IMPORT I_CHAR * const DEFAULT_FUND_BRKR_REQUIRED_FOR_TRADE;
   extern CLASS_IMPORT I_CHAR * const FIRST_TRADE_MUST_BE_TRANSFER;
   extern CLASS_IMPORT I_CHAR * const EVENT_RECIEPT_DATE_AND_TIME_EMPTY;
   extern CLASS_IMPORT I_CHAR * const EAP_REDEMPT_EXCEEDED_EARNING;
   extern CLASS_IMPORT I_CHAR * const INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES;
   extern CLASS_IMPORT I_CHAR * const TRANSFER_NOT_ALLOWED_CONTRACT_TYPE_AND_OR_VERSION_NOT_THE_SAME;
   extern CLASS_IMPORT I_CHAR * const NET_SETTLEMENT_NOT_ALLOWED_FOR_PURCHASE;

   extern CLASS_IMPORT I_CHAR * const DIFFERNT_SETTLESOURCE_THAN_CANCELLATION;
   extern CLASS_IMPORT I_CHAR * const SETTLE_TYPE_INDIVIDUAL_NOT_ALLOW_THROUGH_FUNDSERV;
   extern CLASS_IMPORT I_CHAR * const SETTLE_TYPE_BLOCK_NOT_ALLOW_NOT_THROUGH_FUNDSERV;
   extern CLASS_IMPORT I_CHAR * const BROKER_DIFFERENT_THAN_ACCOUNT_BROKER;
   extern CLASS_IMPORT I_CHAR * const SETTLE_NETWORK_APPLIED_TO_CANCELLATION_AND_REBOOK;
   extern CLASS_IMPORT I_CHAR * const TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_SAGESDEFF;
   extern CLASS_IMPORT I_CHAR * const BENEFICIARY_NOT_SASKATCHEWAN_RESIDENT;
   extern CLASS_IMPORT I_CHAR * const TERMINATION_NOT_ALLOWED_SAGES_BALANCE_GREATER_THAN_ZERO;
   extern CLASS_IMPORT I_CHAR * const INVALID_OR_MISSING_ANNUITANT_SEX;
   extern CLASS_IMPORT I_CHAR * const RESP_TRANSACTION_DATE_MUST_BE_GREATER_THAN_PROGRAM_START_DATE;
   extern CLASS_IMPORT I_CHAR * const RESP_RESIDUAL_GRANT_TRANSFER_NOT_ALLOWED;
   extern CLASS_IMPORT I_CHAR * const AMOUNT_EXCEEDS_BCTESG_BALANCE;
   extern CLASS_IMPORT I_CHAR * const BENEFICIARY_NOT_BC_RESIDENT;
   extern CLASS_IMPORT I_CHAR * const PSE_INFORMATION_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const UNIT_TRADING_NOT_ALLOWED;

   extern CLASS_IMPORT I_CHAR * const CASH_DATE_MANDATORY;
   extern CLASS_IMPORT I_CHAR * const BENEF_NOT_ELIGIBLE_FOR_CLB;

   //extern CLASS_IMPORT I_CHAR * const RDSP_BENEFICIARY_MUST_BE_RESIDENT_OF_CANADA;
   //extern CLASS_IMPORT I_CHAR * const RDSP_BENEFICIARY_OVER_AGE_OF_CONTRIBUTION;
   extern CLASS_IMPORT I_CHAR * const PENDING_ALLOCATION_NOT_ALLOWED_TRADE;//INC0039323
   extern CLASS_IMPORT I_CHAR * const FUND_SUBJECT_TO_LIQUIDITY_FEE_MEASURE;
   extern CLASS_IMPORT I_CHAR * const INVALID_CASH_DATE;
   extern CLASS_IMPORT I_CHAR * const CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE;
   extern CLASS_IMPORT I_CHAR * const CASH_DATE_WILL_REMAIN_AS_ASSIGNED;
}

namespace DSTC_REQUEST
{
   extern CLASS_IMPORT const DSTCRequest TRANS_NUM;
   extern CLASS_IMPORT const DSTCRequest ACTIVE_BATCH;
   extern CLASS_IMPORT const DSTCRequest TRADE_DATE_LAG_VALIDATION;
   extern CLASS_IMPORT const DSTCRequest GIA_ATTRIBS_INQUIRY;//P0186477 - GIA Money In
}

namespace TRADETYPE
{
   extern CLASS_IMPORT I_CHAR * const ALL_FUND_TRANSFER;
   extern CLASS_IMPORT I_CHAR * const ADMIN_FEE;
   extern CLASS_IMPORT I_CHAR * const EXCHANGE;
   extern CLASS_IMPORT I_CHAR * const MGMT_FEE;
   extern CLASS_IMPORT I_CHAR * const ONE_SIDE_TRADE;
   extern CLASS_IMPORT I_CHAR * const PURCHASE;
   extern CLASS_IMPORT I_CHAR * const PURCHASE_LIKE;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION;
   extern CLASS_IMPORT I_CHAR * const REDEMPTION_LIKE;
   extern CLASS_IMPORT I_CHAR * const EXCHANGE_LIKE;
   extern CLASS_IMPORT I_CHAR * const REINVEST_PURCHASE;
   extern CLASS_IMPORT I_CHAR * const ROLLOVER;
   extern CLASS_IMPORT I_CHAR * const TRANSFER;
   extern CLASS_IMPORT I_CHAR * const TRANSFER_OUT;
   extern CLASS_IMPORT I_CHAR * const TRANSFER_IN;
   extern CLASS_IMPORT I_CHAR * const EXCHANGE_IN;
   extern CLASS_IMPORT I_CHAR * const EXCHANGE_OUT;
   extern CLASS_IMPORT I_CHAR * const DIVIDEND;
   extern CLASS_IMPORT I_CHAR * const AUTO_WITHDRAW;
   extern CLASS_IMPORT I_CHAR * const MANUAL_MGMT_FEE_REBATE;
   extern CLASS_IMPORT I_CHAR * const FOREIGN_CAP_GAIN_ALLOC_ADJUSTMENT;
   extern CLASS_IMPORT I_CHAR * const CUSIP_ROLLOVER;
   extern CLASS_IMPORT I_CHAR * const PTC_PURCHASE;
   extern CLASS_IMPORT I_CHAR * const PTC_REDEMPTION;
   extern CLASS_IMPORT I_CHAR * const PTC_TRANSFER;
   extern CLASS_IMPORT I_CHAR * const PTC_AF;
   extern CLASS_IMPORT I_CHAR * const PTC_AW;
   extern CLASS_IMPORT I_CHAR * const ROLLOVER_EXCHANGE;
   extern CLASS_IMPORT I_CHAR * const MANUAL_DIVIDEND_ADJ;
   extern CLASS_IMPORT I_CHAR * const CAPITAL_GAIN_INCOME_ADJ;
   extern CLASS_IMPORT I_CHAR * const SUPPLEMENTARY_INCOME_ADJ;
   extern CLASS_IMPORT I_CHAR * const FOREIGN_CAPGAIN_ALLOCATION_ADJ;
   extern CLASS_IMPORT I_CHAR * const MGMT_FEE_REBATE_ADJ;
   extern CLASS_IMPORT I_CHAR * const POST_ADJUSTMENT_LIST;
   extern CLASS_IMPORT I_CHAR * const POST_DIVIDEND_ADJUSTMENT_LIST;
   extern CLASS_IMPORT I_CHAR * const ADVISOR_FEE;
   extern CLASS_IMPORT I_CHAR * const INTER_CLASS_SWITCH;
   extern CLASS_IMPORT I_CHAR * const INTER_CLASS_SWITCH_IN;
   extern CLASS_IMPORT I_CHAR * const INTER_CLASS_SWITCH_OUT;
   extern CLASS_IMPORT I_CHAR * const REFUND_REDEMPTION;
   extern CLASS_IMPORT I_CHAR * const PURCHASE_LIKE_2;
}

namespace PAYTYPE
{
   extern CLASS_IMPORT I_CHAR * const CASH;
   extern CLASS_IMPORT I_CHAR * const CLEARING;
   extern CLASS_IMPORT I_CHAR * const DIRECT;
   extern CLASS_IMPORT I_CHAR * const EFT;
   extern CLASS_IMPORT I_CHAR * const SYSTEM_CHEQUE;
   extern CLASS_IMPORT I_CHAR * const SUPPRESS;
   extern CLASS_IMPORT I_CHAR * const DIRECT_DEPOSIT;
   extern CLASS_IMPORT I_CHAR * const MANUAL_CHEQUE;
} 

namespace PAY_TO
{
   extern I_CHAR * const BROKER;
   extern I_CHAR * const BRANCH;
   extern I_CHAR * const SALESREP;
}

namespace PAYMENT_FOR
{
   extern const I_CHAR * REDEMPTION;
}

namespace EUSD_OPTION
{
   extern const I_CHAR * const WITHHOLDING_TAX_ONLY              = I_ ("1");
   extern const I_CHAR * const WITHHOLDING_TAX_OR_EXCHANGE_INFO  = I_ ("3");
}

namespace AcctUseCode
{
   extern const I_CHAR * const DEFAULT;
   extern const I_CHAR * const EFT_PURCHASE;
   extern const I_CHAR * const EFT_REDEMPTION;
   extern const I_CHAR * const ALT_EFT_REDEMPTION;
   extern const I_CHAR * const ALT_EFT_PURCHASE;
}

namespace IFASTERR
{
   extern CLASS_IMPORT I_CHAR * const WIRE_ORDER_ALLOWED_SIZE;
   extern CLASS_IMPORT I_CHAR * const WIRE_ORDER_NUMBER_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const INVALID_ORDER_SOURCE_FOR_ACCOUNT_DESIGNATION;
   extern CLASS_IMPORT I_CHAR * const CONTRACT_ACCOUNT_STATUS_IS_DEATH_STATUS;
   extern CLASS_IMPORT I_CHAR * const ACCOUNT_HOLDERS_BIRTH_DATE_IS_MISSING;
   extern CLASS_IMPORT I_CHAR * const BIRTH_DATE_OF_ACCOUNT_HOLDER_OR_SPOUSE_IS_MISSING;
   extern CLASS_IMPORT I_CHAR * const INVALID_SETTLEMENT_TYPE_FOR_DEALER_INTERMEDIARY;
   extern CLASS_IMPORT I_CHAR * const SALESREPCODE_SHOULD_ONLY_BE_5_CHARACTERS;
   extern CLASS_IMPORT I_CHAR * const FUND_INVESTRO_CAPABLE_WHILE_FUND_BROKER_IS_NOT;
   extern CLASS_IMPORT I_CHAR * const FUND_BROKER_INVESTRO_CAPABLE_WHILE_FUND_IS_NOT;
   extern CLASS_IMPORT I_CHAR * const SPOUSAL_CONSENT_IS_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const SPOUSAL_CONSENT_WAIVER_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const SENDER_REF_NUM_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const FUND_MGMT_CLIENT_SETTLEMENT_INSTR_REQUIRED;
   extern CLASS_IMPORT I_CHAR * const CESG_AMOUNT_TO_BE_RETURNED;
   extern CLASS_IMPORT I_CHAR * const AIP_TO_NONRESIDENT_NOT_ALLOWED; 
   extern CLASS_IMPORT I_CHAR * const ENTITY_ADDRESS_IS_MISSING;  
   extern CLASS_IMPORT I_CHAR * const TAX_JURIS_NOT_FOUND_FOR_OWNER;
   extern CLASS_IMPORT I_CHAR * const BENEF_ADDRESS_IS_MISSING;//P0185010.FN02.R02.01 - Delivering EAP written notice and tax info return
   extern CLASS_IMPORT I_CHAR * const SAGES_AMOUNT_TO_BE_RETURNED;
   extern CLASS_IMPORT I_CHAR * const FUND_IN_FOREIGN_CURRENCY;
   extern CLASS_IMPORT I_CHAR * const INVALID_INSTITUTION_CODE;
   extern CLASS_IMPORT I_CHAR * const EXTINSTITUTION_NAME_NOT_PROVIDED;
   extern CLASS_IMPORT I_CHAR * const CESG_ADCESG_AMOUNT_TO_BE_RETURNED;
   //seg event
   extern CLASS_IMPORT I_CHAR * const SEG_EVENT_DURING_CREATE_TRADE;
}

namespace DATE_VALIDATION
{
   extern const I_CHAR * const DEFAULT_TRADE_DATE  = I_ ("1"); 
   // SETTLE_DATE: view returns the default settlement date (based on trade date and ordertype) if the input settlement date is 
   // less the default settlement date. Use it when settlement date require refresh for changing from direct order to wire order
   extern const I_CHAR * const SETTLE_DATE         = I_ ("2");  
   extern const I_CHAR * const BUSINESS_DATE       = I_ ("3"); 
   extern const I_CHAR * const TRADE_DATE          = I_ ("4");
   extern const I_CHAR * const DEAL_TIME           = I_ ("6");   
   extern const I_CHAR * const VALUE_DATE          = I_ ("7");
   extern const I_CHAR * const DEFAULT_VALUE_DATE  = I_ ("8"); // not a true value handled by view code, a code for more logic on C++ side
   // INPUT_SETTLE_DATE: view validate if the settlement date is a valid settlement date. 
   // view considers the date as valid even it is less than the default settlement date. 
   //Use it when validate settlement date override by the user purposely
   extern const I_CHAR * const INPUT_SETTLE_DATE   = I_ ("9"); 
   extern const I_CHAR * const PAC_LEAP_DATE       = I_ ("10");
}

namespace CONSOL_TYPE
{
   extern const I_CHAR * INDIVIDUAL_PAYMENT;
   extern const I_CHAR * BULKING;
}
namespace UAF
{
   extern CLASS_IMPORT I_CHAR * const BACKDATE_TRADES;
   extern CLASS_IMPORT I_CHAR * const AGGREGATE_OPTION;
   extern CLASS_IMPORT I_CHAR * const TRADING_PURCHASE;
   extern CLASS_IMPORT I_CHAR * const TRADING_EXCHANGE;
   extern CLASS_IMPORT I_CHAR * const TRADING_REDEMPTION;
   extern CLASS_IMPORT I_CHAR * const MCH_AND_SECUR_REC_FILE_INDICATOR;
   extern CLASS_IMPORT I_CHAR * const CTRBT_RCPT_CANCELLATION;
   extern CLASS_IMPORT I_CHAR * const MODIFY_BATCH_ID;
}

namespace FUND_TYPE
{
   extern const I_CHAR * const MONEY_MARKET;
}

namespace CLEARING_METHOD
{
   //Clearning method
   const I_CHAR * const DELIVERYvsPAYMENT          = I_ ("DVP");
   const I_CHAR * const DELIVERYafterPAYMENT       = I_ ("DAP");
   const I_CHAR * const PAYMENTafterDELIVERY       = I_ ("PAD");
   const I_CHAR * const FUNDSETTLE                 = I_ ("FDS");
   const I_CHAR * const FREEofPAYMENT              = I_ ("FOP");
   const I_CHAR * const REALIGNMENT                = I_ ("RLG");
   const I_CHAR * const VESTIMA                    = I_ ("VST");
}

namespace TRADE_VALIDATION_GROUP
{
   //Clearning method
   extern CLASS_EXPORT const long SETTLE_LOCATION  = 1L; 
   extern CLASS_EXPORT const long PSE_EAP  = 2L; 
   extern CLASS_EXPORT const long GIA_ATTRIB  = 4L;
}

namespace FEES
{
   extern const I_CHAR * ACQUISITION;
   extern const I_CHAR * DSC;
   extern const I_CHAR * CLAWBACK;
   extern const I_CHAR * EXCHANGE;
   extern const I_CHAR * EXCHANGE_OUT;
   extern const I_CHAR * EXCHANGE_IN;
   extern const I_CHAR * ADL;
   extern const I_CHAR * PURCHASE_CONDITION_RATE;
   extern const I_CHAR * REINVEST_PURCHASE_CONDITION_RATE;
   extern const I_CHAR * PURCHASE_TRXN;
   extern const I_CHAR * REDEMPTION_TRXN;
   extern const I_CHAR * WITHDRAWAL;
   extern const I_CHAR * EARLY_REDEMPTION;
   extern const I_CHAR * SHORT_TERM_TRANSFER;
   extern const I_CHAR * REDEMPTION;
   extern const I_CHAR * XFER_OUT;
   extern const I_CHAR * XFER_IN;
   extern const I_CHAR * MVA;
   extern const I_CHAR * GIADMIN;
}
namespace PLATFORM
{
   const I_CHAR * const DESKTOP = I_("01"); 
}

namespace NETWORK_CONFIG_TYPE
{
   extern CLASS_IMPORT I_CHAR * const DeliveryNetworkIDs;
}

namespace SOURCE_OF_FUND
{
   extern const I_CHAR *const TRANSITION = I_("24");
}

namespace BANKINGLEVEL
{
   extern CLASS_IMPORT I_CHAR *  const SHAREHOLDER_LEVEL ;
   extern CLASS_IMPORT I_CHAR *  const ACCOUNT_LEVEL ;
   extern CLASS_IMPORT I_CHAR *  const SHAREHOLDER_AND_ACCOUNT_LEVEL ;
}

//this is defined in the RegulatoryValidationErrorList.
namespace REGULATION
{
  extern CLASS_IMPORT const I_CHAR * const SIF ;
}

namespace FROM_TO
{
  const I_CHAR * const FROM = I_("FROM"); 
  const I_CHAR * const TO   = I_("TO"); 
}

const BFCBO::CLASS_FIELD_INFO classFieldInfo[] = {
//  Field DD Id,              State Flags,      Group Flags 
//general trade fields
    { ifds::TradesTransType,                BFCBO::REQUIRED,             0}, 
    { ifds::BatchName,                      BFCBO::REQUIRED  | BFCBO::APPEND_VALUE_TO_SUBST,             0}, 
    { ifds::Trace,                          BFCBO::NONE,                 0}, 
    { ifds::TransNum,                       BFCBO::REQUIRED,             0}, 
    { ifds::GoodBad,                        BFCBO::NONE,                 0}, 
    { ifds::DuplicateTrade,                 BFCBO::NONE,                 0}, //do not validate immediately
	{ ifds::Allocation,                     BFCBO::NONE,                0 },//INC0039323
    //one side or from side
    { ifds::AccountNum,                     BFCBO::REQUIRED,             0}, 
    { ifds::FromFund,                       BFCBO::REQUIRED,             0}, 
    { ifds::FromClass,                      BFCBO::REQUIRED,             0}, 
    { ifds::FromFundNumber,                 BFCBO::NONE,                 0}, 
    { ifds::FundISIN,                       BFCBO::NONE,                 0}, 
    { ifds::FundWKN,                        BFCBO::NONE,                 0}, 
    { ifds::FundLFC,                        BFCBO::NONE,                 0}, 
	{ ifds::CUSIP,                      BFCBO::NONE,                 0},
    { ifds::FromCurrency,                   BFCBO::NONE,                 0}, 
    { ifds::FrSettlCurrency,                BFCBO::NONE,                 0}, 
    { ifds::FromFundClass,                  BFCBO::IMMEDIATE_VALIDATION, 0}, 
    //to side
    { ifds::AccountTo,                      BFCBO::NONE,                 0}, 
    { ifds::ToFund,                         BFCBO::NONE,                 0}, 
    { ifds::ToClass,                        BFCBO::NONE,                 0}, 
    { ifds::FundToISIN,                     BFCBO::NONE,                 0}, 
    { ifds::FundToWKN,                      BFCBO::NONE,                 0}, 
    { ifds::FundToLFC,                      BFCBO::NONE,                 0}, 
	{ ifds::ToCUSIP,                    BFCBO::NONE,                 0},
    { ifds::ToFundNumber,                   BFCBO::NONE,                 0}, 
    { ifds::ToCurrency,                     BFCBO::NONE,                 0}, 
    { ifds::ToSettlCurrency,                BFCBO::NONE,                 0}, 
    { ifds::ToFundClass,                    BFCBO::IMMEDIATE_VALIDATION, 0}, 
    { ifds::FromToFundClass,                BFCBO::IMMEDIATE_VALIDATION, 0}, 
    //dates, time
    { ifds::EffectiveDate,                  BFCBO::REQUIRED,             0}, 
    { ifds::SettleDate,                     BFCBO::REQUIRED,             0}, 
    { ifds::SettleDateOverriden,            BFCBO::NONE,                 0}, 
    { ifds::ValueDateOverriden,             BFCBO::NONE,                 0}, 
    { ifds::DealDate,                       BFCBO::NONE,                 0}, 
    { ifds::DealTime,                       BFCBO::NONE,                 0}, 
    { ifds::SettleInDate,                   BFCBO::NONE,                 0}, 
    { ifds::SuggestSettleInDate,            BFCBO::NONE,                 0}, 
    { ifds::DepositDate,                    BFCBO::REQUIRED,             0}, 
    { ifds::CashDate,                       BFCBO::NONE,                 0}, 
    { ifds::ValueDate,                      BFCBO::NONE,                 0}, 
    { ifds::EventReceiptDate,               BFCBO::NONE,                 0}, 
    { ifds::EventReceiptTime,               BFCBO::NONE,                 0},
    { ifds::XEditEventRecieptDateTime,      BFCBO::IMMEDIATE_VALIDATION, 0},
    //currency, pay type, file processor, exch rate
    { ifds::ACHProcessor,                   BFCBO::NONE,                 0}, 
    { ifds::SettleCurrency,                 BFCBO::REQUIRED,             0}, 
    { ifds::FromCurrency,                   BFCBO::NONE,                 0}, 
    { ifds::TradesPayType,                  BFCBO::REQUIRED,             0}, 
    { ifds::PayMethod,                      BFCBO::NONE,                 0}, 
    { ifds::SuppressCode,                   BFCBO::NONE,                 0}, 
    { ifds::DepositType,                    BFCBO::NONE,                 0}, 
    { ifds::DepId,                          BFCBO::NONE,                 0}, 
    { ifds::ExchRate,                       BFCBO::NONE,                 0}, 
    { ifds::PayTypeBankNum,                 BFCBO::NONE,                 0}, 
    { ifds::ROAAmount,                      BFCBO::NONE,                 0}, 
    { ifds::PayInstrOption,                 BFCBO::NONE,                 0}, 
   //wire order/order type
    { ifds::OrderType,                      BFCBO::NONE,                 0}, 
    { ifds::OrderSource,                    BFCBO::NONE,                 0}, 
    { ifds::WireOrdNum,                     BFCBO::NONE,                 0}, 
    { ifds::WireOrdFndCls,                  BFCBO::NONE,                 0}, 
    { ifds::OrderSourceOrderType,           BFCBO::IMMEDIATE_VALIDATION, 0}, 
    { ifds::NetOrdType,                     BFCBO::NONE,                 0}, 
    //accountable, backdated reason
    { ifds::Accountable,                    BFCBO::NONE,                 0}, 
    { ifds::BackDatedReason,                BFCBO::NONE,                 0}, 
	{ ifds::SettleNetwork,                  BFCBO::NONE,                 0}, 
    { ifds::AcctableTradeDate,              BFCBO::NONE,                 0}, 
	{ ifds::DilutionLinkNum,                BFCBO::NONE,                 0}, 
    //acqfeeoption, discount, fund brokers
    { ifds::AcqFeeOption,                   BFCBO::NONE,                 0}, 
    { ifds::DiscountRate,                   BFCBO::NONE,                 0}, 
    { ifds::FundBrokerCode,                 BFCBO::NONE,                 0}, 
    { ifds::AggregateOption,                BFCBO::NONE,                 0}, 
    { ifds::AggOrdAdjustNum,                BFCBO::NONE,                 0}, 
    //amount, gross/net, settle by
    { ifds::Amount,                         BFCBO::REQUIRED,             0}, 
    { ifds::AmtType,                        BFCBO::REQUIRED,             0}, 
    { ifds::GrossOrNet,                     BFCBO::NONE,                 0}, 
    { ifds::ExpGNSettle,                    BFCBO::NONE,                 0}, 
    { ifds::SettledBy,                      BFCBO::NONE,                 0}, 
    { ifds::SettleSource,                   BFCBO::NONE,                 0}, 
    { ifds::SettleType,                     BFCBO::NONE,                 0}, 
    { ifds::AmtTypeGrossNet,                BFCBO::NONE,                 0}, //delayed
    { ifds::AmountAmtType,                  BFCBO::NONE,                 0}, //delayed
    { ifds::MinToFundAmount,                BFCBO::IMMEDIATE_VALIDATION, 0}, 
    { ifds::MinFromFundAmount,              BFCBO::IMMEDIATE_VALIDATION, 0}, 
    { ifds::AmountPrecision,                BFCBO::NONE,                 0}, //delayed
    { ifds::FromSoftCapCheck,               BFCBO::IMMEDIATE_VALIDATION,                 0}, //delayed
    { ifds::ToSoftCapCheck,                 BFCBO::IMMEDIATE_VALIDATION,                 0}, //delayed
    //address code
    { ifds::AddrCode,                       BFCBO::NONE,                 0}, 
    //banking fields  
    { ifds::BankIdValue,                    BFCBO::NONE,                 0}, 
    { ifds::BankId,                         BFCBO::NONE,                 0}, 
    { ifds::BankIdType,                     BFCBO::NONE,                 0}, 
    { ifds::TransitNo,                      BFCBO::NONE,                 0}, 
    { ifds::InstName,                       BFCBO::NONE,                 0}, 
    { ifds::BankAddr1,                      BFCBO::NONE,                 0}, 
    { ifds::BankAddr2,                      BFCBO::NONE,                 0}, 
    { ifds::BankAddr3,                      BFCBO::NONE,                 0}, 
    { ifds::BankAddr4,                      BFCBO::NONE,                 0}, 
    { ifds::BankAddr5,                      BFCBO::NONE,                 0}, 
    { ifds::BankCountry,                    BFCBO::NONE,                 0}, 
    { ifds::BankContact,                    BFCBO::NONE,                 0}, 
    { ifds::BankPostal,                     BFCBO::NONE,                 0}, 
//  { ifds::CorrespBankId,                  BFCBO::NONE,                 0}, 
    { ifds::BankIdValueCB,                  BFCBO::NONE,                 0}, 
    { ifds::BankIdTypeCB,                   BFCBO::NONE,                 0}, 
    { ifds::TransitNoCB,                    BFCBO::NONE,                 0}, 
    { ifds::InstNameCB,                     BFCBO::NONE,                 0}, 
    { ifds::BankAddrCB1,                    BFCBO::NONE,                 0}, 
    { ifds::BankAddrCB2,                    BFCBO::NONE,                 0}, 
    { ifds::BankAddrCB3,                    BFCBO::NONE,                 0}, 
    { ifds::BankAddrCB4,                    BFCBO::NONE,                 0}, 
    { ifds::BankAddrCB5,                    BFCBO::NONE,                 0}, 
    { ifds::BankContactCB,                  BFCBO::NONE,                 0}, 
    { ifds::BankCountryCB,                  BFCBO::NONE,                 0}, 
    { ifds::BankPostalCB,                   BFCBO::NONE,                 0}, 
    { ifds::BankAcctNum,                    BFCBO::NONE,                 0}, 
    { ifds::BankAcctType,                   BFCBO::NONE,                 0}, 
    { ifds::BankAcctName,                   BFCBO::NONE,                 0}, 
//  { ifds::AcctUseCode,                    BFCBO::NONE,                 0}, 
    { ifds::RefNumber,                      BFCBO::NONE,                 0}, 
    { ifds::SwiftCode,                      BFCBO::NONE,                 0}, 
//  { ifds::BankAcctCurrency,               BFCBO::NONE,                 0}, 
    { ifds::PayReason1,                     BFCBO::NONE,                 0}, 
    { ifds::PayReason2,                     BFCBO::NONE,                 0}, 
    { ifds::FFC,                            BFCBO::NONE,                 0}, 
    { ifds::FFC1,                           BFCBO::NONE,                 0}, 
    { ifds::ACHProcessor,                   BFCBO::NONE,                 0}, 
    { ifds::BankChrgs,                      BFCBO::NONE,                 0}, 
    //broker/branch/sales rep
    { ifds::Broker,                         BFCBO::REQUIRED,             0}, 
    { ifds::Branch,                         BFCBO::REQUIRED,             0}, 
    { ifds::SlsrepCode,                     BFCBO::REQUIRED,             0}, 
    //remarks
    { ifds::Remarks1,                       BFCBO::NONE,                 0}, 
    { ifds::Remarks2,                       BFCBO::NONE,                 0}, 
    { ifds::Remarks3,                       BFCBO::NONE,                 0}, 
    //settlement location
    { ifds::FrSettlLocCode,                 BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::FrDeliveryTo,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::FrSettlLocDescription,          BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::FrInFavourOf,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::FrForAccount,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::FrSettlInstrCode,               BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::FrClearingMethod,               BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToSettlLocCode,                 BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToDeliveryTo,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToSettlLocDescription,          BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToInFavourOf,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToForAccount,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToSettlInstrCode,               BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
    { ifds::ToClearingMethod,               BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
	{ ifds::FrCSDLocation,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
	{ ifds::FrCSDAcctNum,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
	{ ifds::ToCSDLocation,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
	{ ifds::ToCSDAcctNum,                   BFCBO::NONE,                 TRADE_VALIDATION_GROUP::SETTLE_LOCATION}, 
//unrelated fields
    { ifds::ProvSales,                      BFCBO::NONE,                 0}, 
    { ifds::SrcOfFund,                      BFCBO::NONE,                 0}, 
    { ifds::SrcOfAccount,                   BFCBO::NONE,                 0}, 
    { ifds::DeliveryMethod,                 BFCBO::NONE,                 0}, 
    { ifds::OrderSource,                    BFCBO::NONE,                 0}, 
    { ifds::RecptIssued,                    BFCBO::NONE,                 0}, 
    { ifds::CertRequired,                   BFCBO::NONE,                 0}, 
    { ifds::ConfirmRequired,                BFCBO::NONE,                 0}, 
    { ifds::BorrowedFunds,                  BFCBO::NONE,                 0}, 
    { ifds::MFPayment,                      BFCBO::NONE,                 0}, 
    { ifds::SetAsDefault,                   BFCBO::NONE,                 0}, 
    { ifds::CloneAcctAMS,                   BFCBO::NONE,                 0}, 
//red code
    { ifds::RedCode,                        BFCBO::NONE,                 0}, 
    { ifds::FundCodeRedCodeAmount,          BFCBO::IMMEDIATE_VALIDATION, 0}, 
    { ifds::LSIFCode,                       BFCBO::NONE,                 0}, 
    { ifds::UseEnteredFee,                  BFCBO::NONE,                 0}, 
    { ifds::CashDateXEdit,                  BFCBO::IMMEDIATE_VALIDATION, 0}, 
    //tax rates, used by canadian markets
    { ifds::FedRate,                        BFCBO::NONE,                 0},
    { ifds::TransRatePUDFed,                BFCBO::NONE,                 0},
    { ifds::ProvRate,                       BFCBO::NONE,                 0},
    { ifds::TransRatePUDProv,               BFCBO::NONE,                 0},
    { ifds::OverrideTax,                    BFCBO::NONE,                 0},
//server (API), fields
    { ifds::ForceVerify,                    BFCBO::NONE,                 0},
    { ifds::ExternalPrice,                  BFCBO::NONE,                 0},
    { ifds::ExternalSettleDate,             BFCBO::NONE,                 0},
    { ifds::ExternalSettleAmt,              BFCBO::NONE,                 0},
    { ifds::ParticipantID,                  BFCBO::NONE,                 0},
    { ifds::FundCurrency,                   BFCBO::NONE,                 0},
//whether refresh of the aggregate order is required
    { ifds::RqdRefresh,                     BFCBO::NONE,                 0},
//fields that are not in 115, used only for display 
    { ifds::TradeAttributesFields,          BFCBO::CALCULATED_FIELD,     0},  //attributes grid
    { ifds::TradeFeesFields,                BFCBO::CALCULATED_FIELD,     0},  //fees grid
    { ifds::InitPurch,                      BFCBO::CALCULATED_FIELD,     0}, 
    { ifds::CreateRep,                      BFCBO::CALCULATED_FIELD,     0}, 
    { ifds::TransModPerm,                   BFCBO::CALCULATED_FIELD,     0}, 
    { ifds::FundIDType,                     BFCBO::CALCULATED_FIELD,     0}, 
    { ifds::FundIDValue,                    BFCBO::CALCULATED_FIELD,     0},
//fees fields, those fields should not be set ever, thru a setField
    { ifds::Fee,                            BFCBO::NONE,                 0}, 
    { ifds::FeeTo,                          BFCBO::NONE,                 0}, 
    { ifds::FlatPercent,                    BFCBO::NONE,                 0}, 
    { ifds::ToFlatPercent,                  BFCBO::NONE,                 0},  
    { ifds::ADLFeeCharge,                   BFCBO::NONE,                 0}, 
    { ifds::ChargeERSTTRFee,                BFCBO::NONE,                 0}, 
    { ifds::ChargeWDFee,                    BFCBO::NONE,                 0}, 
    { ifds::ExchOutFee,                     BFCBO::NONE,                 0}, 
    { ifds::ExchOutFlatPrcnt,               BFCBO::NONE,                 0}, 
    { ifds::ExchInFee,                      BFCBO::NONE,                 0}, 
    { ifds::ExchInFlatPercent,              BFCBO::NONE,                 0}, 
    { ifds::FeeCurrency,                    BFCBO::NONE,                 0}, 
    { ifds::DSCOverrideCode,                BFCBO::NONE,                 0}, 
    { ifds::DSCOverrideAmt,                 BFCBO::NONE,                 0}, 
//network order fields
    { ifds::NetworkID,                      BFCBO::NONE,                 0}, 
    { ifds::ExtTransNum,                    BFCBO::NONE,                 0}, 
    { ifds::SendRefNum,                     BFCBO::NONE,                 0}, 
    { ifds::PartRefNum,                     BFCBO::NONE,                 0}, 
    { ifds::MasterRefNum,                   BFCBO::NONE,                 0}, 
    { ifds::OtherConfirmType,               BFCBO::NONE,                 0}, 
    { ifds::InterDetlRid,                   BFCBO::NONE,                 0}, 
    { ifds::VersionNum,                     BFCBO::NONE,                 0}, 
//used so the trades list can set a different pay type then the one in trade defaults
    { ifds::FieldAssignment,                BFCBO::CALCULATED_FIELD,     0}, 
// rebook
    { ifds::AdjTransNum,                    BFCBO::NONE,                 0}, 
    { ifds::SplitCommRebookTransID,         BFCBO::NONE,                 0},
    { ifds::FromHistoryTrade,               BFCBO::NONE,                 0},

// eusd
    { ifds::OverrideCost,                   BFCBO::NONE,                 0}, 
    { ifds::Cost,                           BFCBO::NONE,                 0}, 
    { ifds::OverrideTIS,                    BFCBO::NONE,                 0}, 
    { ifds::TIS,                            BFCBO::NONE,                 0}, 
// trade suppress
    { ifds::MCHFileIndicator,               BFCBO::NONE,                 0}, 
    { ifds::SecRecFileIndicator,            BFCBO::NONE,                 0}, 
    { ifds::ESGSettle,                      BFCBO::NONE,                 0}, 
//pay instructions
    { ifds::PayInstructExists,              BFCBO::NONE,                 0}, 
    //{ ifds::UnitRoundMethod,                BFCBO::NONE,               0},//Blackrock unit rounding project 	
    { ifds::RcptStatus,                     BFCBO::NONE,                 0}, 
    { ifds::DepTypeTradeDate,               BFCBO::IMMEDIATE_VALIDATION, 0}, 	
    { ifds::LinkedEntityId,                 BFCBO::NONE,                 0}, 
    { ifds::TradePayTypeFundClass,          BFCBO::IMMEDIATE_VALIDATION, 0}, 
    { ifds::BnkAcctIDLink,                  BFCBO::NONE,                 0}, 
    
    //QESI Transaction Level , Req 3,4,5,7
    { ifds::AssocTransId,                   BFCBO::NONE,                 0}, 
    { ifds::GRRepayReason,                  BFCBO::NONE,                 0}, 
    { ifds::RESPReportHRDC,                 BFCBO::NONE,                 0}, 
    { ifds::CourseStart,                    BFCBO::NONE,                 TRADE_VALIDATION_GROUP::PSE_EAP}, 
    { ifds::CourseLen,                      BFCBO::NONE,                 TRADE_VALIDATION_GROUP::PSE_EAP}, 
    { ifds::PSEProgramLen,                  BFCBO::NONE,                 TRADE_VALIDATION_GROUP::PSE_EAP}, 
    { ifds::PSEProgramType,                 BFCBO::NONE,                 TRADE_VALIDATION_GROUP::PSE_EAP}, 
    { ifds::PSEProgramYear,                 BFCBO::NONE,                 TRADE_VALIDATION_GROUP::PSE_EAP}, 
    { ifds::EduInstPstl,                    BFCBO::NONE,                 TRADE_VALIDATION_GROUP::PSE_EAP}, 
    { ifds::PSEProgramLenList,              BFCBO::NONE,                 0}, 
    { ifds::PSEProgramTypeList,             BFCBO::NONE,                 0}, 
    { ifds::PSEProgramYearList,             BFCBO::NONE,                 0}, 
    { ifds::Tainted,                        BFCBO::NONE,                 0}, 
    { ifds::OCRdmYear,                      BFCBO::NONE,                 0}, 
    { ifds::RESPContrDetlTaxYear,           BFCBO::NONE,                 0}, 
    { ifds::AmtTypeRedCode,                 BFCBO::IMMEDIATE_VALIDATION, 0},
    { ifds::AmountRedCode,                  BFCBO::IMMEDIATE_VALIDATION, 0},
    { ifds::FromPlanNum,                    BFCBO::NONE,                 0}, 
    { ifds::FromContractId,                 BFCBO::NONE,                 0}, 
    { ifds::ToPlanNum,                      BFCBO::NONE,                 0}, 
    { ifds::ToContractId,                   BFCBO::NONE,                 0}, 
    { ifds::InceptionDate,                  BFCBO::NONE,                 0}, 
    { ifds::TerminationDate,                BFCBO::NONE,                 0}, 
    { ifds::NEQ1,                           BFCBO::NONE,                 0}, 
    { ifds::NEQ2,                           BFCBO::NONE,                 0}, 
    { ifds::RESPTransStat,                  BFCBO::NONE,                 0}, 
    { ifds::RESPLetter,                     BFCBO::NONE,                 0}, 
    { ifds::AssistedContrAmt,               BFCBO::NONE,                 0}, 
    { ifds::AcctLvlOverride,                BFCBO::NONE,                 0}, 
    { ifds::EligibleTransfer,               BFCBO::NONE,                 0}, 
    { ifds::FundAmtType     ,               BFCBO::IMMEDIATE_VALIDATION, 0},
    { ifds::NetworkRespRequired,            BFCBO::NONE,                 0},	
    { ifds::EAPCESGPaid,                    BFCBO::NONE,                 0},//IN2689391 - PET0185010_FN01: CESG Paid is tracked at the EAP level
    { ifds::IntInvestType,                  BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::IntCalcMthd,                    BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::InvestTerm,                     BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::GIMaturityDate,                 BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::IntCredFreq,                    BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::NextIntCredDate,                BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::CommRedRate,                    BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::AddlAmt,                        BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::IntRate,                        BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB}, 
    { ifds::ForcedRate,                     BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::ForcedRateAmt,                  BFCBO::IMMEDIATE_VALIDATION, TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::InvHisLastIntCrdDate,           BFCBO::NONE,                 TRADE_VALIDATION_GROUP::GIA_ATTRIB},
    { ifds::TransId,                        BFCBO::NONE,                 0},
    { ifds::PFCrystalisation,               BFCBO::NONE,                 0},
    { ifds::PaymentInfo,                    BFCBO::NONE,                 0},
    { ifds::PendTrdContract,                BFCBO::NONE,                 0},
    { ifds::ValuationDt,                    BFCBO::NONE,                 0},
    { ifds::FromSegTradeEntryCheck,         BFCBO::IMMEDIATE_VALIDATION, 0},
    { ifds::FromToSegTradeEntryCheck,       BFCBO::IMMEDIATE_VALIDATION, 0},
    { ifds::GuaranteesOverride,             BFCBO::NONE,                 0},
    { ifds::RedemOrder,                     BFCBO::NONE,                 0},
    { ifds::IsAllocationChanged,            BFCBO::NOT_ON_HOST,          0},
    { ifds::SrcOfFunds_IA,                  BFCBO::NONE,                 0}, //P0186486_FN15_The Source of Funds
    { ifds::RightToCancel,                  BFCBO::NONE,                 0},  
    { ifds::RDRAdvice,                      BFCBO::NONE,                 0},
    { ifds::AWDFieldFlag,                   BFCBO::NONE,                 0},
    { ifds::PSDAdvice,                      BFCBO::NONE,                 0},
    { ifds::PymtRoutingMthd,                BFCBO::NONE,                 0},
    { ifds::SourceOfTrade,                  BFCBO::NONE,                 0},
    { ifds::ChannelOfTrade,                 BFCBO::NONE,                 0},
    { ifds::Platform,                       BFCBO::NONE,                 0},
    { ifds::TimeFactor,                     BFCBO::CALCULATED_FIELD,     0 },
    { ifds::DeliveryNetwork,                BFCBO::NONE,                 0 },

    {ifds::SettleTypeNetworkSettleXEdit,    BFCBO::IMMEDIATE_VALIDATION, 0 },
    {ifds::SettleSourceNetworkSettleXEdit,  BFCBO::IMMEDIATE_VALIDATION, 0 },
    { ifds::FrSettlementAccount,            BFCBO::CALCULATED_FIELD,     0 },
    { ifds::FrInternalSettlementAccount,    BFCBO::CALCULATED_FIELD,     0 },
    { ifds::FrIntermediaryBank,             BFCBO::NONE,                 0 },
    { ifds::FrCashMsgType,                  BFCBO::NONE,                 0 }, 
    { ifds::FrReceivingBank,                BFCBO::NONE,                 0 },
    { ifds::FrBeneficiary,                  BFCBO::NONE,                 0 }, 
    { ifds::FrSpecialInstructions,          BFCBO::NONE,                 0 },
    { ifds::ToSettlementAccount,            BFCBO::CALCULATED_FIELD,     0 },
    { ifds::ToInternalSettlementAccount,    BFCBO::CALCULATED_FIELD,     0 },
    { ifds::ToIntermediaryBank,             BFCBO::NONE,                 0 },
    { ifds::ToCashMsgType,                  BFCBO::NONE,                 0 }, 
    { ifds::ToReceivingBank,                BFCBO::NONE,                 0 },
    { ifds::ToBeneficiary,                  BFCBO::NONE,                 0 }, 
    { ifds::ToSpecialInstructions,          BFCBO::NONE,                 0 },  
    { ifds::G1Impact,             BFCBO::IMMEDIATE_VALIDATION,           0 },
    { ifds::G2Impact,             BFCBO::IMMEDIATE_VALIDATION,           0 },
    { ifds::G1G2UnitsXEdit,       BFCBO::IMMEDIATE_VALIDATION,           0 }, 
    { ifds::AggregationType,                 BFCBO::NONE,                0 },
    { ifds::rxAcctNum,                       BFCBO::NONE,                0 },
    { ifds::rxBankingEntity,                 BFCBO::NONE,                0 },
    { ifds::SourceofFundsChecked,            BFCBO::NONE,                0 },
    { ifds::ExternalInstitution,             BFCBO::NONE,                0 },
    { ifds::DepTypeExternalInstitution,      BFCBO::IMMEDIATE_VALIDATION,0 },
    { ifds::RedCodeExternalInstitution,      BFCBO::IMMEDIATE_VALIDATION,0 },
    { ifds::InterClassSwitch,                BFCBO::NONE,                0 },
    { ifds::RefundAmtOpt,                    BFCBO::NONE,                0 },
	{ ifds::Deconversion,					 BFCBO::NONE,                0 },
	{ ifds::OrderRouting,                    BFCBO::NONE,                0 },
	{ ifds::TradeInDate,                 BFCBO::IMMEDIATE_VALIDATION,    0 },
	{ ifds::ValuationInDt,                   BFCBO::NONE,                0 },
	{ ifds::PricingCode,                     BFCBO::NONE,                0 },	
	{ ifds::PriceInCode,                     BFCBO::NONE,                0 },
	{ ifds::FullMoneyOutIndc,				 BFCBO::NONE,                0 },
	{ ifds::ExtAccount,						 BFCBO::NONE,				 0 }, 
	{ ifds::ExtSpecimenPlanNo,				 BFCBO::NONE,				 0 },
	{ ifds::NontaxContrib,					 BFCBO::NONE,				 0 },
	{ ifds::Rollovers,						 BFCBO::NONE,				 0 },
	{ ifds::CDSGrant,						 BFCBO::NONE,				 0 },
	{ ifds::CDSBond,						 BFCBO::NONE,				 0 },
	{ ifds::CurrYrFMV,						 BFCBO::NONE,				 0 },
	{ ifds::PrevYrGrantBond,				 BFCBO::NONE,				 0 },
	{ ifds::PrevYrContrib,					 BFCBO::NONE,				 0 },
	{ ifds::PrevYrNonTaxRedAmt,				 BFCBO::NONE,				 0 },   
	{ ifds::PrevYrTaxRedAmt,				 BFCBO::NONE,				 0 },
	{ ifds::CurrYrNonTaxRedAmt,				 BFCBO::NONE,				 0 },
	{ ifds::CurrYrTaxRedAmt,				 BFCBO::NONE,				 0 },
	{ ifds::GateOverrideIndicator,           BFCBO::NONE,                0 },
	{ ifds::RDSPPaymtDate,					 BFCBO::NONE,                0 },
	{ ifds::CashDateOverriden,               BFCBO::NONE,                0 },
};
const FIELD_DEFAULT_RULE m_FieldDefaultRule[] = { 
// FieldID,					Key1,				key2,			  Key3,			 Key4,			Key5,					MODE

{ifds::SourceOfTrade,ifds::TradesTransType,	 ifds::NullFieldId, ifds::NullFieldId, ifds::NullFieldId, ifds::NullFieldId, MODE_INIT | MODE_REBOOK },
{ifds::ChannelOfTrade,ifds::TradesTransType, ifds::NullFieldId, ifds::NullFieldId, ifds::NullFieldId, ifds::NullFieldId, MODE_INIT | MODE_REBOOK },

};
static const int NUM_FIELDS = sizeof (classFieldInfo) / sizeof (BFCBO::CLASS_FIELD_INFO);
static const int _numFieldDefaultRule = sizeof(m_FieldDefaultRule) / sizeof(FIELD_DEFAULT_RULE);

//******************************************************************************
Trade::Trade (BFAbstractCBO &parent) : MFCanBFCbo (parent),
_currentBusinessDate (NULL_STRING),
_multiCurrency (NULL_STRING),
_origTradeFee (NULL_STRING),
_pTransFeeContext (NULL),
_strInitialRebookAmt(I_("")),
_bInitPending (false),
_bShouldRefreshSplitCommissions (true), //should be initialized to true, so we always refresh the splits
_bRebook (false),
_bRefund (false),
_bBackDateCheck (true),
_bAlreadySetPayTypeDefaults (false),
_bDefaultPayInstructPayTypeIsNotEFTOrSystemCheque (false),
_bSameAccount(false),
_pBatchInfoList (NULL),
_bPtcForPending(false),
_strRDRAdviceFlag(I_("")),
_bSetAmsParentFundClass(false)
{
   TRACE_CONSTRUCTOR ( CLASSNAME, 
                       NULL_STRING);

   registerMemberData ( NUM_FIELDS, (const CLASS_FIELD_INFO *)&classFieldInfo,
                        0, NULL);

   //to be invalidated when from fund/class updates, 
   //from fund affect eligibility of a wire order
   addCrossEdit (ifds::WireOrdFndCls, ifds::OrderType);  
   //to be invalidated when from fund/class updates
   //from fund load type affects value of gross/net
   addCrossEdit (ifds::NetOrdType, ifds::GrossOrNet);
   addCrossEdit (ifds::NetOrdType, ifds::OrderType);

   addCrossEdit (ifds::OrderSourceOrderType, ifds::OrderType);
   addCrossEdit (ifds::OrderSourceOrderType, ifds::OrderSource);

//for backdated trades
   addCrossEdit (ifds::AcctableTradeDate, ifds::Accountable); 
   addCrossEdit (ifds::AcctableTradeDate, ifds::BackDatedReason);

//for setting cash date updatable
   addCrossEdit (ifds::CashDateXEdit, ifds::EffectiveDate);
   addCrossEdit (ifds::CashDateXEdit, ifds::FromFund); 
   addCrossEdit (ifds::CashDateXEdit, ifds::FromClass); 

//amount type / gross net
   addCrossEdit (ifds::AmtTypeGrossNet, ifds::AmtType); 
   addCrossEdit (ifds::AmtTypeGrossNet, ifds::GrossOrNet); 

//amount, amt type
   addCrossEdit (ifds::AmountAmtType, ifds::Amount);
   addCrossEdit (ifds::AmountAmtType, ifds::AmtType);

   addCrossEdit (ifds::FromFundClass, ifds::FromFund); //from fund/code validations
   addCrossEdit (ifds::FromFundClass, ifds::FromClass);

   addCrossEdit (ifds::ToFundClass, ifds::ToFund); //to fund/code validations
   addCrossEdit (ifds::ToFundClass, ifds::ToClass);  

   addCrossEdit (ifds::FromToFundClass, ifds::FromFund); //validate all four fields
   addCrossEdit (ifds::FromToFundClass, ifds::FromClass);
   addCrossEdit (ifds::FromToFundClass, ifds::ToFund);
   addCrossEdit (ifds::FromToFundClass, ifds::ToClass);  

   addCrossEdit (ifds::MinToFundAmount, ifds::Amount);   // Fund/Class To and AmtType

   addCrossEdit (ifds::MinFromFundAmount, ifds::Amount); // Fund/Class From and AmtType

   addCrossEdit (ifds::AmountPrecision, ifds::AmtType);
   addCrossEdit (ifds::AmountPrecision, ifds::SettleCurrency); 
//duplicate trade check
   addCrossEdit (ifds::DuplicateTrade, ifds::FromFund); //invalidate on account num/fund/class/amount change
   addCrossEdit (ifds::DuplicateTrade, ifds::FromClass);
// red code/from fund/amount
   addCrossEdit (ifds::FundCodeRedCodeAmount, ifds::RedCode);
   addCrossEdit (ifds::FundCodeRedCodeAmount, ifds::FromFund);
   addCrossEdit (ifds::FundCodeRedCodeAmount, ifds::Amount);
   addCrossEdit (ifds::FundCodeRedCodeAmount, ifds::SettleCurrency);
// paytype and bank
   addCrossEdit (ifds::PayTypeBankNum, ifds::TradesPayType);
//soft cap check - from side
   addCrossEdit (ifds::FromSoftCapCheck, ifds::FromFund);
   addCrossEdit (ifds::FromSoftCapCheck, ifds::FromClass);
   addCrossEdit (ifds::FromSoftCapCheck, ifds::EffectiveDate);
//soft cap check - to side
   addCrossEdit (ifds::ToSoftCapCheck, ifds::ToFund);
   addCrossEdit (ifds::ToSoftCapCheck, ifds::ToClass);
   addCrossEdit (ifds::ToSoftCapCheck, ifds::EffectiveDate);

   addCrossEdit (ifds::DepTypeTradeDate, ifds::DepositType);
   addCrossEdit (ifds::DepTypeTradeDate, ifds::EffectiveDate);
   addCrossEdit (ifds::DepTypeTradeDate, ifds::AccountTo);

   addCrossEdit (ifds::TradePayTypeFundClass, ifds::TradesPayType);
   addCrossEdit (ifds::TradePayTypeFundClass, ifds::FromFund);
   addCrossEdit (ifds::TradePayTypeFundClass, ifds::FromClass);
//amt type redemption code
   addCrossEdit (ifds::AmtTypeRedCode, ifds::AmtType); 
   addCrossEdit (ifds::AmtTypeRedCode, ifds::RedCode); 

   addCrossEdit (ifds::AmountRedCode, ifds::Amount); 
   addCrossEdit (ifds::AmountRedCode, ifds::RedCode); 

   addCrossEdit (ifds::FundAmtType, ifds::FromFund); 
   addCrossEdit (ifds::FundAmtType, ifds::AmtType);

   addCrossEdit (ifds::FromSegTradeEntryCheck, ifds::EffectiveDate);
   addCrossEdit (ifds::FromSegTradeEntryCheck, ifds::FromFund); 
   addCrossEdit (ifds::FromSegTradeEntryCheck, ifds::FromClass); 

   addCrossEdit (ifds::FromToSegTradeEntryCheck, ifds::EffectiveDate);
   addCrossEdit (ifds::FromToSegTradeEntryCheck, ifds::FromFund); 
   addCrossEdit (ifds::FromToSegTradeEntryCheck, ifds::FromClass); 
   addCrossEdit (ifds::FromToSegTradeEntryCheck, ifds::ToFund); 
   addCrossEdit (ifds::FromToSegTradeEntryCheck, ifds::ToClass);

   addCrossEdit (ifds::XEditEventRecieptDateTime, ifds::EventReceiptDate); 
   addCrossEdit (ifds::XEditEventRecieptDateTime, ifds::EventReceiptTime);

   addCrossEdit (ifds::SettleSourceNetworkSettleXEdit, ifds::SettleNetwork);
   addCrossEdit (ifds::SettleSourceNetworkSettleXEdit, ifds::SettleSource);
   addCrossEdit (ifds::SettleSourceNetworkSettleXEdit, ifds::EffectiveDate);

   addCrossEdit (ifds::SettleTypeNetworkSettleXEdit, ifds::SettleType);
   addCrossEdit (ifds::SettleTypeNetworkSettleXEdit, ifds::SettleNetwork);

   addCrossEdit (ifds::G1G2UnitsXEdit, ifds::G1Impact);
   addCrossEdit (ifds::G1G2UnitsXEdit, ifds::G2Impact);
   addCrossEdit (ifds::G1G2UnitsXEdit, ifds::Amount);

   addCrossEdit (ifds::DepTypeExternalInstitution,ifds::ExternalInstitution);
   addCrossEdit (ifds::DepTypeExternalInstitution,ifds::DepositType);
   addCrossEdit (ifds::RedCodeExternalInstitution,ifds::ExternalInstitution);
   addCrossEdit (ifds::RedCodeExternalInstitution,ifds::RedCode);

//read management company options VERY OFTEN used
   getWorkSession ().getOption ( ifds::MultiCurrency, 
                                 _multiCurrency, 
                                 BF::HOST,
                                 false);
   getWorkSession ().getOption ( ifds::CurrBusDate, 
                                 _currentBusinessDate, 
                                 BF::HOST, 
                                 false);

   getWorkSession ().getOption ( ifds::OrigTradeFee, 
                                 _origTradeFee, 
                                 BF::HOST,
                                 false);

   _nextCycleDate = _currentBusinessDate;
}


//******************************************************************************
Trade::~Trade ()
{
   TRACE_DESTRUCTOR (CLASSNAME);
   if (_pTransFeeContext)
   {
      delete _pTransFeeContext;
      _pTransFeeContext = NULL;
   }
}

//******************************************************************************
SEVERITY Trade::makeDirty (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("makeDirty"));
//SP (Jan 2005), PTS 10037503
//this is a kludge! object should not be made dirty by anyone!! 
//(only 'setField' is allowed to dirty the object)
//the issue occurs when trade object sometimes is dirty due to the allocations
//issue should be fixed in the way new allocations (i.e. 100% allocations) 
//are created and handled, this implies a fairly significant change of the alloc classes,
//postponed for the new generation of allocations....
   setFieldUpdated (ifds::AccountNum, idDataGroup, true);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::init ( const BFDataGroupId &idDataGroup,
                       const DString &track, /*=I_("N")*/
                       const DString &pageName /*=NULL_STRING*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("init"));
   firstLineInInit (idDataGroup);
//default for the effective date
   setFieldNoValidate ( ifds::EffectiveDate, _currentBusinessDate, idDataGroup, false, 
                        true, true, false);
//set the transaction type 
   doInit (idDataGroup);
   
   if (!isOneSideTrade(idDataGroup))
   {
	   setFieldNoValidate ( ifds::TradeInDate, _currentBusinessDate, idDataGroup, false, 
		   true, false, false);
   }

//fetch a transaction number, and set various defaults
   if (GETCURRENTHIGHESTSEVERITY () <= WARNING)
   {
      fetchTransNum (idDataGroup, track, pageName);
      initBatch (idDataGroup);
   }
//field properties are set
   preInitWithDefaultValues (idDataGroup);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::init (const BFData &data)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("init"));
   _bInitPending = true;
   _bPtcForPending = true;

   attachDataObject (const_cast <BFData&>(data), true, true);
   firstLineInInit (BF::HOST);
   initBatch (BF::HOST);

//set the transaction type 
   doInit (BF::HOST);
//field properties are set
   preInitWithDefaultValues (BF::HOST);
//capture field properties, part of 'doApplyRelatedChanges'
   doInit (data);
//api server fields
   setFieldNoValidate (ifds::ForceVerify, N, BF::HOST, false);
//display or helpers fields
   setFieldNoValidate ( ifds::CreateRep, N, BF::HOST, false, 
                        true, 
                        false, 
                        false);
   _bInitPending = false;
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::initBatch (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("initBatch"));

   DString originalBatch;

   getWorkSession().getBatchList (_pBatchInfoList, idDataGroup);

   WorksessionTradesList *pWorksessionTradesList = 
         dynamic_cast<WorksessionTradesList*>(getParent());

   if(pWorksessionTradesList != NULL)
   {
      originalBatch = pWorksessionTradesList->getBatchName ();
   }

   if (_pBatchInfoList)
   {
      DString batchList;
      DString autoBatching;

      getWorkSession ().getOption (ifds::AutoBatch, autoBatching, BF::HOST, false);

      bool bReadOnly = autoBatching.asInteger () == AUTO_BATCHING ? false : true;

      if (originalBatch.empty ())
      {
         getField (ifds::BatchName, originalBatch, idDataGroup);
      }
      else 
      {
         setFieldNoValidate (ifds::BatchName, originalBatch, idDataGroup, false);
      }
      _pBatchInfoList->getSubstitionList(batchList, originalBatch, idDataGroup);
      setFieldAllSubstituteValues (ifds::BatchName, idDataGroup, batchList);

      setFieldReadOnly (ifds::BatchName, idDataGroup, bReadOnly);		
   }

   return GETCURRENTHIGHESTSEVERITY ();

}
//******************************************************************************
SEVERITY Trade::doInit (const BFData &data)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("init"));

//this method is used to incorporate the related changes for 
//modifying pending trade

   //account related changes
//first set the trades type/account num to be read only
   setFieldReadOnly (ifds::TradesTransType, BF::HOST, true);
   setFieldReadOnly (ifds::AccountNum, BF::HOST, true);

//pay type should be set to empty for transfers/exchanges
//it should be done here before initializing anything else, 
//since view 54 sends us 'S' for pay type if trans type is EX,TR. 
//This should be properly fixed by the view side! (SP)   
   if (isExchangeLike (BF::HOST))
   {
      setFieldNoValidate (ifds::TradesPayType, NULL_STRING, BF::HOST, false, false, true);
   }

   DString orderType;

   getField (ifds::OrderType, orderType, BF::HOST, false);
   batchOrderType = orderType;
   setFieldReadOnly (ifds::ExpGNSettle, BF::HOST, orderType != Y);

//fund related changes
   DString fundCode,
           classCode,
           toFund,
           toClass;

   getField (ifds::FromFund, fundCode, BF::HOST, false);
   getField (ifds::FromClass, classCode, BF::HOST, false);
   if ( !fundCode.empty() &&
        !classCode.empty())
   {
      DString fundNumber,
              isinNumber,
              wknNumber,
              lfcNumber,
			  cusipNumber;

      getWorkSession ().GetFundNumber (fundCode, classCode, fundNumber);
      getWorkSession ().GetISINNumber (fundCode, classCode, isinNumber);
      getWorkSession ().GetWKNNumber (fundCode, classCode, wknNumber);
      getWorkSession ().GetLFCNumber (fundCode, classCode, lfcNumber);
	  getWorkSession ().GetCUSIPNumber (fundCode, classCode, cusipNumber);
      setFieldNoValidate ( ifds::FromFundNumber, fundNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
      setFieldNoValidate ( ifds::FundISIN, isinNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
      setFieldNoValidate ( ifds::FundWKN, wknNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
      setFieldNoValidate ( ifds::FundLFC, lfcNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
	  setFieldNoValidate ( ifds::CUSIP, cusipNumber, BF::HOST, false,
						   true,
						   true,
						   false); //notify

//from currency, set-up
      DString fundCurrency;

      getFundField (fundCode, classCode, ifds::Currency, fundCurrency);
      setFieldNoValidate ( ifds::FromCurrency, fundCurrency, BF::HOST, true, 
                           true, 
                           true); //if fund is empty set from currency to NULL_STRING
// do this for multi-cycle processing, assign the currBusDate based on the fund
      getFundField (fundCode, classCode, ifds::NextNightRun, _currentBusinessDate);

   }
   getField (ifds::ToFund, toFund, BF::HOST, false);
   getField (ifds::ToClass, toClass, BF::HOST, false);
   if ( !toFund.empty() &&
        !toClass.empty())
   {
      DString fundNumber,
         isinNumber,
         wknNumber,
         lfcNumber,
		 cusipNumber;

      getWorkSession ().GetFundNumber (toFund, toClass, fundNumber);
      getWorkSession ().GetISINNumber (toFund, toClass, isinNumber);
      getWorkSession ().GetWKNNumber (toFund, toClass, wknNumber);
      getWorkSession ().GetLFCNumber (toFund, toClass, lfcNumber);
	  getWorkSession ().GetCUSIPNumber (toFund, toClass, cusipNumber);
      setFieldNoValidate ( ifds::ToFundNumber, fundNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
      setFieldNoValidate ( ifds::FundToISIN, isinNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
      setFieldNoValidate ( ifds::FundToWKN, wknNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
      setFieldNoValidate ( ifds::FundToLFC, lfcNumber, BF::HOST, false, 
                           true, 
                           true, //notify
                           false);
	  setFieldNoValidate ( ifds::ToCUSIP, cusipNumber, BF::HOST, false,
						   true,
						   true,
						   false); //notify
//to currency, set-up
      DString fundCurrency;

      getFundField (toFund, toClass, ifds::Currency, fundCurrency);
      setFieldNoValidate ( ifds::ToCurrency, fundCurrency, BF::HOST, true, 
                           true, 
                           true);
   }

//effective date related changes

   if (!_bRebook)
   {
      // for non-rebooking trade we could init the dilution record immediately
      // however, for rebooking trade we may need to delay the initialization of dilution
      // to be after a few required fields completely initialized
      loadDilution(BF::HOST);
   }

//the set of necessary related changes
   aggregateOptionRelatedChanges (BF::HOST);
   orderTypeRelatedChanges (BF::HOST);
   payTypeRelatedChanges (BF::HOST);
   settleCurrencyRelatedChanges (BF::HOST);
   fileProcessorRelatedChanges (BF::HOST);
   payMethodPropertyChanges (BF::HOST);
   clearingRelatedChanges (BF::HOST);
   setCashDateUpdatable (BF::HOST);
   setExchRate (BF::HOST);
   initPriceTypesList(BF::HOST);
   refreshIntradayPricing(BF::HOST);
   hasWaiveGatingFund(BF::HOST);
   BFProperties *pBFPropertiesOCT =  getFieldProperties (ifds::OtherConfirmType, BF::HOST);
   assert (pBFPropertiesOCT);
   if (pBFPropertiesOCT)
   {
     DString otherConfirmTypeSubstList;
     pBFPropertiesOCT->getAllSubstituteValues (otherConfirmTypeSubstList);
     otherConfirmTypeSubstList = I_("=N/A;") + otherConfirmTypeSubstList;
     setFieldAllSubstituteValues (ifds::OtherConfirmType, BF::HOST, otherConfirmTypeSubstList);
   }
   networkIDRelatedChanges (BF::HOST);
   amtTypeExtraRelatedChanges (BF::HOST);
// Check condition to set ESGSettlement when modify a pending automatic withdraw
   esgSettleRelatedChange (BF::HOST); 

   DString dstrFrSettleInstrCode;
// From Side
   getField (ifds::FrSettlInstrCode, dstrFrSettleInstrCode, BF::HOST, false);   
   bool bNotApplicable = dstrFrSettleInstrCode == I_("N/A") || dstrFrSettleInstrCode.empty();
   setFieldReadOnly (ifds::FrDeliveryTo, BF::HOST, !bNotApplicable);
   setFieldReadOnly (ifds::FrInFavourOf, BF::HOST, !bNotApplicable);
   setFieldReadOnly (ifds::FrForAccount, BF::HOST, !bNotApplicable);
   setFieldReadOnly (ifds::FrCSDLocation, BF::HOST, !bNotApplicable);
   setFieldReadOnly (ifds::FrCSDAcctNum, BF::HOST, !bNotApplicable);
   for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrFrReadOnlyFields;	i++)
   {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrFrReadOnlyFields[i],  BF::HOST, !bNotApplicable );
   }
   for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
   {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
   }	
//force the creation of children lists
//each method will determine whether the list is necessary or not

//allocations
   TradeFundAllocList *pTradeFundAllocList = NULL;
   getFundAllocationList (pTradeFundAllocList, BF::HOST);

//fees
   TransFeeList* pTransFeeList = NULL;

   getTransFeeList (pTransFeeList, BF::HOST); 

   if (pTradeFundAllocList)
   {
      BFObjIter iter ( *pTradeFundAllocList, 
                        BF::HOST, 
                        true);
      while (!iter.end())
      {
         TradeFundAlloc *pTradeFundAlloc = 
            dynamic_cast <TradeFundAlloc *> (iter.getObject());

         if (pTradeFundAlloc)
         {
            SplitCommissionList *pSplitCommissionList = NULL;
//split commission            
            pTradeFundAlloc->getSplitCommissionList (pSplitCommissionList, BF::HOST, true);
         }
         ++iter;
      }
   }
   if(pTransFeeList)
      pTransFeeList->applyTransFeeRateToAllocation(BF::HOST);

   TradeBankInstructionsList *pTradeBankInstructionsList (NULL);

   getBankInstructionsList (pTradeBankInstructionsList, BF::HOST);

   TradePayInstructList *pTradePayInstructList (NULL);

   getTradePayInstructList (pTradePayInstructList, BF::HOST);

   TradeSettlementLocationsList *pTradeSettlementLocationsList;

   getSettlementLocsList (pTradeSettlementLocationsList, BF::HOST);

   RESPBeneficiaryAllocationList *pRESPBeneficiaryAllocationList (NULL);

   getRESPBenefAllocationList (pRESPBeneficiaryAllocationList, BF::HOST);

   RESPTransferList *pRESPTransferList (NULL);

   getRESPTransferList (pRESPTransferList, BF::HOST);

   MatSweepInstrList *pMaturityInstrList = NULL;

   getMaturityInstrList (pMaturityInstrList, BF::HOST);

   PSEEAPList *pPSEEAPList (NULL);

   getPSEData (pPSEEAPList, BF::HOST);

   bool bROAValueReadOnly = !isROAApplicable (BF::HOST) || (isROAApplicable (BF::HOST) && hasAllocations (BF::HOST));

   setFieldReadOnly (ifds::ROAAmount, BF::HOST, bROAValueReadOnly);

   setSuppressIndicatorsSubstitutionSet (BF::HOST);
   setSuppressIndicatorsPerm (BF::HOST);

   GIAInvAttribList *pGIAInvAttribList(NULL);
   getGIFundDefaults (pGIAInvAttribList, BF::HOST);

   intCalcMthdRelatedChanges(BF::HOST);

   PendTrdContractRelatedChanges(BF::HOST); 
   enablePFCrystalisationFlag (BF::HOST);

   setFieldReadOnly (ifds::PaymentInfo, BF::HOST, !isValueDatePriorToTradeDate(BF::HOST));
   loadPaymentStatusSubstList (BF::HOST);
   updateGuaranteeFeeOverride (BF::HOST);
    
   getField (ifds::RDRAdvice, _strRDRAdviceFlag, BF::HOST, false); 
   if( _strRDRAdviceFlag == I_("00") )
   {
      setFieldReadOnly (ifds::RDRAdvice, BF::HOST, true);
   }
   else
   {
      loadRDRAdviceSubstList(BF::HOST);
   }
   setGIDIFTradePayType (BF::HOST);
   //in case of re-book we don't need to have the old EventRecipetDate/Time
   bool bEventReceiptDateTimeAppl = bIsEventReceiptDateTimeAppl(BF::HOST);
   //mask the time returned by the view using ##:##:##
   DString dstrValue;
   getField (ifds::EventReceiptTime, dstrValue, BF::HOST, false);
   formatStringUsingMask(dstrValue, I_("##:##:##"));
   setFieldNoValidate(ifds::EventReceiptTime, dstrValue, BF::HOST, false, false, false);
   if(_bRebook)
   {
      setFieldNoValidate(ifds::EventReceiptDate,I_(""),BF::HOST,false,false,false);//no apply related changes
      setFieldNoValidate(ifds::EventReceiptTime,I_(""),BF::HOST,false,false,false);
      setFieldValid(ifds::EventReceiptDate,BF::HOST,false);
      setFieldValid(ifds::EventReceiptTime,BF::HOST,false);
   }
   setFieldReadOnly(ifds::EventReceiptDate, BF::HOST, !bEventReceiptDateTimeAppl);
   setFieldReadOnly(ifds::EventReceiptTime, BF::HOST, !bEventReceiptDateTimeAppl);
   setFieldReadOnly(ifds::Platform, BF::HOST, true);
   DString dstrPSDAdvice;
   getWorkSession ().getOption (ifds::PSDAdvice, dstrPSDAdvice, BF::HOST,  false);
   if(  NO == dstrPSDAdvice.stripAll())	
   {
      addBlankToSubSet( ifds::SourceOfTrade,  BF::HOST );
      addBlankToSubSet( ifds::ChannelOfTrade, BF::HOST);
   }
   DString dstrPlatform, dstrDepositType;
   getField(ifds::Platform, dstrPlatform, BF::HOST);
   getField(ifds::DepositType, dstrDepositType, BF::HOST);
   setFieldReadOnly(ifds::SourceOfTrade, BF::HOST, !(PLATFORM::DESKTOP == dstrPlatform && I_( "2" ) != dstrDepositType ));   //I_("2") PAC
   setFieldReadOnly(ifds::ChannelOfTrade, BF::HOST,!(PLATFORM::DESKTOP == dstrPlatform && I_( "2" ) != dstrDepositType ));   //I_("2") PAC

   if(dstrPlatform.empty())
      setFieldNoValidate(ifds::Platform, PLATFORM::DESKTOP, BF::HOST, false, true, true);

   if(_bRebook) 
      populateFieldsWithDefaultValues(BF::HOST, MODE_REBOOK);

   setFieldReadOnly(ifds::PSDAdvice,BF::HOST, true);
   bool bSrc_Channel_ReadOnly  = false;
   DString dstrNetworkID,dstrAWDFieldFlag;
   getField (ifds::NetworkID, dstrNetworkID, BF::HOST);
   getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag,BF::HOST,false);
   if( !dstrNetworkID.empty()&& !( I_("AWD") == dstrNetworkID  && YES == dstrAWDFieldFlag ))  //AWD integration flag Yes use default,no change
   {  
      bSrc_Channel_ReadOnly  = true;        
      if(_bRebook)
      {
         setFieldNoValidate(ifds::SourceOfTrade, dstrNetworkID, BF::HOST, false, true, true, !_bInitPending );
         setFieldNoValidate(ifds::ChannelOfTrade, NULL_STRING, BF::HOST, false, true, true, !_bInitPending );	
      }
   }
   setFieldReadOnly(ifds::SourceOfTrade,  BF::HOST, bSrc_Channel_ReadOnly );
   setFieldReadOnly(ifds::ChannelOfTrade, BF::HOST, bSrc_Channel_ReadOnly );

   setFieldReadOnly (ifds::SettleNetwork, BF::HOST, true);
   for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
   {
      setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
   }
   setAccountNumbersFromSystemLevel( true, BF::HOST);

   DString strExternalInstitution, strOther, strTrackTrActive;
   getField (ifds::ExternalInstitution, strExternalInstitution, BF::HOST,false);
   strExternalInstitution.strip().upperCase();

   getWorkSession().getOption2(ifds::TrackTrOther,strOther,BF::HOST,false);
   getWorkSession().getOption2(ifds::TrackTrActive,strTrackTrActive,BF::HOST,false);
   strOther.strip().upperCase();
   strTrackTrActive.strip().upperCase();

   bool bisFieldEnable = strTrackTrActive == I_("Y");

   setFieldReadOnly (ifds::ExternalInstitution, BF::HOST, !bisFieldEnable );

   orderRoutingRelatedChanges (BF::HOST);

   RDSPTransfer *pRDSPTransfer (NULL);

   getRDSPTransfer (pRDSPTransfer, BF::HOST);

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::initRebook (const BFData &data)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("initRebook"));
   _bRebook = true;
   init (data);   //call init function
//save the old transNum to adjust transNum 

   TransFeeList* pTransFeeList = NULL;
   getTransFeeList(pTransFeeList, BF::HOST, false);
   
   DString toSaveFees[4];

   pTransFeeList->getTransFeeRate(I_("112"), toSaveFees[0], BF::HOST);
   pTransFeeList->getTransFeeRate(I_("122"), toSaveFees[1], BF::HOST);
   pTransFeeList->getTransFeeRate(I_("113"), toSaveFees[2], BF::HOST);
   pTransFeeList->getTransFeeRate(I_("123"), toSaveFees[3], BF::HOST);

   DString oldTransNum;

   getField (ifds::TransNum, oldTransNum, BF::HOST, false);
   setFieldNoValidate (ifds::AdjTransNum, oldTransNum, BF::HOST, false, false); 

   BFData query127 (ifds::DSTC0127_REQ);
   BFData *response = new BFData (ifds::DSTC0127_VW);
   DString mgmtCoIdOut, 
           payType, 
           transType;

   getField (ifds::TradesTransType, transType, BF::HOST, false);
   getField (ifds::TradesPayType, payType, BF::HOST, false);   
   query127.setElementValue (ifds::CompanyId, getMgmtCoId (mgmtCoIdOut));
   query127.setElementValue (ifds::Track, I_("N"));
   query127.setElementValue (ifds::Activity, NULL_STRING);
   query127.setElementValue (ifds::PayType, payType);
   query127.setElementValue (ifds::TransType, transType);
   if (BFDataBroker::getInstance ()->
         receive ( DSTC_REQUEST::TRANS_NUM, 
                     query127, 
                     *response, 
                     DSTCRequestor (getSecurity ())) <= WARNING)
   {
      DString dealTime, 
              dealDate,
              transNum,
              settleDate,
              tradeDate,
              batch,
              orderType;
//assign new transaction number
      response->getElementValue (ifds::TransNum, transNum);
      transNum.strip ().stripLeading ('0');
      setFieldNoValidate (ifds::TransNum, transNum, BF::HOST, false);
      setFieldReadOnly (ifds::TransNum, BF::HOST, true);

//assign new transaction number to SendRefNum
      setNetworkIDSendRefNum (BF::HOST, false);

//read current business date
      response->getElementValue (ifds::CurrBusDate, _currentBusinessDate);
      _currentBusinessDate.strip ();
//assign deal date and deal time
      response->getElementValue (ifds::DealTime, dealTime);
      dealTime.strip ();
	  
	  DString fromFund,fromClass;
	  getField (ifds::FromFund, fromFund, BF::HOST, false);
	  getField (ifds::FromClass, fromClass, BF::HOST, false);
	  bool bFromIsPF = getWorkSession ().isPerfFeeFund(fromFund,fromClass,BF::HOST);
      
	  setFieldNoValidate ( ifds::DealTime, dealTime, BF::HOST, false, 
                           !bFromIsPF);
      response->getElementValue (ifds::DealDate, dealDate);
      dealDate.strip();
      _todayDate = dealDate;
      setFieldNoValidate ( ifds::DealDate, dealDate, BF::HOST, false, 
                           !bFromIsPF); 
//if DealDateTime is Yes, DealDate and DealTime are updatable
      DString dealDateTime;

      getWorkSession ().getOption ( ifds::DealDateTime, 
                                    dealDateTime, 
                                    BF::HOST, 
                                    false);
      bool bRequired = dealDateTime == Y;
      setFieldRequired (ifds::DealDate, BF::HOST, bRequired && !isHypo()); 
      setFieldRequired (ifds::DealTime, BF::HOST, bRequired && !isHypo()); 
      setFieldReadOnly (ifds::DealDate, BF::HOST, !bRequired);
      setFieldReadOnly (ifds::DealTime, BF::HOST, !bRequired);

      pTransFeeList->setTransFeeRate(I_("112"), toSaveFees[0], BF::HOST);
      pTransFeeList->setTransFeeRate(I_("122"), toSaveFees[1], BF::HOST);
      pTransFeeList->setTransFeeRate(I_("113"), toSaveFees[2], BF::HOST);
      pTransFeeList->setTransFeeRate(I_("123"), toSaveFees[3], BF::HOST);
//assign batch name
      response->getElementValue (ifds::rxBatchName, batch);
      batch.strip();
      setFieldNoValidate (ifds::BatchName, batch, BF::HOST, false);
      DString autoBatching;

      getWorkSession ().getOption (ifds::AutoBatch, autoBatching, BF::HOST, false);

      bool bReadOnly = autoBatching.asInteger () == AUTO_BATCHING ? false : true;

      setFieldReadOnly (ifds::BatchName, BF::HOST, bReadOnly);
//clear trace number
      setFieldNoValidate (ifds::Trace, I_("0"), BF::HOST, false);
      _nextCycleDate = _currentBusinessDate;
   }
   else
   {
      setFieldNoValidate (ifds::BatchName, NULL_STRING, BF::HOST, false);
   }
   if (response)
   {
      delete response;
      response = NULL;
   }

// after field transnum\adjustedtransnum of rebooking trade initialized
// we would be able to load a dilution record for the trade properly
   loadDilution(BF::HOST);

// clear record id and version number for trade account allocation
// fund allocation and split commission
   TradeAcctAllocList* pAccountAllocationList = NULL;

   getAccountAllocationList (pAccountAllocationList, BF::HOST);
   if (pAccountAllocationList)
   {
      pAccountAllocationList->changeFieldsForRebook ();
   }
//   TransFeeList* pTransFeeList = NULL;

   getTransFeeList (pTransFeeList, BF::HOST); 
// record ID and replace transNum  in TransFeeList
   if (pTransFeeList)
   {   
      pTransFeeList->changeFieldsForRebook ();
   }

// clear  record ID and version number
   setFieldNoValidate ( ifds::InterDetlRid, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
   setFieldNoValidate ( ifds::VersionNum, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
   setFieldNoValidate (ifds::TransModPerm, I_("1"), BF::HOST, false);
//clear the ExtTransNum for trades that have the NetworkId set - Incident# 564040
//With AWD integartion project,P0203789,the ExtTransNum with NetworkType is a manual
//entry and need to behave the same way the updateNetworkIDExternalTransNum()behaves
   DString dstrAWDFieldFlag,dstrNetworkID;
   getField(ifds::NetworkID,dstrNetworkID,BF::HOST);
   getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag,BF::HOST,false);
   if(dstrNetworkID != I_("AWD") && dstrAWDFieldFlag != I_("Y") )
      setFieldNoValidate ( ifds::ExtTransNum, NULL_STRING, BF::HOST, false, 
                           false, false, 
                           false); //no related changes
// according to Winnie
// in multi currency environment, settlement currency should be blank and do validation at the end
// in single currency environemnt, settlement currency should default to fund currency
// if there is an allocation, default to the first fund currency in the allocation
// but why settlementcurrency is blank in first place, it is still a secreat.
// Yingbao as of Aug. 15, 2005
   DString settlCurrency;

   getField (ifds::SettleCurrency, settlCurrency, BF::HOST, false);
   settlCurrency.strip();
   if (settlCurrency.empty())
   {
      if (_multiCurrency == N) //non-multi currency environment
      {
         DString  fundCode, 
                  classCode,
                  fundCurrency;

         getFundField (ifds::FundCode, fundCode, BF::HOST);
         getFundField (ifds::ClassCode, classCode, BF::HOST);
         if (!fundCode.empty () && !classCode.empty())
         {
            getFundField (fundCode, classCode, ifds::Currency, fundCurrency);
         }
         else if (hasAllocations (BF::HOST))
         {
            TradeFundAllocList *pTradeFundAllocList = NULL;      
            
            if (getFundAllocationList (pTradeFundAllocList, BF::HOST, false) <= WARNING)
            {
               pTradeFundAllocList->getAllocCurrency (fundCurrency, BF::HOST);
            }
         }
         fundCurrency.strip();
         if (!fundCurrency.empty())
         {
            setFieldNoValidate (ifds::SettleCurrency, fundCurrency, BF::HOST, false, true, true, true);         
         }
      }  
   }

   setDefaultSuppressIndicators (ifds::MCHRbkTrade, ifds::SRRbkTrade, BF::HOST);
   setSuppressIndicatorsPerm (BF::HOST);
   deliveryNetworkRelatedChanges(BF::HOST);

   DString dstrSettleNetwork;
   getField(ifds::SettleNetwork, dstrSettleNetwork, BF::HOST, false);
   if(dstrSettleNetwork == I_("FSRV"))
   {
      DString date;
      DSTCommonFunctions::addDays(_currentBusinessDate, date, 1);
      setFieldNoValidate(ifds::SettleDate, date, BF::HOST, false, true, false, false);
      validateDate(DATE_VALIDATION::INPUT_SETTLE_DATE, ifds::SettleDate, date, BF::HOST);
      setFieldValid(ifds::SettleDate, BF::HOST, true);
      setFieldReadOnly(ifds::SettleDate, BF::HOST, true);
   }



   updateBranchCodeForRebook(BF::HOST);
   setFieldReadOnly( ifds::AggregationType, BF::HOST, true );
   setFieldReadOnly( ifds::SourceofFundsChecked, BF::HOST, true );   

   DString dstrCashdate;
   getField (ifds::CashDate, dstrCashdate, BF::HOST, false);
   if ( dstrCashdate.empty() )
   {
	   DString emptyDate;
	   getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, BF::HOST);
	   setFieldNoValidate (ifds::CashDate, emptyDate, BF::HOST, false,true, false, false);
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//*******************************************************************************
SEVERITY Trade::initRebookFromHistory(const BFData &data)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("initRebookFromHistory"));
   _bRebook = true;

   init (data);   //call init function
//save the old transNum to adjust transNum 
   DString oldTransNum;

   getField (ifds::TransNum, oldTransNum, BF::HOST, false);
   setFieldNoValidate (ifds::AdjTransNum, oldTransNum, BF::HOST, false, false); 

   BFData query127 (ifds::DSTC0127_REQ);
   BFData *response = new BFData (ifds::DSTC0127_VW);
   DString mgmtCoIdOut, 
           payType, 
           transType;

   getField (ifds::TradesTransType, transType, BF::HOST, false);
   getField (ifds::TradesPayType, payType, BF::HOST, false);   
   query127.setElementValue (ifds::CompanyId, getMgmtCoId (mgmtCoIdOut));
   query127.setElementValue (ifds::Track, I_("N"));
   query127.setElementValue (ifds::Activity, NULL_STRING);
   query127.setElementValue (ifds::PayType, payType);
   query127.setElementValue (ifds::TransType, transType);
   if (BFDataBroker::getInstance ()->
         receive ( DSTC_REQUEST::TRANS_NUM, 
                     query127, 
                     *response, 
                     DSTCRequestor (getSecurity ())) <= WARNING)
   {
      DString dealTime, 
              dealDate,
              transNum,
              settleDate,
              tradeDate,
              batch,
              orderType;

//assign new transaction number
      response->getElementValue (ifds::TransNum, transNum);
      transNum.strip ().stripLeading ('0');
      setFieldNoValidate (ifds::TransNum, transNum, BF::HOST, false);
      setFieldReadOnly (ifds::TransNum, BF::HOST, true);

//assign new transaction number to SendRefNum
      setNetworkIDSendRefNum (BF::HOST, false);
//read current business date
      response->getElementValue (ifds::CurrBusDate, _currentBusinessDate);
      _currentBusinessDate.strip ();
//assign deal date and deal time
      response->getElementValue (ifds::DealTime, dealTime);
      dealTime.strip ();

	  DString fromFund,fromClass;
	  getField (ifds::FromFund, fromFund, BF::HOST, false);
	  getField (ifds::FromClass, fromClass, BF::HOST, false);
	  bool bFromIsPF = getWorkSession ().isPerfFeeFund(fromFund,fromClass,BF::HOST);

      setFieldNoValidate ( ifds::DealTime, dealTime, BF::HOST, false, 
                           !bFromIsPF);
      response->getElementValue (ifds::DealDate, dealDate);
      dealDate.strip();
      _todayDate = dealDate;
      setFieldNoValidate ( ifds::DealDate, dealDate, BF::HOST, false, 
                           !bFromIsPF); 
//if DealDateTime is Yes, DealDate and DealTime are updatable
      DString dealDateTime;

      getWorkSession ().getOption ( ifds::DealDateTime, 
                                    dealDateTime, 
                                    BF::HOST, 
                                    false);
      bool bRequired = dealDateTime == Y;
      setFieldRequired (ifds::DealDate, BF::HOST, bRequired && !isHypo()); 
      setFieldRequired (ifds::DealTime, BF::HOST, bRequired && !isHypo()); 
      setFieldReadOnly (ifds::DealDate, BF::HOST, !bRequired);
      setFieldReadOnly (ifds::DealTime, BF::HOST, !bRequired);
//assign batch name
      response->getElementValue (ifds::rxBatchName, batch);
      batch.strip();
      setFieldNoValidate (ifds::BatchName, batch, BF::HOST, false);
      DString autoBatching;

      getWorkSession ().getOption (ifds::AutoBatch, autoBatching, BF::HOST, false);

      bool bReadOnly = autoBatching.asInteger () == AUTO_BATCHING ? false : true;

      setFieldReadOnly (ifds::BatchName, BF::HOST, bReadOnly);
//clear trace number
      setFieldNoValidate (ifds::Trace, I_("0"), BF::HOST, false);
      _nextCycleDate = _currentBusinessDate;
   }
   else
   {
      setFieldNoValidate (ifds::BatchName, NULL_STRING, BF::HOST, false);
   }
   if (response)
   {
      delete response;
      response = NULL;
   }

// after field transnum\adjustedtransnum of rebooking trade initialized
// we would be able to load a dilution record for the trade properly
   loadDilution(BF::HOST);

// clear record id and version number for trade account allocation
// fund allocation and split commission
   TradeAcctAllocList* pAccountAllocationList = NULL;

   getAccountAllocationList (pAccountAllocationList, BF::HOST);
   if (pAccountAllocationList)
   {
      pAccountAllocationList->changeFieldsForRebook ();
   }
   TransFeeList* pTransFeeList = NULL;

   getTransFeeList (pTransFeeList, BF::HOST); 
// record ID and replace transNum  in TransFeeList
   if (pTransFeeList)
   {   
      pTransFeeList->changeFieldsForRebook ();
   }

// clear  record ID and version number
   setFieldNoValidate ( ifds::InterDetlRid, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
   setFieldNoValidate ( ifds::VersionNum, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
   setFieldNoValidate (ifds::TransModPerm, I_("1"), BF::HOST, false);
//clear the ExtTransNum for trades that have the NetworkId set - Incident# 564040
   setFieldNoValidate ( ifds::ExtTransNum, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
// according to Winnie
// in multi currency environment, settlement currency should be blank and do validation at the end
// in single currency environemnt, settlement currency should default to fund currency
// if there is an allocation, default to the first fund currency in the allocation
// but why settlementcurrency is blank in first place, it is still a secreat.
// Yingbao as of Aug. 15, 2005
   DString settlCurrency;

   getField (ifds::SettleCurrency, settlCurrency, BF::HOST, false);
   settlCurrency.strip();
   if (settlCurrency.empty())
   {
      if (_multiCurrency == N) //non-multi currency environment
      {
         DString  fundCode, 
                  classCode,
                  fundCurrency;

         getFundField (ifds::FundCode, fundCode, BF::HOST);
         getFundField (ifds::ClassCode, classCode, BF::HOST);
         if (!fundCode.empty () && !classCode.empty())
         {
            getFundField (fundCode, classCode, ifds::Currency, fundCurrency);
         }
         else if (hasAllocations (BF::HOST))
         {
            TradeFundAllocList *pTradeFundAllocList = NULL;      
            
            if (getFundAllocationList (pTradeFundAllocList, BF::HOST, false) <= WARNING)
            {
               pTradeFundAllocList->getAllocCurrency (fundCurrency, BF::HOST);
            }
         }
         fundCurrency.strip();
         if (!fundCurrency.empty())
         {
            setFieldNoValidate (ifds::SettleCurrency, fundCurrency, BF::HOST, false, true, true, true);         
         }
      }
   }

   setDefaultSuppressIndicators (ifds::MCHRbkTrade, ifds::SRRbkTrade, BF::HOST);
   setSuppressIndicatorsPerm (BF::HOST);
   setFieldReadOnly( ifds::AggregationType, BF::HOST, true );
   setFieldReadOnly( ifds::SourceofFundsChecked, BF::HOST, true );
   DString dstrNetWorkID;
   getFieldBeforeImage( ifds::NetworkID, dstrNetWorkID);
   if( I_("NSCC") ==dstrNetWorkID )
       setFieldNoValidate( ifds::RoundFlag, NULL_STRING, BF::HOST, false, true, false, false);

   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
SEVERITY Trade::initRefund (const BFData &data)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("initRefund"));
   _bRebook = false;
   _bRefund = true;
   init (data);   //call init function
//save the old transNum to adjust transNum 

   TransFeeList* pTransFeeList = NULL;
   getTransFeeList(pTransFeeList, BF::HOST, false);
   
   DString oldTransNum;

   getField (ifds::TransNum, oldTransNum, BF::HOST, false);
   setFieldNoValidate (ifds::AdjTransNum, oldTransNum, BF::HOST, false, false); 

   BFData query127 (ifds::DSTC0127_REQ);
   BFData *response = new BFData (ifds::DSTC0127_VW);
   DString mgmtCoIdOut, 
           payType, 
           transType;

   getField (ifds::TradesTransType, transType, BF::HOST, false);
   getField (ifds::TradesPayType, payType, BF::HOST, false);   
   query127.setElementValue (ifds::CompanyId, getMgmtCoId (mgmtCoIdOut));
   query127.setElementValue (ifds::Track, I_("N"));
   query127.setElementValue (ifds::Activity, NULL_STRING);
   query127.setElementValue (ifds::PayType, payType);
   query127.setElementValue (ifds::TransType, transType);
   if (BFDataBroker::getInstance ()->receive ( DSTC_REQUEST::TRANS_NUM, query127, *response, DSTCRequestor (getSecurity ())) <= WARNING)
   {
      DString dealTime, 
              dealDate,
              transNum,
              settleDate,
              tradeDate,
              batch,
              orderType;
//assign new transaction number
      response->getElementValue (ifds::TransNum, transNum);
      transNum.strip ().stripLeading ('0');
      setFieldNoValidate (ifds::TransNum, transNum, BF::HOST, false);
      setFieldReadOnly (ifds::TransNum, BF::HOST, true);

//assign new transaction number to SendRefNum
      setNetworkIDSendRefNum (BF::HOST, false);

//read current business date
      response->getElementValue (ifds::CurrBusDate, _currentBusinessDate);
      _currentBusinessDate.strip ();
//assign deal date and deal time
	  
	  DString fromFund,fromClass;
	  getField (ifds::FromFund, fromFund, BF::HOST, false);
	  getField (ifds::FromClass, fromClass, BF::HOST, false);
	  bool bFromIsPF = getWorkSession ().isPerfFeeFund(fromFund,fromClass,BF::HOST);
      
      response->getElementValue (ifds::DealTime, dealTime);
      dealTime.strip ();
      setFieldNoValidate ( ifds::DealTime, dealTime, BF::HOST, false, !bFromIsPF, false, false);

      response->getElementValue (ifds::DealDate, dealDate);
      _todayDate = dealDate.strip();;
      setFieldNoValidate ( ifds::DealDate, dealDate, BF::HOST, false, !bFromIsPF, false, false); 

//if DealDateTime is Yes, DealDate and DealTime are updatable
      DString dealDateTime;

      getWorkSession ().getOption ( ifds::DealDateTime, dealDateTime, BF::HOST, false);
      bool bRequired = dealDateTime == Y;

      setFieldRequired (ifds::DealDate, BF::HOST, bRequired && !isHypo()); 
      setFieldRequired (ifds::DealTime, BF::HOST, bRequired && !isHypo()); 
      setFieldReadOnly (ifds::DealDate, BF::HOST, !bRequired);
      setFieldReadOnly (ifds::DealTime, BF::HOST, !bRequired);

	  //trade date (effective date)
	  response->getElementValue (ifds::TradeDate, tradeDate);
	  tradeDate.strip();
	  validateDate ( DATE_VALIDATION::DEFAULT_TRADE_DATE, ifds::EffectiveDate, tradeDate, BF::HOST);

	  MFAccount *pMFAccount = NULL;
	  DString dstrTaxType,dstrAccountNum;
	  bool copyUnits = false;

	  getField (ifds::AccountNum, dstrAccountNum, BF::HOST, false);
	  if ( getWorkSession().getMFAccount ( BF::HOST, 
		  dstrAccountNum, 
		  pMFAccount) <= WARNING && 
		  pMFAccount)
	  {
		  pMFAccount->getField (ifds::TaxType, dstrTaxType, BF::HOST);
		  if (DSTCommonFunctions::codeInList (dstrTaxType, I_("SA,OA,SR")))
		  {
				copyUnits = true;			  
				DString dstrUnits;
				SEVERITY sevRtn = SEVERE_ERROR;
				sevRtn = getPurchasedUnits(dstrUnits, BF::HOST);
				if( WARNING >= sevRtn )
				{
					setField(ifds::Amount, dstrUnits, BF::HOST, false);
				}
				else
				{
					copyUnits = false; //Set amount to 0
				}

				setFieldReadOnly (ifds::Amount, BF::HOST, true);
		  }
	  }

	  if (!copyUnits)
      setField(ifds::Amount, I_("0"), BF::HOST, false);

      setFieldNoValidate (ifds::OrderType, Y, BF::HOST, false);
      setFieldNoValidate (ifds::TradesPayType, I_("X"), BF::HOST, false); //supperss
      setFieldNoValidate (ifds::RefundAmtOpt, I_("02"), BF::HOST, false);
      setFieldNoValidate (ifds::RedCode, I_("01"), BF::HOST, false);
      setFieldNoValidate (ifds::AmtType, I_("U"), BF::HOST, true);

      setFieldReadOnly (ifds::AmtType, BF::HOST, true);
      setFieldReadOnly (ifds::FromFund, BF::HOST, true);
      setFieldReadOnly (ifds::FromClass, BF::HOST, true);
      setFieldReadOnly (ifds::FromFundNumber, BF::HOST, true);
      setFieldReadOnly (ifds::FundISIN, BF::HOST, true);

      setFieldReadOnly (ifds::FundWKN, BF::HOST, true);
      setFieldReadOnly (ifds::FundLFC, BF::HOST, true);
      setFieldReadOnly (ifds::FundISIN, BF::HOST, true);


     //assign batch name
      response->getElementValue (ifds::rxBatchName, batch);
      batch.strip();
      setFieldNoValidate (ifds::BatchName, batch, BF::HOST, false);
      DString autoBatching;

      getWorkSession ().getOption (ifds::AutoBatch, autoBatching, BF::HOST, false);

      bool bReadOnly = autoBatching.asInteger () == AUTO_BATCHING ? false : true;

      setFieldReadOnly (ifds::BatchName, BF::HOST, bReadOnly);
//clear trace number
      setFieldNoValidate (ifds::Trace, I_("0"), BF::HOST, false);
      _nextCycleDate = _currentBusinessDate;
   }
   else
   {
      setFieldNoValidate (ifds::BatchName, NULL_STRING, BF::HOST, false);
   }
   if (response)
   {
      delete response;
      response = NULL;
   }

// after field transnum\adjustedtransnum of rebooking trade initialized
// we would be able to load a dilution record for the trade properly
   loadDilution(BF::HOST);

// clear record id and version number for trade account allocation
// fund allocation and split commission
   TradeAcctAllocList* pAccountAllocationList = NULL;

   getAccountAllocationList (pAccountAllocationList, BF::HOST);
   if (pAccountAllocationList)
   {
      pAccountAllocationList->changeFieldsForRebook ();
   }
//   TransFeeList* pTransFeeList = NULL;

   getTransFeeList (pTransFeeList, BF::HOST); 
// record ID and replace transNum  in TransFeeList
   if (pTransFeeList)
   {   
      pTransFeeList->changeFieldsForRebook ();
   }

// clear  record ID and version number
   setFieldNoValidate ( ifds::InterDetlRid, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
   setFieldNoValidate ( ifds::VersionNum, NULL_STRING, BF::HOST, false, 
                        false, false, 
                        false); //no related changes
   setFieldNoValidate (ifds::TransModPerm, I_("1"), BF::HOST, false);
//clear the ExtTransNum for trades that have the NetworkId set - Incident# 564040
//With AWD integartion project,P0203789,the ExtTransNum with NetworkType is a manual
//entry and need to behave the same way the updateNetworkIDExternalTransNum()behaves
   DString dstrAWDFieldFlag,dstrNetworkID;
   getField(ifds::NetworkID,dstrNetworkID,BF::HOST);
   getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag,BF::HOST,false);
   if(dstrNetworkID != I_("AWD") && dstrAWDFieldFlag != I_("Y") )
      setFieldNoValidate ( ifds::ExtTransNum, NULL_STRING, BF::HOST, false, 
                           false, false, 
                           false); //no related changes
// according to Winnie
// in multi currency environment, settlement currency should be blank and do validation at the end
// in single currency environemnt, settlement currency should default to fund currency
// if there is an allocation, default to the first fund currency in the allocation
// but why settlementcurrency is blank in first place, it is still a secreat.
// Yingbao as of Aug. 15, 2005
   DString settlCurrency;

   getField (ifds::SettleCurrency, settlCurrency, BF::HOST, false);
   settlCurrency.strip();
   if (settlCurrency.empty())
   {
      if (_multiCurrency == N) //non-multi currency environment
      {
         DString  fundCode, 
                  classCode,
                  fundCurrency;

         getFundField (ifds::FundCode, fundCode, BF::HOST);
         getFundField (ifds::ClassCode, classCode, BF::HOST);
         if (!fundCode.empty () && !classCode.empty())
         {
            getFundField (fundCode, classCode, ifds::Currency, fundCurrency);
         }
         else if (hasAllocations (BF::HOST))
         {
            TradeFundAllocList *pTradeFundAllocList = NULL;      
            
            if (getFundAllocationList (pTradeFundAllocList, BF::HOST, false) <= WARNING)
            {
               pTradeFundAllocList->getAllocCurrency (fundCurrency, BF::HOST);
            }
         }
         fundCurrency.strip();
         if (!fundCurrency.empty())
         {
            setFieldNoValidate (ifds::SettleCurrency, fundCurrency, BF::HOST, false, true, true, true);         
         }
      }  
   }

   setDefaultSuppressIndicators (ifds::MCHRbkTrade, ifds::SRRbkTrade, BF::HOST);
   setSuppressIndicatorsPerm (BF::HOST);
   deliveryNetworkRelatedChanges(BF::HOST);

   DString dstrSettleNetwork;
   getField(ifds::SettleNetwork, dstrSettleNetwork, BF::HOST, false);
   if(dstrSettleNetwork == I_("FSRV"))
   {
      DString date;
      DSTCommonFunctions::addDays(_currentBusinessDate, date, 1);
      setFieldNoValidate(ifds::SettleDate, date, BF::HOST, false, true, false, false);
      validateDate(DATE_VALIDATION::INPUT_SETTLE_DATE, ifds::SettleDate, date, BF::HOST);
      setFieldValid(ifds::SettleDate, BF::HOST, true);
      setFieldReadOnly(ifds::SettleDate, BF::HOST, true);
   }



   updateBranchCodeForRebook(BF::HOST);
   setFieldReadOnly( ifds::AggregationType, BF::HOST, true );
   setFieldReadOnly( ifds::SourceofFundsChecked, BF::HOST, true );   

   return GETCURRENTHIGHESTSEVERITY ();
}

//*******************************************************************************
SEVERITY Trade::updateBranchCodeForRebook(const BFDataGroupId &idDataGroup)
{
    MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("updateBranchCodeForRebook"));

    DString dstrRepByBranch, dstrBranch, dstrSlsRep, accBranchCode, accSlsRep;
    getWorkSession().getOption( ifds::RepByBranch, dstrRepByBranch, idDataGroup, false );
   
    getAccountField(ifds::BranchCode, accBranchCode, idDataGroup);
    getAccountField(ifds::Slsrep, accSlsRep, idDataGroup);
    getField(ifds::Branch, dstrBranch, idDataGroup);
    getField(ifds::SlsrepCode, dstrSlsRep, idDataGroup);

    if( dstrRepByBranch.stripAll().upperCase() == N && 
        dstrBranch.stripAll().upperCase() != accBranchCode.stripAll().upperCase() &&
        dstrSlsRep.stripAll().upperCase() == accSlsRep.stripAll().upperCase())
    {
        Agent *pAgent = NULL;
        DString agentBranchCode;

        if (getAgent(pAgent, idDataGroup) <= WARNING && pAgent)
        {
            pAgent->getField(ifds::BranchCode, agentBranchCode, idDataGroup);
            setFieldNoValidate( ifds::Branch, agentBranchCode, idDataGroup, false, false, true, false);
        }
    }

    return GETCURRENTHIGHESTSEVERITY ();
}

//*******************************************************************************
SEVERITY Trade::postInitRebook ( const BFDataGroupId &idDataGroup,
                                 bool bMultipleRebook)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("postInitRebook"));
   setFieldValid (ifds::Accountable, idDataGroup, false);
   setFieldValid (ifds::BackDatedReason, idDataGroup, false);
   setFieldValid (ifds::AcctableTradeDate, idDataGroup, false); 
   if (_multiCurrency == Y) //multi currency environment
   {
      setFieldValid (ifds::SettleCurrency, idDataGroup, false);
   }
//Incident 390388 - for multiple rebooks clear out the wire order number (user will be forced to input it)
   if (bMultipleRebook) 
   {
//clear out the wire order num
      setFieldNoValidate ( ifds::WireOrdNum, NULL_STRING, idDataGroup, false,
                           false, //invalid
                           true, false);
   }

   //set the correct value and access for RecptIssued
   //setRecptIssuedForRebook( idDataGroup );
   DString strFromHistoryTrade;
   getField( ifds::FromHistoryTrade, strFromHistoryTrade, idDataGroup, false );

   if ( strFromHistoryTrade == I_("Y"))
   {
      if( isPurchase(idDataGroup) )
      {
         setRecptIssuedForRebook( idDataGroup );
      }
   }
   else
   {
      setRecptIssuedForRebook( idDataGroup );
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

SEVERITY Trade::postInitRefund ( const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("postInitRebook"));
   setFieldValid (ifds::Accountable, idDataGroup, false);
   setFieldValid (ifds::BackDatedReason, idDataGroup, false);
   setFieldValid (ifds::AcctableTradeDate, idDataGroup, false); 
   if (_multiCurrency == Y) //multi currency environment
   {
      setFieldValid (ifds::SettleCurrency, idDataGroup, false);
   }

   //set the correct value and access for RecptIssued
   //setRecptIssuedForRebook( idDataGroup );
   DString strFromHistoryTrade;
   getField( ifds::FromHistoryTrade, strFromHistoryTrade, idDataGroup, false );

   if ( strFromHistoryTrade == I_("Y"))
   {
      if( isPurchase(idDataGroup) )
      {
         setRecptIssuedForRebook( idDataGroup );
      }
   }
   else
   {
      setRecptIssuedForRebook( idDataGroup );
   }

   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
void Trade::doReset (const BFDataGroupId &idDataGroup)
{
   firstLineInInit (idDataGroup);
}

//******************************************************************************
SEVERITY Trade::preInitWithDefaultValues (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("preInitWithDefaultValues"));
//generaly this method should not have any set fields (or 'setfieldnovalidate')
//things like setting fields read only or required based on system featurs data
//or because they are supposed to be that way, 
//setting subst sets, etc should go in here
//this method is called by both inits (the 'new' init and the 'pending' init)
//in either case field values should already be set (in one by the 'doInitWithDefaultValue'
//in the other one by the 'attachdataobject'); 
//what remains to be set are the properties of the field, and this is exactly what this
//method does

//make sure that the 'to side' is completly in darkness (read-only)
   setFieldReadOnly (ifds::AccountTo, idDataGroup, true);
   setFieldReadOnly (ifds::FromCurrency, idDataGroup, true);
   setFieldReadOnly (ifds::ToFund, idDataGroup, true);
   setFieldReadOnly (ifds::ToClass, idDataGroup, true);
   setFieldReadOnly (ifds::ToFundNumber, idDataGroup, true);
   setFieldReadOnly (ifds::FundToISIN, idDataGroup, true);
   setFieldReadOnly (ifds::FundToWKN, idDataGroup, true);
   setFieldReadOnly (ifds::FundToLFC, idDataGroup, true);
   setFieldReadOnly (ifds::ToCUSIP, idDataGroup, true);
   if (_multiCurrency == N)
   {
      setFieldReadOnly (ifds::SettleCurrency, idDataGroup, true);
   }
   setFieldRequired ( ifds::TradesPayType, 
                      idDataGroup, 
                      !isHypo());
   setFieldRequired (ifds::BatchName, idDataGroup, !isHypo ());

   DString slsepByBranch;

   getWorkSession ().getOption ( ifds::RepByBranch, 
                                 slsepByBranch, 
                                 BF::HOST,
                                 false);
   if (slsepByBranch == N)
   {
      setFieldReadOnly (ifds::Branch, idDataGroup, true);
   }   
   
   DString srcOfFundMandatory;

   getWorkSession ().getOption ( ifds::SrcOfFundMandatory, 
                                 srcOfFundMandatory, 
                                 BF::HOST,
                                 false);
   setFieldRequired ( ifds::SrcOfFund, 
                      idDataGroup, 
                      srcOfFundMandatory == Y && !isHypo());
   setFieldReadOnly (ifds::UseEnteredFee, idDataGroup, true);

   DString canSuppressConfirm;

   getWorkSession ().getOption ( ifds::CanSuppressConfirm, 
                                 canSuppressConfirm, 
                                 BF::HOST,
                                 false);
   setFieldReadOnly (ifds::ConfirmRequired, idDataGroup, canSuppressConfirm != Y);
   setFieldReadOnly (ifds::RecptIssued, idDataGroup, true);
//lsif code initialization
   DString fundCode;
   getField (ifds::FromFund, fundCode, idDataGroup, false);
   FundMasterList *pFundMasterList = NULL; 
   bool bIsLisfFund = false;
   if ( !fundCode.empty() && 
         getMgmtCo().getFundMasterList (pFundMasterList) && 
         NULL != pFundMasterList )
   {
      bIsLisfFund = pFundMasterList->isLSIFFund (fundCode);
   }
   setFieldReadOnly (ifds::LSIFCode, idDataGroup, !bIsLisfFund);   
   
//source of account-updatable:
   DString bankSrcAcct;

   getWorkSession ().getOption ( ifds::BankSrcAcct, 
                                 bankSrcAcct, 
                                 BF::HOST, 
                                 false);
   setFieldReadOnly (ifds::SrcOfAccount, idDataGroup, bankSrcAcct == Y);
   setFieldReadOnly (ifds::FundBrokerCode, idDataGroup, true);
   setFieldReadOnly (ifds::DiscountRate, idDataGroup, true); //this is calculated, no need to be touched
   setFieldReadOnly (ifds::AcqFeeOption, idDataGroup, true);
   setFieldReadOnly ( ifds::AggregateOption, idDataGroup, 
                      !getWorkSession().hasUpdatePermission (UAF::AGGREGATE_OPTION));
   setFieldReadOnly (ifds::AggOrdAdjustNum, idDataGroup, true);
//set the 'other confirm type subst set'
   BFProperties *pBFPropertiesOCT = 
      getFieldProperties (ifds::OtherConfirmType, idDataGroup);

   assert (pBFPropertiesOCT);
   if (pBFPropertiesOCT)
   {
      DString otherConfirmTypeSubstList;

      pBFPropertiesOCT->getAllSubstituteValues (otherConfirmTypeSubstList);
      {
         otherConfirmTypeSubstList = I_("=N/A;") + otherConfirmTypeSubstList;
         setFieldAllSubstituteValues (ifds::OtherConfirmType, idDataGroup, otherConfirmTypeSubstList);
      }
   }
   setFieldReadOnly (ifds::PayInstrOption, idDataGroup, true);
   setFieldReadOnly (ifds::CloneAcctAMS, idDataGroup, true);

   DString companyCode (NULL_STRING);
   getWorkSession().getOption (ifds::CompanyCode, companyCode, idDataGroup, false);
   companyCode = companyCode.upperCase();
   
   //force validation for this cross edit, regardless if the user changed the field values or not
   setValidFlag (ifds::DepTypeTradeDate, idDataGroup, false);
   //force validation for EffectiveDate, regardless if the user changed the field values or not - in order to trigger start/end date validation
   setValidFlag (ifds::EffectiveDate, idDataGroup, false);

   if (isAssociationWithBeneficiaryAllowed(idDataGroup))
   {
	   initBeneficiarySubList (idDataGroup);
   }
   else if (isAIPAllowed (idDataGroup))
   {
		initAccountHoldersSubList (idDataGroup);
   }
   else
   {
	   //populate former spouses substitution list
      DString strFormerSpouses;
         
      if (getFormerSpouseList (strFormerSpouses, idDataGroup) <= WARNING)
      {
         setFieldAllSubstituteValues (ifds::LinkedEntityId, idDataGroup, strFormerSpouses);
      }
   }
   
   setFieldReadOnly (ifds::RESPContrDetlTaxYear, idDataGroup, true);
   setFieldReadOnly (ifds::AssistedContrAmt, idDataGroup, true);

   setRespRequiredSubstList(idDataGroup);
   setFieldReadOnly (ifds::NetworkRespRequired, idDataGroup, true);
   //IN2689391 - PET0185010_FN01: CESG Paid is tracked at the EAP level
   setFieldReadOnly (ifds::EAPCESGPaid, idDataGroup, true); 
   setFieldReadOnly (ifds::ValuationDt, idDataGroup, true);
   setFieldReadOnly (ifds::ValuationInDt, idDataGroup, true);
   
   DString dstrForcedRate;
   getField (ifds::ForcedRate, dstrForcedRate, idDataGroup, false);
   dstrForcedRate.strip().upperCase();
   if(dstrForcedRate == FORCED_RATE_FORCED)
   {
      setFieldReadOnly (ifds::ForcedRateAmt, idDataGroup, false);
   }
   else
   {
      setFieldReadOnly (ifds::ForcedRateAmt, idDataGroup, true);
   }   
   
   setFieldReadOnly (ifds::IntRate, idDataGroup, true);
   setFieldReadOnly(ifds::ExtTransNum,idDataGroup,true);
   setFieldReadOnly( ifds::AggregationType, idDataGroup, true );
   setFieldReadOnly( ifds::SourceofFundsChecked, idDataGroup, true );
   setFieldReadOnly( ifds::PricingCode, idDataGroup, true );
   setFieldReadOnly( ifds::PriceInCode, idDataGroup, true );
   setFieldReadOnly( ifds::GateOverrideIndicator, idDataGroup, true );
   setFieldReadOnly( ifds::RDSPPaymtDate, idDataGroup, true );

   addBlankToSubSet (ifds::Deconversion, idDataGroup);
   addBlankToSubSet (ifds::FullMoneyOutIndc, idDataGroup);

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
void Trade::doInitWithDefaultValues (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("doInitWithDefaultValues"));
//read the trade defaults from the management company options

   DString fieldAssignment;

   getField (ifds::FieldAssignment, fieldAssignment, idDataGroup, false);

   setFieldNoValidate ( ifds::PayInstrOption, I_("02"), idDataGroup,  //redirect to shareholder
                           false, 
                           false,
                           true);

   DString payType,
      amtType, awdAmtType,
      frClearingMethod,
      fileProcessor;

   getField (ifds::AmtType, awdAmtType, idDataGroup, false);
 
   getTradeDefaults ( payType, 
                      amtType, 
                      frClearingMethod, //not set in here, see 'clearingRelatedChanges'
                      fileProcessor, 
                      idDataGroup);
   //if payType is empty from management company options, 
   //do not override the existing default
   if ( !_bAlreadySetPayTypeDefaults && 
        !payType.empty() && fieldAssignment != I_("API"))
   {
      setFieldNoValidate ( ifds::TradesPayType, payType, idDataGroup, false, 
                           false,
                           true);
   }
   else //call related changes for the existing default pay type
   {
      payTypeRelatedChanges (idDataGroup);
      getField (ifds::TradesPayType, payType, idDataGroup, false);
   }
//pay method, default
   //incident# 1152508 - do not set pay method default if alredy read the defaults from the pay entity level
   if (!_bAlreadySetPayTypeDefaults) 
   {
      setFieldNoValidate ( ifds::PayMethod, DSTCommonFunctions::getMarket() != MARKET_IDS::CANADA ? I_("WIRE"): I_("EFT"), idDataGroup, false, 
                           true, 
                           true, //notify
                           false); //no related changes
   }
   if (fieldAssignment != I_("FromAWD") ||
	   (fieldAssignment == I_("FromAWD") && awdAmtType.empty ()))
   {

      if (amtType.empty())
      {
         amtType = I_("D"); //amount
      }
      setFieldNoValidate ( ifds::AmtType, amtType, idDataGroup, false,
                           false,
                           false, // do not notify
                           false); //no related changes

      setAllocField (ifds::AmtType, ifds::AllocAmtType, idDataGroup);
      setFromAllocField (ifds::AmtType, ifds::AllocAmtType, idDataGroup);
   }
   if (payType != PAYTYPE::CLEARING)
   {
      if ( !_bAlreadySetPayTypeDefaults && 
           !fileProcessor.empty()&& 
		   isFileProccessorApplicable(idDataGroup))//if FileProccessorNotApplicable dont set the fileprocessor instead of BLANK
      {
         DString tradeFileProcessor;

         getField (ifds::ACHProcessor, tradeFileProcessor, idDataGroup, false);
         if (tradeFileProcessor != fileProcessor)
         {
            setFieldNoValidate ( ifds::ACHProcessor, fileProcessor, idDataGroup, false,
                                 false,
                                 true);
         }
      }
      else 
      {
         fileProcessorRelatedChanges (idDataGroup);
      }
   }
   payMethodPropertyChanges (idDataGroup);
   if (fieldAssignment != I_("FromAWD"))
   {
      setFieldNoValidate ( ifds::Amount, I_("0"), idDataGroup, false, 
                           true, 
                           false, //do not notify,
                           false); //no related changes
   }
//if non-multi currency environment default the currency to the system currency
//settle currency is linked to the banking, so set the default after 
//all the banking related fields have their defaults already set
   DString sysCurrency,
      defSetlCurrency;

   getWorkSession ().getOption ( ifds::SysCurrency, 
                                 sysCurrency, 
                                 BF::HOST,
                                 false);
   getWorkSession().getOption ( ifds::DefSetlCurrency, 
                                defSetlCurrency, 
                                BF::HOST, 
                                false);
   if (!sysCurrency.empty() && defSetlCurrency == Y)
   {
      setFieldNoValidate ( ifds::SettleCurrency, sysCurrency, idDataGroup, false,
                           true,
                           true,
                           true);
   }

//unknown in the beginning   
   setFieldNoValidate ( ifds::SettledBy, NULL_STRING, idDataGroup, false,
                        true, //valid
                        true);
// default to 'I' as per request PTS 10005021
   setFieldNoValidate ( ifds::SettleType, I_ ("I"), idDataGroup, false, 
                        true, 
                        false, //do not notify
                        false);  //no related changes
   setFieldNoValidate ( ifds::SettleSource, I_("D"), //dealer
                        idDataGroup, 
                        false,
                        false, //not valid, validation in redemption will be triggered
                        false);  //do not notify
   setFieldNoValidate ( ifds::DepositType, I_("1"), idDataGroup, false, 
                        true, 
                        false, 
                        false);
   setFieldNoValidate ( ifds::GoodBad, Y, idDataGroup, false, 
                        true, 
                        false, 
                        false);
   setFieldNoValidate ( ifds::GrossOrNet, Y, idDataGroup, false,
                        true, 
                        false, 
                        false);
   setFieldNoValidate ( ifds::UseEnteredFee, N, idDataGroup, false, 
                        true, 
                        false, 
                        false);
   setFieldNoValidate ( ifds::CertRequired, N, idDataGroup, false, 
                        true, 
                        false, 
                        false);
   setFieldNoValidate ( ifds::ConfirmRequired, Y, idDataGroup, false, 
                        true, 
                        false, 
                        false);
//recpt issued should be always read only and set to 'N'
   setFieldNoValidate ( ifds::RecptIssued, N, idDataGroup, false, 
                        true, 
                        false, 
                        false);
//lsif code set to null string
   setFieldNoValidate ( ifds::LSIFCode, NULL_STRING, idDataGroup, false, 
                        true,
                        true, //notify
                        false);
   setFieldNoValidate ( ifds::CloneAcctAMS, N, idDataGroup, false, //should be no
                        true,
                        true, //notify
                        false);
//exchange rate
   setExchRate (idDataGroup);
//backdate reason, accountability field
   //accountableBackdatedRelatedChanges (idDataGroup); 
   //Always default to read only during init since only after user update the trade date 
   //should the system need to consider enable of the field
   setFieldReadOnly (ifds::Accountable, idDataGroup, true);
   setFieldReadOnly (ifds::BackDatedReason, idDataGroup, true);
   setFieldReadOnly (ifds::SettleNetwork, idDataGroup, true);
   setFieldReadOnly (ifds::ROAAmount, idDataGroup, true);

//address code
   if (isShareholderAddressNeeded (idDataGroup))
   {
      setFieldNoValidate (ifds::AddrCode, I_("01"), idDataGroup, false);
   }
//special enhancement for mifund, 
//get the default trade date for future dated EFT's
   DString eftPurchFuture;

   getWorkSession().getOption ( ifds::EFTPurchFuture, 
                                eftPurchFuture, 
                                BF::HOST, 
                                false);
   if ( eftPurchFuture == Y && 
        payType == PAYTYPE::EFT) 
   {
      validateDate ( DATE_VALIDATION::DEFAULT_TRADE_DATE, 
                     ifds::CurrBusDate, 
                     _currentBusinessDate, 
                     idDataGroup);
   }
//acq fee option
   setFieldNoValidate (ifds::AcqFeeOption, I_("0"), idDataGroup, false); //regular
//api fields
   setFieldNoValidate (ifds::ForceVerify, N, idDataGroup, false);
//always modifiable for new trades
   setFieldNoValidate (ifds::TransModPerm, I_("1"), idDataGroup, false);
   DString validNetworkType,networkTypeUpd, dstrAWDFieldFlag; 
   getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag,BF::HOST,false);
   if (dstrAWDFieldFlag == I_("Y"))
   {
    // We need to set the default before calling network related changes 
	getWorkSession().getOption ( ifds::NetworkTypeUpd, networkTypeUpd, BF::HOST, false);
	BFProperties *pBFPropNetworkID = getFieldProperties (ifds::NetworkID, idDataGroup);
    if (pBFPropNetworkID)
   	    pBFPropNetworkID->getAllSubstituteValues (validNetworkType);//check if the list has got AWD in .
	validNetworkType.stripAll();
	if(networkTypeUpd == I_("Y") && !validNetworkType.empty()&&
	   (validNetworkType.find (I_("AWD=")) != DString::npos ))
	{
	 //no apply related chnage as networkIDRelatedChanges() will take care.To avoid redundant calls 
	 setFieldNoValidate (ifds::NetworkID, I_("AWD"), idDataGroup, false,true,false,false);
	}  
   }
   networkIDRelatedChanges (idDataGroup);
//fee fields
   initFeeFields (idDataGroup);

   setDefaultSuppressIndicators( ifds::MCHNewTrade, ifds::SRNewTrade, idDataGroup);
   setSuppressIndicatorsPerm (idDataGroup);
   setFieldNoValidate (ifds::ESGSettle, I_("In"), idDataGroup, false);
   setFieldNoValidate (ifds::CloneAcctAMS, I_("N"), idDataGroup, false);
   setFieldNoValidate (ifds::RESPReportHRDC, I_("N"), idDataGroup, false);
   setFieldNoValidate (ifds::Tainted, I_("N"), idDataGroup, false);
   setFieldNoValidate (ifds::RESPLetter, I_("N"), idDataGroup, false);
   setFieldNoValidate (ifds::RESPTransStat, I_("N"), idDataGroup, false);

   if (!isAssociationWithBeneficiaryAllowed (idDataGroup))
   {
      setFieldReadOnly (ifds::RESPReportHRDC, idDataGroup, true);
      setFieldReadOnly (ifds::GRRepayReason, idDataGroup, true);
   }
   setFieldReadOnly (ifds::AssocTransId, idDataGroup, true);
   ResetPendTrdContract (idDataGroup);
   updateGuaranteeFeeOverride (idDataGroup);
  
   setFieldNoValidate (ifds::RDRAdvice, I_("00"), idDataGroup, false); 
   setFieldReadOnly (ifds::RDRAdvice, idDataGroup, true);

   setGIDIFTradePayType (idDataGroup);   
   setCommRedRateSubstitutionSet (idDataGroup);
   bool bDealDateTimeAppl = bIsEventReceiptDateTimeAppl(idDataGroup);;
   setFieldReadOnly(ifds::EventReceiptDate, idDataGroup, !bDealDateTimeAppl);
   setFieldReadOnly(ifds::EventReceiptTime, idDataGroup, !bDealDateTimeAppl);
   setFieldValid(ifds::EventReceiptDate,idDataGroup,false);
   setFieldValid(ifds::EventReceiptTime,idDataGroup,false);
   setFieldNoValidate(ifds::Platform, PLATFORM::DESKTOP, idDataGroup, false, false, true);
   setFieldReadOnly(ifds::Platform, idDataGroup, true);
   DString dstrPSDAdvice;
   getWorkSession ().getOption (ifds::PSDAdvice, dstrPSDAdvice, idDataGroup );
   if(  NO == dstrPSDAdvice.stripAll())
   {
	addBlankToSubSet( ifds::SourceOfTrade,  idDataGroup );
    addBlankToSubSet( ifds::ChannelOfTrade, idDataGroup );
   }
   populateFieldsWithDefaultValues(idDataGroup, MODE_INIT);
   setFieldReadOnly(ifds::PSDAdvice,idDataGroup, true);
   DString dstrNetworkID;
   getField (ifds::NetworkID, dstrNetworkID, idDataGroup);
   if( !dstrNetworkID.empty())
    networkIDRelatedChanges (idDataGroup);
   
   /* The Checkbox should be unchecked first for the new trade */
   setFieldNoValidate( ifds::OverrideTax, I_("N"), idDataGroup, false, true, true);
   for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
   {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
   }
   setFieldNoValidate( ifds::SourceofFundsChecked, NULL_STRING, idDataGroup, false, true, false, false);

   setAccountNumbersFromSystemLevel( true, idDataGroup);

   if (isNew())
   {
      setFieldNoValidate( ifds::ExternalInstitution, NULL_STRING, idDataGroup, false, true, false, false);
   }

   DString strTrackTrActive;
   getWorkSession().getOption2(ifds::TrackTrActive,strTrackTrActive,BF::HOST,false);
   strTrackTrActive.strip().upperCase();

   bool bisFieldEnable = (strTrackTrActive == I_("Y"));

   setFieldReadOnly (ifds::ExternalInstitution, idDataGroup, !bisFieldEnable );

   setFieldNoValidate (ifds::Deconversion, I_(""), idDataGroup, false);
   setFieldReadOnly( ifds::Deconversion, idDataGroup, true );

	orderRoutingRelatedChanges (idDataGroup);
	
   setFieldNoValidate ( ifds::RDSPPaymtDate, NULL_STRING, idDataGroup, false, true, true, false);   
	
   setCashDateUpdatable (idDataGroup);
	
}

//******************************************************************************
inline bool Trade::isRebook()
{
//whether this trade is a rebook or not
   return _bRebook;
}

//******************************************************************************
inline bool Trade::isRefund()
{
//whether this trade is a rebook or not
   return _bRefund;
}
//******************************************************************************
DString Trade::getOrigTradeFee() const
{
   return _origTradeFee;
}


//******************************************************************************
inline bool Trade::isHypo ()
{
//by default a Trade is not hypothetical
   return false;
}

//******************************************************************************
SEVERITY Trade::doPreSetField ( const BFFieldId &idField, 
                                DString &value, 
                                const BFDataGroupId &idDataGroup, 
                                bool bFormatted)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("doPreSetField"));
   if ( idField == ifds::FromClass ||
        idField == ifds::FromFund ||
        idField == ifds::ToClass ||
        idField == ifds::ToFund)
   {
      value.strip().upperCase ();
   }
   else if (idField == ifds::EffectiveDate || idField == ifds::OrderType)
   {
		DString oldValue;

      getField (idField, oldValue, idDataGroup, false);
      if (oldValue != value)
      {
		   setFieldNoValidate (ifds::SettleDateOverriden, I_("N"), idDataGroup, false);
         setFieldNoValidate (ifds::ValueDateOverriden, I_("N"), idDataGroup, false);
      }
   }
   else if (idField == ifds::SettleDate)
   {
      setFieldNoValidate (ifds::ValueDateOverriden, I_("N"), idDataGroup, false);
   }
   return GETCURRENTHIGHESTSEVERITY ();
};

//******************************************************************************
SEVERITY Trade::setField ( const BFFieldId &idField, 
                           const DString &dstrValue,
                           const BFDataGroupId &idDataGroup, 
                           bool bFormatted, 
                           bool bSideEffect, 
                           bool bCheckCurrentValue)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setField"));

   DString value (dstrValue);
   bool bSetField = true;
//if acount from/to num comes as 0, then its value should be reset to null_string
//so the validation fails, and the field set as required
   if ((idField == ifds::AccountTo || idField == ifds::AccountNum) && 
         value.strip() == I_("0"))
   {
      value = NULL_STRING;
   }
   else if ( idField == ifds::Fee ||
             idField == ifds::FeeTo ||
             idField == ifds::FlatPercent ||
             idField == ifds::ADLFeeCharge ||
             idField == ifds::ChargeERSTTRFee ||
             idField == ifds::ChargeWDFee ||
             idField == ifds::ExchOutFee ||
             idField == ifds::ExchOutFlatPrcnt ||
             idField == ifds::ExchInFee ||
             idField == ifds::ExchInFlatPercent ||
             idField == ifds::FeeCurrency ||
             idField == ifds::DSCOverrideCode ||
             idField == ifds::DSCOverrideAmt)
   {
      bSetField = false;
//fee fields should not be set thru here, since Rel 59, SSBG, but
//thru method 'copyFeeValuesForCycleProcessing', which is called by the process in 'doPostOk'
      assert (0);
   }
   if (bSetField)
   {
      if (idField == ifds::Amount && bFormatted)
         getFormattedAmount (idDataGroup, value);

         BFCBO::setField ( idField, 
                           value, 
                           idDataGroup,
               bFormatted && !((idField == ifds::AccountTo || idField == ifds::AccountNum) && value.empty()), 
                           bSideEffect, 
                           bCheckCurrentValue);
   }
   if (idField == ifds::FundIDValue)
   {
      //FundIDType have to be set before fundIDValue
      DString fundCode, fundIDType;
      getField (ifds::FundIDType, fundIDType, idDataGroup);
      getField (ifds::FromFund, fundCode, idDataGroup);
      if( fundCode == NULL_STRING )
      {
         if (fundIDType == I_("WKN"))
         {
            BFCBO::setField (ifds::FundWKN, dstrValue, idDataGroup, bFormatted, bSideEffect);
         }
         if (fundIDType == I_("LFC"))
         {
            BFCBO::setField (ifds::FundLFC, dstrValue, idDataGroup, bFormatted, bSideEffect);
         }
		 if (fundIDType == I_("CUSIP"))
		 {
			 BFCBO::setField (ifds::CUSIP, dstrValue, idDataGroup, bFormatted, bSideEffect);
		 }
         if (fundIDType == I_("ISIN"))
         {
            BFCBO::setField (ifds::FundISIN, dstrValue, idDataGroup, bFormatted, bSideEffect);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
void Trade::getField ( const BFFieldId &idField, 
                       DString &fieldValue, 
                       const BFDataGroupId &idDataGroup, 
                       bool formattedReturn) const
{
   if (idField == ifds::Amount && formattedReturn)
   {
      BFCBO::getField (idField, fieldValue, idDataGroup, false);
      getFormattedAmount (idDataGroup, fieldValue);
   }
   else if ( idField == ifds::FromFund || 
             idField == ifds::FromClass || 
             idField == ifds::ToFund || 
             idField == ifds::ToClass)
   {
      BFCBO::getField (idField, fieldValue, idDataGroup, false);
      fieldValue.strip ().upperCase ();
   }
   else
   {
      BFCBO::getField (idField, fieldValue, idDataGroup, formattedReturn);
   }
}

//******************************************************************************
SEVERITY Trade::doValidateField ( const BFFieldId &idField, 
                                  const DString &strValue, 
                                  const BFDataGroupId &idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("doValidateField"));
   if ( idField == ifds::AccountNum ||
        idField == ifds::AccountTo)
   {
      const_cast <DString&>(strValue).stripLeading ('0').strip();
      if (!strValue.empty())
      {
         if (validateAccountNum (strValue, idDataGroup) <= WARNING)
         {
            //validateDefaultSettleInstr(strValue,idDataGroup);
            
            MFAccount *pMFAccount = NULL;

            if ( getWorkSession ().getMFAccount ( idDataGroup, 
                                                  strValue, 
                                                  pMFAccount) <= WARNING && 
                 pMFAccount)
            {
               if (idField == ifds::AccountNum)
               {
                  if (canAccountTrade (pMFAccount, idDataGroup) <= WARNING)
                  {
                     validateAccount (pMFAccount, idDataGroup);
                  }
               }
               else if (idField == ifds::AccountTo)
               {
                  if (canAccountToTrade (pMFAccount, idDataGroup) <= WARNING)
                  {
                     validateAccountTo (pMFAccount, idDataGroup);
                  }
               }
            }
         }
      }
   }
   if ( idField == ifds::FromFund ||
        idField == ifds::ToFund)
   {
      if (isOneSideTrade (idDataGroup) && idField == ifds::FromFund)
      {
         //incident 341078
         //the logic in fundclassrelatedchanges isn't triggered,
         //when user clear fund directly.
         clearROAAmount (idDataGroup);
         setFieldRequired ( idField, 
                            idDataGroup, 
                            !hasAllocations (idDataGroup) && 
                            !hasFromAllocations (idDataGroup) &&
                            !canCloseAccount (idDataGroup));

      }
      if (!isOneSideTrade (idDataGroup) && idField == ifds::ToFund)
      {
         //incident 341078
         //the logic in fundclassrelatedchanges isn't triggered,
         //when user clear fund directly.
         clearROAAmount (idDataGroup);
         updateGuaranteeFeeOverride (idDataGroup);
         setFieldRequired (idField, idDataGroup, !hasAllocations (idDataGroup));        
      }
      if (strValue == I_("CASH"))
      {
         ADDCONDITIONFROMFILE (CND::ERR_INVALID_FUND_CLASS_CODES)
      }
      else 
      {
         FundMasterList *pFundMasterList;

         if (!strValue.empty())
         {
            if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
                 pFundMasterList)
            {
               if (!pFundMasterList->IsFundExist (strValue, idDataGroup))
               {
                  ADDCONDITIONFROMFILE (CND::ERR_INVALID_FUND_CLASS_CODES);
               }
               else
               {
                  if (idField == ifds::FromFund)
                  {
                     validateFundCode (strValue, idDataGroup);
                  }
                  else if (idField == ifds::ToFund)
                  {
                     validateToFundCode (strValue, idDataGroup);
                  }
               }
            }
         }
      }
   }
   else if (idField == ifds::FromClass)
   {
      if (isOneSideTrade (idDataGroup))
      {
         setFieldRequired ( idField, 
                            idDataGroup, 
                            !hasAllocations (idDataGroup) && 
                            !hasFromAllocations (idDataGroup) &&
                            !canCloseAccount (idDataGroup));
      }
      if (!strValue.empty())
      {
         DString fundCode;

         getField (ifds::FromFund, fundCode, idDataGroup);
         validateClassCode (fundCode, strValue, idDataGroup);
        
      }
   }
   else if (idField == ifds::ToClass)
   {
      if (!isOneSideTrade (idDataGroup))
      {
         setFieldRequired (idField, idDataGroup, !hasAllocations (idDataGroup));
      }
      if (!strValue.empty())
      {
         DString fundCode;

         getField (ifds::ToFund, fundCode, idDataGroup);
         validateClassCode (fundCode, strValue, idDataGroup);
         validateFundForERISAAccount(fundCode, strValue, idDataGroup);
      }
   }
   if (idField == ifds::FromFundClass)
   {
      validateFundClass (idDataGroup);
	  checkLiqRedFeeExist(idDataGroup);
   }
   else if (idField == ifds::ToFundClass)
   {
      validateToFundClass (idDataGroup);
	  checkLiqRedFeeExist(idDataGroup,false);
	   setCashDateUpdatable(idDataGroup);
   }
   else if ( idField == ifds::FromFundNumber || 
             idField == ifds::ToFundNumber)
   {
      if (!strValue.empty())
      {
         DString fundCode, 
            classCode;

         if (!getWorkSession ().GetFundClassCode (strValue, fundCode, classCode))
         {
            ADDCONDITIONFROMFILE (CND::WARN_INVALID_FUND_NUMBER);
         }
      }
   }
   else if ( idField == ifds::FundISIN || 
             idField == ifds::FundToISIN)
   {
      if (!strValue.empty())
      {
         DString fundCode, 
            classCode;

         if (!getWorkSession ().GetFundClassCodeByISIN (strValue, fundCode, classCode))
         {
            if (bfutil::isServerContext())
            {
               ADDCONDITIONFROMFILE (CND::ERR_INVALID_ISIN_NUMBER);
            }
            else
            {
               ADDCONDITIONFROMFILE (CND::WARN_INVALID_ISIN_NUMBER);
            }
         }
      }
   }
   else if ( idField == ifds::FundWKN || 
             idField == ifds::FundToWKN)
   {
      if (!strValue.empty())
      {
         DString fundCode, 
            classCode;

         if (!getWorkSession ().GetFundClassCodeByWKN (strValue, fundCode, classCode))
         {
            if (bfutil::isServerContext())
            {
               ADDCONDITIONFROMFILE (CND::ERR_INVALID_WKN_NUMBER);
            }
            else
            {
               ADDCONDITIONFROMFILE (CND::WARN_INVALID_WKN_NUMBER);
            }
         }
      }
   }
   else if ( idField == ifds::FundLFC || 
             idField == ifds::FundToLFC)
   {
      if (!strValue.empty())
      {
         DString fundCode, 
            classCode;

         if (!getWorkSession ().GetFundClassCodeByLFC (strValue, fundCode, classCode))
         {
            if (bfutil::isServerContext())
            {
               ADDCONDITIONFROMFILE (CND::ERR_INVALID_LFC_NUMBER);
            }
            else
            {
               ADDCONDITIONFROMFILE (CND::WARN_INVALID_LFC_NUMBER);
            }
         }
      }
   }
   else if ( idField == ifds::CUSIP || 
             idField == ifds::ToCUSIP)
   {
      if (!strValue.empty())
      {
         DString fundCode, 
            classCode;

         if (!getWorkSession ().GetFundClassCodeByCUSIP (strValue, fundCode, classCode))
         {
            if (bfutil::isServerContext())
            {
               ADDCONDITIONFROMFILE (CND::ERR_INVALID_CUSIP_NUMBER);
            }
            else
            {
               ADDCONDITIONFROMFILE (CND::WARN_INVALID_CUSIP_NUMBER);
            }
         }
      }
   }
   else if (idField == ifds::FromToFundClass)
   {
      validateFromToFundClass (idDataGroup);
   }
   else if (idField == ifds::SettleCurrency)
   {
      validateCurrency (strValue, idDataGroup);
   }
   else if (idField == ifds::Broker)
   {      
      if (checkIfBrokerEffective (idDataGroup) <= WARNING)
      {
         validatePayTypeBroker (idDataGroup);
      }

	  DString accBroker, dstrBroker;
	  getAccountField(ifds::BrokerCode, accBroker, idDataGroup);
	  getField(ifds::Broker, dstrBroker, idDataGroup);
	  if(accBroker != dstrBroker)
	  {
		  getErrMsg(IFASTERR::BROKER_DIFFERENT_THAN_ACCOUNT_BROKER,
				 CND::ERR_BROKER_DIFFERENT_THAN_ACCOUNT_BROKER,
				 CND::WARN_BROKER_DIFFERENT_THAN_ACCOUNT_BROKER,
				 idDataGroup );
	  }
   }
   else if (idField == ifds::Branch)
   {
       checkIfBranchEffective (idDataGroup);

       DString accBranchCode, dstrBranch;
       getAccountField(ifds::BranchCode, accBranchCode, idDataGroup);
       getField(ifds::Branch, dstrBranch, idDataGroup);

       if(accBranchCode != dstrBranch)
       {
           getErrMsg(IFASTERR::BROKER_DIFFERENT_THAN_ACCOUNT_BROKER,
                     CND::ERR_BRANCH_DIFFERENT_THAN_ACCOUNT_BRANCH,
                     CND::WARN_BRANCH_DIFFERENT_THAN_ACCOUNT_BRANCH,
                     idDataGroup );
       }
   }
   else if (idField == ifds::SlsrepCode)
   {
      //P0186486FN09 - Employee and Agent Account Gap#8A
      //Employee/Agent account is not allowed to change reps
      if(isFieldUpdated (ifds::SlsrepCode, idDataGroup))
      {
         validateSlsRepIA(idDataGroup);
      }

      if (strValue.size() >= 6)
      {
         getErrMsg ( IFASTERR::SALESREPCODE_SHOULD_ONLY_BE_5_CHARACTERS, 
                     CND::ERR_SALS_CODE_HAS_TO_BE_5, 
                     CND::WAR_SALS_CODE_HAS_TO_BE_5, 
                     idDataGroup); 
      }
      if (GETCURRENTHIGHESTSEVERITY() <= WARNING && strValue.size() > 6)
      {
         ADDCONDITIONFROMFILE (CND::ERR_SALES_CODE_CAN_NOT_LONGER_THAN_6);
      }

      if (GETCURRENTHIGHESTSEVERITY() <= WARNING)
      {      
          checkIfAgentEffective (idDataGroup);

          DString accSlsRep, dstrSlsRepCode;
          getAccountField(ifds::Slsrep, accSlsRep, idDataGroup);
          getField(ifds::SlsrepCode, dstrSlsRepCode, idDataGroup);

          if (accSlsRep != dstrSlsRepCode)
          {
              getErrMsg(IFASTERR::BROKER_DIFFERENT_THAN_ACCOUNT_BROKER,
                        CND::ERR_SLSREP_DIFFERENT_THAN_ACCOUNT_SLSREP,
                        CND::WARN_SLSREP_DIFFERENT_THAN_ACCOUNT_SLSREP,
                        idDataGroup);
          }
      }
   }
   else if (idField == ifds::GrossOrNet)
   {
      validateGrossOrNet (strValue, idDataGroup);
   }
   else if (idField == ifds::OrderType)
   {
      validateOrderType (strValue, idDataGroup);
   }
   else if (idField == ifds::WireOrdNum)
   {
      validateWireOrderNum (strValue, idDataGroup);
   }
   if (idField == ifds::WireOrdFndCls)
   {
      wireOrderAllowed (idDataGroup);
   }
   else if (idField == ifds::OrderSource)
   {
      validateOrderSource (strValue, idDataGroup);
   }
   if (idField == ifds::OrderSourceOrderType)
   {
      validateOrderSourceOrderType (idDataGroup);
   }
   else if (idField == ifds::NetOrdType)
   {
      validateNetOrdType (idDataGroup);
   }
   else if (idField == ifds::AddrCode)
   {
      validateAddressCode (strValue, idDataGroup);
   }
   else if (idField == ifds::PayTypeBankNum) //cross edit for paytype and bank
   {
      validatePayTypeBank (idDataGroup);
   }   
   else if (idField == ifds::TradesPayType)
   {
      validatePayType (strValue, idDataGroup);
   }
   else if (idField == ifds::DepositType)
   {
      validateDepositType (strValue, idDataGroup);
   }
   else if (idField == ifds::RedCode)
   {
      validateRedCode (strValue, idDataGroup);
   }
   else if (idField == ifds::FundCodeRedCodeAmount)
   {
      validateFundCodeRedCodeAmount (idDataGroup);
   }
   else if (idField == ifds::ExchRate)
   {
      validateExchRate (strValue, idDataGroup);
   }
//dates and time validation
   else if (idField == ifds::EffectiveDate)
   {
	   validatePendingTradeAllocated(idDataGroup);//INC0039323
      if( validateDate ( DATE_VALIDATION::TRADE_DATE, 
                     idField, 
                     strValue, 
                     idDataGroup))
	  {
		  validateTradeDate (strValue, idDataGroup);
        if( WARNING >= GETCURRENTHIGHESTSEVERITY() )
        {
           //do only the to side regulatory validation once the from side is error free.
           if( WARNING >= doSIFRegulationSpecificValidations(idDataGroup , FROM_TO::FROM ) && !isOneSideTrade(idDataGroup) ) 
               doSIFRegulationSpecificValidations(idDataGroup , FROM_TO::TO );
        }
       
	  }
   }
   else if (idField == ifds::TradeInDate)
   {
	   validateTradeInDate (strValue, idDataGroup);
   }
   else if (idField == ifds::SettleDate)
   {
      DString tradeDate;

      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      if (DSTCommonFunctions::
            CompareDates (strValue, tradeDate) == DSTCommonFunctions::FIRST_EARLIER)
      {
         ADDCONDITIONFROMFILE (CND::ERR_SETTLEDATE_EARLIER_THAN_TRADEDATE);
      }
      else if (DSTCommonFunctions::
         CompareDates (strValue, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER)
      {
         ADDCONDITIONFROMFILE (CND::ERR_SETTLEDATE_EARLIER_THAN_NEXT_CYCLEDATE);
      }
      else 
      {
         DString dstrSettleNetwork;

         getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup, false);
         if(dstrSettleNetwork == I_("FSRV"))
         {
            validateDate ( DATE_VALIDATION::INPUT_SETTLE_DATE, 
                           ifds::SettleDate, 
                           strValue, 
                           idDataGroup);
         }
         else
         {
           DString dstrSettleDateOverriden;
     
           getField (ifds::SettleDateOverriden, dstrSettleDateOverriden, idDataGroup, false);
     // validate if settlement date is equal to the settlement date based on the trade date and order type
           if (dstrSettleDateOverriden.strip().upperCase() == Y)
           {
              validateDate ( DATE_VALIDATION::INPUT_SETTLE_DATE, 
                             ifds::SettleDate, 
                             strValue, 
                             idDataGroup);
           }
           else
           {  // validate if the settlement date is a valid settlement date
              validateDate ( DATE_VALIDATION::SETTLE_DATE, 
                             ifds::SettleDate, 
                             strValue, 
                             idDataGroup);
           }
        }
     }
   }
   else if (idField == ifds::DepositDate)
   {
      if (validateDate ( DATE_VALIDATION::BUSINESS_DATE, 
                         ifds::DepositDate, 
                         strValue, 
                         idDataGroup) <= WARNING)
      {
         validateDepositDate (strValue, idDataGroup);
      }
   }
   else if (idField == ifds::CashDate)
   {
      validateCashDate (strValue, idDataGroup);
   }
   else if (idField == ifds::ValueDate)
   {
      validateValueDate (strValue, idDataGroup);
   }
   else if (idField == ifds::DealDate)
   {
      validateDealDate (strValue, idDataGroup);
   }
   else if (idField == ifds::SettleInDate)
   {
      if (!strValue.empty ())
         validateSettleInDate (strValue, idDataGroup);
   }
   else if (idField == ifds::DealTime)
   {
      validateDealTime (strValue, idDataGroup);
   }
   else if (idField == ifds::CertRequired)
   {
      validateCertRequired (strValue, idDataGroup);
   }
   else if (idField == ifds::SettleSource)
   {
      validateSettleSource (strValue, idDataGroup);
   }
   else if (idField == ifds::SettleType)
   {
      validateSettleType (strValue, idDataGroup);
   }
   else if (idField == ifds::AcctableTradeDate)
   {
      validateAcctableTradeDate (idDataGroup);
   }
   else if (idField == ifds::AmtType)
   {
      validateAmtType (strValue, idDataGroup);	
   }
   else if (idField == ifds::FundAmtType)
   {
      DString amtType;
      getField (ifds::AmtType, amtType, idDataGroup, false);
      if( amtType == I_("D") && (isPurchase(idDataGroup) || isRedemption(idDataGroup)) )
      {
         ValidateFundAmtType(idDataGroup);
	  }
   }
   else if (idField == ifds::AmtTypeGrossNet)
   {
      validateAmtTypeGrossNet (idDataGroup);
   }
   else if (idField == ifds::AmountAmtType)
   {
      validateAmountAmtType (idDataGroup); 
   }
   else if (idField == ifds::Amount)
   {
      validateAmount (strValue, idDataGroup); 
   }
   else if (idField == ifds::MinToFundAmount)
   {
      validateMinToFundAmount (idDataGroup);
   }
   else if (idField == ifds::MinFromFundAmount)
   {
      validateMinFromFundAmount (idDataGroup);
   }
   else if (idField == ifds::ToSoftCapCheck)
   {
      validateToSoftCapCheck (idDataGroup);
   }
   else if (idField == ifds::FromSoftCapCheck)
   {
      validateFromSoftCapCheck (idDataGroup);
   }
   else if (idField == ifds::DuplicateTrade)
   {
      WorksessionTradesList *pWorksessionTradesList = NULL;

      if ( getWorkSession().getTradesList ( pWorksessionTradesList, 
                                            idDataGroup) <= WARNING &&
           pWorksessionTradesList)
      {
         pWorksessionTradesList->checkDuplicate (this, idDataGroup);
      }
   }
   else if (idField == ifds::FrClearingMethod)
   {
      MFAccount *pMFAccount = NULL;
      DString accountNum;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      if ( getWorkSession().getMFAccount ( idDataGroup, 
                                           accountNum, 
                                           pMFAccount) <= WARNING && 
           pMFAccount)
      {
         validateClearingMethod (strValue, pMFAccount, idDataGroup);
         DString dstrTradesPayType;
         getField(ifds::TradesPayType,dstrTradesPayType,idDataGroup);
         //if Trades Pay Type is not used, or the type is 'Clearing',
         //then validate the settl instruction.
         if(dstrTradesPayType.empty() || dstrTradesPayType == I_("R")) 
         {
            DString accountNum;
            getField (ifds::AccountNum,accountNum,idDataGroup);            
            if( !accountNum.empty() )
            {
               validateDefaultSettleInstr(accountNum, idDataGroup);
            }
         }
      }
   }
   else if (idField == ifds::ToClearingMethod)
   {
      MFAccount *pMFAccount = NULL;
      DString accountNum;

      getField (ifds::AccountTo, accountNum, idDataGroup, false);
      if ( getWorkSession().getMFAccount ( idDataGroup, 
                                           accountNum, 
                                           pMFAccount) <= WARNING && 
           pMFAccount)
      {
         validateClearingMethod (strValue, pMFAccount, idDataGroup, false);
         DString dstrTradesPayType;
         getField(ifds::TradesPayType,dstrTradesPayType,idDataGroup);
         //if Trades Pay Type is not used, or the type is 'Clearing',
         //then validate the settl instruction.
         if(dstrTradesPayType.empty() || dstrTradesPayType == I_("R")) 
         {
            DString accountTo;
            getField (ifds::AccountTo,accountTo,idDataGroup);
            if( !accountTo.empty() )
            {
               validateDefaultSettleInstr(accountTo, idDataGroup);
            }
         }
      }
   }
   else if (idField == ifds::ParticipantID)
   {
      validateParticipantID (strValue, idDataGroup);
   }
   else if (idField == ifds::SendRefNum)
   {
      validateSenderRefNum (strValue, idDataGroup);
   }
   else if (idField == ifds::OtherConfirmType)
   {
      validateOtherConfirmType (strValue, idDataGroup);
   }
   else if (idField == ifds::NetworkID)
   {
      validateNetworkID (strValue, idDataGroup);
   }
   else if (idField == ifds::FundCurrency)
   {
      validateAPIFundCurrency (strValue, idDataGroup);
   }
   else if (idField == ifds::ESGSettle)
   {
      validateESGSettle ( strValue, idDataGroup );
   }
   else if (idField == ifds::MCHFileIndicator)
   {
      DString fundCode;
      getField (ifds::FromFund, fundCode, idDataGroup, false);

      if (!fundCode.empty())
      {
         FundMasterList *pFundMasterList;

         if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
               pFundMasterList)
         {
            if (pFundMasterList->is3rdPartyFund (fundCode))
            {
               DString mchFileIndicator;
               getField (ifds::MCHFileIndicator, mchFileIndicator, idDataGroup, false);
               if (mchFileIndicator != I_("0")) // "exclude" 
               {
                  ADDCONDITIONFROMFILE (CND::ERR_ONLY_EXCLUDE_MCH_FOR_THIRDPARTYFUNDS);
               }
            }
         }
      }
   }
   else if (idField == ifds::PayInstrOption)
   {
      validatePayInstrOption( strValue, idDataGroup );
   }
   else if (idField == ifds::MFPayment)
   {
      if (strValue == NA)
      {
         getErrMsg ( IFASTERR::INVALID_MF_PAYMENT,
                     CND::ERR_INVALID_MF_PAYMENT, 
                     CND::WARN_INVALID_MF_PAYMENT, 
                     idDataGroup);
      }
   }
   else if( idField == ifds::DepTypeTradeDate )
   {
      DString dstrAccountNum, dstrTaxType, dstrEffectivedate, dstrDepositType;
      
      getField( ifds::EffectiveDate, dstrEffectivedate, idDataGroup, false );
      getField( ifds::DepositType, dstrDepositType, idDataGroup);
      if ( isResidencyRequired( dstrAccountNum, idDataGroup ) )
      {
         Residency* residency;
         if( getWorkSession().getResidency( residency, dstrAccountNum, dstrEffectivedate, dstrDepositType, idDataGroup ) <= WARNING && residency )
         {
            if (!residency->isTaxJurisdictionValid())
            {
                getErrMsg ( IFASTERR::NON_RESIDENT_TAX_JURISD_CONTR_NOT_ALLOWED,
                            CND::ERR_CONTRIBUTION_NOT_ALLOWED_FOR_NON_RESIDENT,
                            CND::WARN_CONTRIBUTION_NOT_ALLOWED_FOR_NON_RESIDENT,
                            idDataGroup,
                            NULL_STRING);
            }
         }
      }
   }
   else if (idField == ifds::BatchName)
   {
      if (_pBatchInfoList)
         _pBatchInfoList->validateBatch (strValue, idDataGroup);
   }
   else if (idField == ifds::TradePayTypeFundClass )
   {
      validateTradePayTypeFundClass( idDataGroup );
   }
   else if (idField == ifds::PayMethod)
   {
      validatePayMethod (idDataGroup);
   }
   else if (idField == ifds::LinkedEntityId)
   {
      validateLinkedEntity(strValue, idDataGroup);
   }
   else if (idField == ifds::AssocTransId)
   {
      if ( isAssociationToOriginalContribAllowed (idDataGroup) &&
           (strValue.empty() || strValue == I_("0")))
      {
		  DString redCode;
		  getField(ifds::RedCode, redCode, idDataGroup, false);

		  if (!DSTCommonFunctions::codeInList (redCode, I_("BP,GP,RB,RG"))) // BP-RDSP Bond Repayment, GP-RDSP Grant Repayment, RB-RDSP Bond Return, RG-RDSP Grant Return  
		  {
			  // display rejerror 240
			  getErrMsg ( IFASTERR::NO_ORIGINATING_CONTRIBUTION_SELECTED,
						  CND::ERR_NO_ORIGINATING_CONTRIBUTION_SELECTED,
						  CND::WARN_NO_ORIGINATING_CONTRIBUTION_SELECTED,
						  idDataGroup );
		  }
      }
   }
   else if (idField == ifds::AmountRedCode)
   {
      validateAmountRedCode(idDataGroup);
   }
   else if (idField == ifds::AmtTypeRedCode)
   {
      validateAmtTypeRedCode (idDataGroup);
   }
   else if (idField == ifds::CourseStart)
   {
      if (isPSEEAPAllowed (idDataGroup) && isTradeOnOrAfterPSEEAPEditDate (idDataGroup))
      {
         DString emptyDate;

         getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
         if  (strValue == emptyDate || strValue.empty())
         {
            ADDCONDITIONFROMFILE (CND::ERR_COURSE_START_DATE_MANDATORY);
         }
         else
         {
            int iCourseStartDay = DSTCommonFunctions::getDayFromUnFormattedDate(strValue);
            if(iCourseStartDay != 1)
            {
               ADDCONDITIONFROMFILE( CND::ERR_ACADEMIC_DAY_MUST_BE_01);
            }
         }
      }
   }
   else if (idField == ifds::EduInstPstl)
   {
      if(isPSEEAPAllowed (idDataGroup) && isTradeOnOrAfterPSEEAPEditDate (idDataGroup) && strValue.empty())
      {
         ADDCONDITIONFROMFILE (CND::ERR_EDUCATION_INST_POST_CODE_AND_COUNTRY_NAME_REQUIRED);	 
      }
   }
   else if (idField == ifds::CourseLen)
   {
      if(isPSEEAPAllowed (idDataGroup) && isTradeOnOrAfterPSEEAPEditDate (idDataGroup))
      {
         if(strValue.empty() || strValue == I_("0"))
         {      
            ADDCONDITIONFROMFILE (CND::ERR_ACADEMIC_YEAR_LENGTH_REQUIRED);               
         }
         else
         {
            double dec_courselen = DSTCommonFunctions::convertToDouble (strValue);

            if  (dec_courselen < 1 || dec_courselen > 52)
            {
               ADDCONDITIONFROMFILE (CND::ERR_COURSE_LEN_BETWEEN_1_AND_52_WEEKS);
            }
         }
      }
   }
   else if (idField == ifds::RESPContrDetlTaxYear)
   {
      validateRESPContrDetlTaxYear(strValue,idDataGroup);
   }
   else if(idField == ifds::PSEProgramLen  ||
           idField == ifds::PSEProgramType ||
           idField == ifds::PSEProgramYear)
   {
      if(isPSEEAPAllowed (idDataGroup) && isTradeOnOrAfterPSEEAPEditDate (idDataGroup))
      {
         if(strValue.empty())
         {
            if(idField == ifds::PSEProgramLen)
            {
               ADDCONDITIONFROMFILE(CND::ERR_PSE_LEN_INVALID);
            }
            else if(idField == ifds::PSEProgramType)
            {
               ADDCONDITIONFROMFILE(CND::ERR_PSE_TYPE_INVALID);
            }
            else if(idField == ifds::PSEProgramYear)
            {
               ADDCONDITIONFROMFILE(CND::ERR_PSE_YEAR_INVALID);
            }
         }
      }
   }
   else if (idField == ifds::AssistedContrAmt)
   {
      DString depositType, redCode;
      getField(ifds::DepositType, depositType, idDataGroup, false);
      getField(ifds::RedCode, redCode, idDataGroup, false);
      depositType.strip();
      redCode.strip();
      
      if(DSTCommonFunctions::codeInList (depositType, I_("78,79")) ||
         redCode == I_("Q1"))
      {
         DString dstrAssistedContrAmt;
         getField(ifds::AssistedContrAmt, dstrAssistedContrAmt, idDataGroup, false);
         double dec_assistedamount = DSTCommonFunctions::convertToDouble (dstrAssistedContrAmt);

         if(dec_assistedamount == 0)
            ADDCONDITIONFROMFILE (CND::WARN_ASSISTED_AMT_IS_ZERO);
      }
   }
   else if (idField == ifds::ForcedRateAmt)
   {
      DString dstrPercentage(strValue);
      dstrPercentage.strip();

      BigDecimal bdPercent = DSTCommonFunctions::convertToBigDecimal(dstrPercentage);
      BigDecimal bdHundred = DSTCommonFunctions::convertToBigDecimal(I_("100.0"));
      BigDecimal bdZero    = DSTCommonFunctions::convertToBigDecimal(I_("0.0"));
      BigDecimal bdFifteen = DSTCommonFunctions::convertToBigDecimal(I_("15.0"));

      if (bdPercent > bdHundred || bdPercent < bdZero)
      {
         ADDCONDITIONFROMFILE (CND::ERR_VALUE_BETWEEN_0_AND_100);
      }

      if (bdPercent > bdFifteen)
      {
         ADDCONDITIONFROMFILE (CND::WARN_INTEREST_EXCEEDS_FIFTEEN);
      }
   }
   else if (idField == ifds::AmtOrdType)
   {
      DString dstrFundCode;
      getField (ifds::FromFund, dstrFundCode, idDataGroup, false);
      if( isMoneyMarketFund(dstrFundCode) )
      {
         validateMoneyMktFund(idDataGroup);
      }
   }
   else if (idField == ifds::FromSegTradeEntryCheck)
   {
      if (isOneSideTrade (idDataGroup))
      {
         DString accountNum,
            fundCode,
            classCode,
            tradeDate,
            transType,
            transId;

         getField (ifds::AccountNum, accountNum, idDataGroup, false);
         getFundField (ifds::FundCode, fundCode, idDataGroup);
         getFundField (ifds::ClassCode, classCode, idDataGroup);
         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         getField (ifds::TradesTransType, transType, idDataGroup, false);
         getField (ifds::TransId, transId, idDataGroup,false);

         validateFromSegTradeEntryCheck(accountNum,
                                        fundCode,
                                        classCode,
                                        tradeDate,
                                        transType,
                                        transId,
                                        idDataGroup);         
      }
   }
   else if (idField == ifds::FromToSegTradeEntryCheck)
   {
      if (!isOneSideTrade (idDataGroup))
      {
         DString accountNum,
            accountTo,
            fundCode,
            fundToCode,
            classCode,
            classToCode,
            tradeDate,
            transType,
            transId;

         getField (ifds::AccountNum, accountNum, idDataGroup, false);
         getField (ifds::AccountTo, accountTo, idDataGroup, false);
         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         getField (ifds::TradesTransType, transType, idDataGroup, false);
         getField (ifds::TransId, transId, idDataGroup,false);

         getFundField (ifds::FundCode, fundCode, idDataGroup);
         getFundField (ifds::ClassCode, classCode, idDataGroup);
         getField (ifds::ToFund, fundToCode, idDataGroup, false);
         getField (ifds::ToClass, classToCode, idDataGroup, false);

         validateFromToSegTradeEntryCheck(accountNum,
                                          fundCode,
                                          classCode,
                                          accountTo,
                                          fundToCode,
                                          classToCode,
                                          tradeDate,
                                          transType,
                                          transId,
                                          idDataGroup);
      }
   }

   else if(idField == ifds::SrcOfAccount) 
   {//P0186486_FN15_The Source of Funds
       ValidateSourceOfAcct(idDataGroup);
   }

   else if (idField == ifds::FundBrokerCode)
   {
      //For Routing Client, the fund broker code is allowed empty if the fund is not 3rd party
      bool bIs3rdPartyFund = false;
      DString fundCode;
      getField (ifds::FromFund, fundCode, idDataGroup, false);
      FundMasterList *pFundMasterList = NULL;
      if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
         pFundMasterList)
         bIs3rdPartyFund = pFundMasterList->is3rdPartyFund (fundCode);

      DString dstrFundBrokerCode,dstrFdBrokerApplicable;
      getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                dstrFdBrokerApplicable,
                                BF::HOST,
                                false);
      getField(ifds::FundBrokerCode,dstrFundBrokerCode,idDataGroup,false);
      if(dstrFundBrokerCode.empty() &&
         accountHasCategory(ACCTCAT_ROUTINGCLIENT,idDataGroup)&& dstrFdBrokerApplicable == I_("Y") &&
         bIs3rdPartyFund )
      {
         getErrMsg ( IFASTERR::DEFAULT_FUND_BRKR_REQUIRED_FOR_TRADE,
                       CND::ERR_DEFAULT_FUND_BRKR_REQUIRED_FOR_TRADE, 
                       CND::WARN_DEFAULT_FUND_BRKR_REQUIRED_FOR_TRADE, 
                       idDataGroup
                       );
      }
   }
   else if(idField == ifds::RDRAdvice) 
   {
      DString dstrRDRAdvice;
      getField (ifds::RDRAdvice, dstrRDRAdvice, idDataGroup, false);
      if( dstrRDRAdvice != _strRDRAdviceFlag )
      {
         ADDCONDITIONFROMFILE (CND::WARN_RDR_ADVICE_UPDATED);
      }
   }
   else if( idField == ifds::EventReceiptDate || idField == ifds::EventReceiptTime )
   {
      DString dstrEventReceiptDate,dstrEventReceiptTime,dstrTemp;
      bool bEventReceiptDateTimeAppl = bIsEventReceiptDateTimeAppl(idDataGroup); 
      getField(ifds::EventReceiptDate, dstrEventReceiptDate, idDataGroup, false);
      getField(ifds::EventReceiptTime, dstrEventReceiptTime, idDataGroup, false);
      dstrEventReceiptDate.stripAll();
      dstrEventReceiptTime.stripAll();
      //invalidate the field so that crossedit will be called  after fields validation
      setFieldValid(ifds::EventReceiptDate, idDataGroup, false);
      setFieldValid(ifds::EventReceiptTime, idDataGroup, false );
      if ( !dstrEventReceiptDate.empty() && bEventReceiptDateTimeAppl )
      { 
         // Event reciept date cannot future dated 
         DString dstrCurrentSysDate;
         getWorkSession().getDateInHostFormat(dstrCurrentSysDate, DSTCWorkSession::DATE_TYPE::CURRENT_SYSTEM_DAY, BF::HOST);  
         if (DSTCommonFunctions::CompareDates (dstrCurrentSysDate, dstrEventReceiptDate) == DSTCommonFunctions::FIRST_EARLIER)
         {
            addIDITagValue( dstrTemp, I_("FieldName"), I_("Event Receipt Date"));
            ADDCONDITIONFROMFILEIDI( CND::ERR_FUTURE_DATE, dstrTemp );
         }
      }
      if ( !dstrEventReceiptTime.empty() && bEventReceiptDateTimeAppl )
      {
         if(!DSTCommonFunctions::bValidateTime(dstrEventReceiptTime))
         {
            DString dstrTemp;
            addIDITagValue( dstrTemp, I_("FORMAT"), I_("HH:MM:SS"));
            ADDCONDITIONFROMFILEIDI(CND::ERR_INVALID_TIME_FORMAT,dstrTemp)
         }
      }
      if(GETCURRENTHIGHESTSEVERITY () <= WARNING )
      {
         setFieldValid(ifds::EventReceiptDate, idDataGroup, true);
         setFieldValid(ifds::EventReceiptTime, idDataGroup, true );
      }
   }
   else if (idField == ifds::XEditEventRecieptDateTime )
   {
      bool bEventReceiptDateTimeAppl = bIsEventReceiptDateTimeAppl(idDataGroup);
      if(bEventReceiptDateTimeAppl)
      {
         DString dstrEventReceiptDate,dstrEventReceiptTime,dstrTemp;
         getField(ifds::EventReceiptDate, dstrEventReceiptDate, idDataGroup, false);
         getField(ifds::EventReceiptTime, dstrEventReceiptTime, idDataGroup, false);
         if ( dstrEventReceiptDate.stripAll().empty())
         {
            addIDITagValue( dstrTemp, I_("FieldName"), I_("Event Receipt Date"));
            ADDCONDITIONFROMFILEIDI( CND::ERR_REQ_FIELD_EMPTY, dstrTemp );
         }
         else if ( dstrEventReceiptTime.stripAll().empty() )
         {
            addIDITagValue( dstrTemp, I_("FieldName"), I_("Event Receipt Time"));
            ADDCONDITIONFROMFILEIDI( CND::ERR_REQ_FIELD_EMPTY, dstrTemp );
         }
      }
   }
   else if (idField == ifds::SettleTypeNetworkSettleXEdit)
   {
      validateSettleTypeSettleNetworkXEdit(idDataGroup);
   }
   else if (idField == ifds::SettleSourceNetworkSettleXEdit)
   {
      validateSettleSourceSettleNetworkXEdit(idDataGroup);
   }
   else if (idField == ifds::DepTypeExternalInstitution || 
            idField == ifds::RedCodeExternalInstitution)
   {
      if (isExternalInstitutionTrackingEnable(idDataGroup))
      {
         DString strExternalInstitution;
         getField(ifds::ExternalInstitution, strExternalInstitution, idDataGroup, false);
         strExternalInstitution.strip().upperCase();

         if (strExternalInstitution.empty())
         {
             getErrMsg(IFASTERR::EXTINSTITUTION_NAME_NOT_PROVIDED,
                        CND::ERR_EXTINSTITUTION_NAME_NOT_PROVIDED,
                        CND::WARN_EXTINSTITUTION_NAME_NOT_PROVIDED,
                        idDataGroup );
         }
         else
         {
            ExternalInstitutionList* pExternalInstitutionList = nullptr;

            if ( getExternalInstitutionList(pExternalInstitutionList, idDataGroup) <= WARNING &&
                 pExternalInstitutionList != nullptr)
            {
               if ( !pExternalInstitutionList->doesCodeExist(strExternalInstitution,idDataGroup))
               {
                  CND::CIFast_IFast_ifastcbo_warn_Invalid_institution_code warnCond;
                  CND::CIFast_IFast_ifastcbo_err_Invalid_institution_code errCond;

                  MFCanBFCbo::getErrMsg (IFASTERR::INVALID_INSTITUTION_CODE, // 1782
                                         errCond,
                                         warnCond,
                                         idDataGroup);
               }
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::doApplyRelatedChanges ( const BFFieldId &idField, 
                                        const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("doApplyRelatedChanges"));

   if (idField == ifds::TradesTransType)
   {
      transTypeRelatedChanges (idDataGroup);
   }
   else if (idField == ifds::BatchName)
   {
      DString autoBatching;

      getWorkSession ().getOption (ifds::AutoBatch, autoBatching, idDataGroup, false);

      // there is already code in worksessiontradeslist that flips closed batch
      // used by trade to the newly active one if env does not support autobatching
      if (autoBatching.asInteger () == AUTO_BATCHING)
      {
         setFieldUpdated (ifds::BatchName, idDataGroup, true);
         setFieldValid (ifds::BatchName, idDataGroup, false);
      }
   }
   else if (idField == ifds::AccountNum)
   {
//initialize the broker/branch/sales rep
      DString accountNum;
      MFAccount *pMFAccount = NULL;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      accountNum.stripLeading ('0').strip();
      if ( getWorkSession().getMFAccount ( idDataGroup, 
                                           accountNum, 
                                           pMFAccount) <= WARNING && 
           pMFAccount)
      {
         DString brokerCode, 
            branchCode, 
            slsrepCode;

         pMFAccount->getField (ifds::BrokerCode, brokerCode, idDataGroup, false);
         setFieldNoValidate ( ifds::Broker, brokerCode, idDataGroup, false, 
                              false, 
                              true, //notify,
                              false); //no related changes
         if (brokerRelatedChanges (branchCode, idDataGroup) <= WARNING)
         {
            setFieldNoValidate ( ifds::Branch, branchCode, idDataGroup, false, 
                                 false, 
                                 true, //notify,
                                 false); //no related changes, do not want to trigger split comms, yet
         }
//changing the broker affects the value of 'ExpGNSettle'
         orderTypeBrokerRelatedChanges (idDataGroup);
         if (!isHouseBroker (idDataGroup))
         {
            pMFAccount->getField (ifds::BranchCode, branchCode, idDataGroup, false);
            setFieldNoValidate ( ifds::Branch, branchCode, idDataGroup, false, 
                                 false, 
                                 true, //notify,
                                 false); //no related changes
            pMFAccount->getField (ifds::Slsrep, slsrepCode, idDataGroup, false);
            setFieldNoValidate ( ifds::SlsrepCode, slsrepCode, idDataGroup, false, 
                                 false, 
                                 true, //notify,
                                 false); //no related changes
         }
//initialize the calculated 'Initial' field, it is displayed only for 
//purchase like transactions, in the attributes box
         DString transFound;
         
         pMFAccount->getField (ifds::TransFound, transFound, idDataGroup, false);
         setFieldNoValidate ( ifds::InitPurch, 
                              transFound == N ? Y : N,
                              idDataGroup, 
                              false, //not-formatted
                              true,  //valid
                              true);   //notify         
         setNetworkIDSendRefNum (idDataGroup, true);

// default for Country/Province
//GUI needs ProvSales, to show it to the user; Backend changed logic not to require anymore this field for view 115
//JTradesProcess assigned '0000' value to this field, so don't call view 69 in this case
//if we send '0000' ProvSales will be set to Prim-Mstr.ProvRes which is the same value as pShareholder ResProvCode
         DString resProvCode;

         getField (ifds::ProvSales, resProvCode, idDataGroup, false);
         if (resProvCode.strip () != I_ ("0000"))//wasn't set to 0000, go after it
         {
            Shareholder *pShareholder = NULL;
            DString shrNum;

            pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup);
            if ( getWorkSession ().getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING &&
                 pShareholder)
            {
               DString resProvCode;

               pShareholder->getField (ifds::ResProvCode, resProvCode, idDataGroup, false);
               setFieldNoValidate ( ifds::ProvSales, resProvCode, idDataGroup, false, 
                                    true, //valid
                                    true, //side effect
                                    false);
            }
         }
//ESGSettle
         esgSettleRelatedChange (idDataGroup);
         
         TradePayInstructList *pTradePayInstructList (NULL);

         DString accountNum;
         MFAccount *pMFAccount = NULL;

         getField (ifds::AccountNum, accountNum, idDataGroup, false);
         accountNum.stripLeading ('0').strip();

         if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING && pMFAccount)
         {
            if (!pMFAccount->isClearingAcount (idDataGroup))
            {
               getTradePayInstructList (pTradePayInstructList, idDataGroup, true, true);
               if (GETCURRENTHIGHESTSEVERITY() <= WARNING)
               {
                  DString payType;

                  getField (ifds::TradesPayType, payType, idDataGroup, false);
                  _bDefaultPayInstructPayTypeIsNotEFTOrSystemCheque = payType != PAYTYPE::EFT && payType != PAYTYPE::SYSTEM_CHEQUE;
               }
            }
         }
      } //valid account
      if (GETCURRENTHIGHESTSEVERITY() <= WARNING)
      {
//lock the trade transaction type
         setFieldReadOnly (ifds::TradesTransType, idDataGroup, true);
//set myself (ifds::AccountNum) as read only
         setFieldReadOnly (ifds::AccountNum, idDataGroup, true);
         setFieldValid (ifds::DuplicateTrade, idDataGroup, false); //duplicate trade check
         setFieldValid (ifds::RedCode, idDataGroup, false); //account is part of red code validation   
         setFieldValid (ifds::Amount, idDataGroup, false);
         setFieldValid (ifds::AmtType, idDataGroup, false);
      }

      if ( isPurchaseLike (idDataGroup) )
      {
         DString payType, amtType, frClearingMethod, fileProcessor;
         getTradeDefaults ( payType, 
                            amtType, 
                            frClearingMethod, //not set in here, see 'clearingRelatedChanges'
                            fileProcessor, 
                            idDataGroup);
         if (!payType.empty())
         {
            setFieldNoValidate (ifds::TradesPayType, payType, idDataGroup, false, true );
         }
      }

	  /* for AMS account Trade via parent fund/class, the allocation will not be populated */
	  if ( isPurchase(idDataGroup) || isRedemption(idDataGroup) )
	  {
		  DString dstrAccountNum;
		  MFAccount *pMFAccount = NULL;
		  getField(ifds::AccountNum, dstrAccountNum, idDataGroup, false);

		  if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && 
			  pMFAccount &&
			  pMFAccount->isAMSAccount (idDataGroup) )
		  { 
			  if ( isAMSTradeViaParentFundClass(idDataGroup) )
			  {
				  DString dstrAMSCode;
				  pMFAccount->getField(ifds::AMSCode, dstrAMSCode, idDataGroup, false);

				  AmsMstrInfo *pAmsMstrInfo = NULL;
				  if ( getAMSMstrInfo ( pAmsMstrInfo, dstrAMSCode, idDataGroup) <= WARNING &&
					  pAmsMstrInfo )
				  {
					  // Apply parent fund class
					  DString dstrParentFund, dstrParentClass;
					  pAmsMstrInfo->getField(ifds::AssocFund, dstrParentFund, idDataGroup, false);
					  pAmsMstrInfo->getField(ifds::AssocClass, dstrParentClass, idDataGroup, false);			

					  _bSetAmsParentFundClass = true;
					  setFieldNoValidate(ifds::FromFund, dstrParentFund, idDataGroup, false, true, true, true);
					  setFieldNoValidate(ifds::FromClass, dstrParentClass, idDataGroup, false, true, true, true);		   				  

				  }
			  }

		  }
	  }
	  /* P0269956 Australia product */
	  SupportedProductsList *pSupportedProductsList = NULL;	  
	  if (getMgmtCo ().
		    getSupportedProductsList (pSupportedProductsList) <= WARNING && 
		    pSupportedProductsList)
	  {
	     if (pSupportedProductsList->isSSBAUProductActive ())
	     {
			if (isRedemptionLike(idDataGroup)){
				AccountEntityXref *pAccountEntityXref = NULL;
				getField (ifds::AccountNum, accountNum, idDataGroup);
				accountNum.stripLeading('0').strip();
				if (!accountNum.empty())
				{
					AccountEntityXref *pAccountEntityXref = NULL;
					if ( getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
						 pAccountEntityXref)
					{
						ENTITIES_VECTOR clearingPlatformEntities;
						pAccountEntityXref->getClearingPlatformEntities ( clearingPlatformEntities, 
																		  accountNum, 
																		  idDataGroup);
						for (ENTITIES_VECTOR::size_type i = 0; i < clearingPlatformEntities.size(); ++i)
						{
						//get the entity ids list for every owner...
							DString entityId = clearingPlatformEntities [i];
							Entity *pEntity = NULL;
							if ( getWorkSession().getEntity ( idDataGroup, 
															  entityId, 
															  pEntity) <= WARNING &&
															  pEntity)
							{
								EntityIdsList *pEntityIdsList = NULL;

								if ( pEntity->getEntityIdsList (pEntityIdsList, idDataGroup) <= WARNING &&
									pEntityIdsList)
								{
									BFObjIter iter (*pEntityIdsList, idDataGroup);
									while(!iter.end())
									{
										DString idType;
										iter.getObject()->getField (ifds::IdType, idType, idDataGroup);
										if(idType == I_("18")) //Id type: Clearing Platform
										{
											DString idValue;
											iter.getObject()->getField (ifds::IdValue, idValue, idDataGroup);

											if (DSTCommonFunctions::codeInList (idValue, I_("NZC,AUC")))
											{
												setFieldNoValidate (ifds::TradesPayType, PAYTYPE::SUPPRESS, idDataGroup, false, false, true );
												setFieldValid (ifds::TradesPayType, idDataGroup, true);
												_bAlreadySetPayTypeDefaults = true;
												break;
	  }
   }
										++iter;
									}
								}
							}
						}
					}
				}
			}
			
	     }
	  }
   }
   else if ( idField == ifds::FromFund ||
             idField == ifds::FromClass)
   {
//set the 'from fund' number(s)
      DString fundCode,
         classCode,
         fundNumber,
         isinNumber,
         wknNumber,
         lfcNumber,
		 cusipNumber;

      getField (ifds::FromFund, fundCode, idDataGroup, false);
      getField (ifds::FromClass, classCode, idDataGroup, false);
      if ( !fundCode.empty() &&
           !classCode.empty())
      {
         getWorkSession ().GetFundNumber (fundCode, classCode, fundNumber);
         getWorkSession ().GetISINNumber (fundCode, classCode, isinNumber);
         getWorkSession ().GetWKNNumber (fundCode, classCode, wknNumber);
         getWorkSession ().GetLFCNumber (fundCode, classCode, lfcNumber);
		 getWorkSession ().GetCUSIPNumber (fundCode, classCode, cusipNumber);
         setFieldNoValidate ( ifds::FromFundNumber, fundNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         setFieldNoValidate ( ifds::FundISIN, isinNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         setFieldNoValidate ( ifds::FundWKN, wknNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         setFieldNoValidate ( ifds::FundLFC, lfcNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
		 setFieldNoValidate ( ifds::CUSIP, cusipNumber, idDataGroup, false,
							  true,
						      true,
						      false); //notify

                              
         // Multi Manager project.
         if ( isPurchaseLike (idDataGroup) )
         {
            DString payType, accountNum;
            
            getField(ifds::AccountNum, accountNum, idDataGroup, false);
            // Call view to default paytype at fund/class level.
            getDefaultFundClassPayType (accountNum, 
                                        payType,
                                        fundCode,
                                        classCode,
                                        idDataGroup);
            
            if (!payType.empty())
            {
               setFieldNoValidate (ifds::TradesPayType, payType, idDataGroup, false, true );
            }
         }
      }
      fromFundClassRelatedChanges (fundCode, classCode, idDataGroup);
      setFieldValid (ifds::MinFromFundAmount, idDataGroup, false); 
      setFieldValid (ifds::CertRequired, idDataGroup, false); 

      if (isRebook())
      {
         setDefaultMCHIndicator (ifds::MCHRbkTrade, idDataGroup);
      }
      else
      {
         setDefaultMCHIndicator (ifds::MCHNewTrade, idDataGroup);
	  }
	  PendTrdContractRelatedChanges (idDataGroup);
	  RDRAdviceRelatedChanges(idDataGroup);

	  orderRoutingRelatedChanges  (idDataGroup);
	  initPriceTypesList (idDataGroup);
	  refreshIntradayPricing(idDataGroup);
	  if(idField == ifds::FromFund)
	  {
		  hasWaiveGatingFund(idDataGroup);
	  }

   }
   else if ( idField == ifds::ToFund ||
             idField == ifds::ToClass)
   {
//set the 'to fund' number(s)
      DString fundCode,
         classCode,
         fundNumber,
         isinNumber,
         wknNumber,
         lfcNumber,
		 cusipNumber;

      getField (ifds::ToFund, fundCode, idDataGroup, false);
      getField (ifds::ToClass, classCode, idDataGroup, false);
      if ( !fundCode.empty() &&
           !classCode.empty())
      {
         getWorkSession ().GetFundNumber (fundCode, classCode, fundNumber);
         getWorkSession ().GetISINNumber (fundCode, classCode, isinNumber);
         getWorkSession ().GetWKNNumber (fundCode, classCode, wknNumber);
         getWorkSession ().GetLFCNumber (fundCode, classCode, lfcNumber);
		 getWorkSession ().GetCUSIPNumber (fundCode, classCode, cusipNumber);
         setFieldNoValidate ( ifds::ToFundNumber, fundNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         setFieldNoValidate ( ifds::FundToISIN, isinNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         setFieldNoValidate ( ifds::FundToWKN, wknNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         setFieldNoValidate ( ifds::FundToLFC, lfcNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
		 setFieldNoValidate ( ifds::ToCUSIP, cusipNumber, idDataGroup, false, 
                              true, 
                              true, //notify
                              false);
         toFundClassRelatedChanges (fundCode, classCode, idDataGroup);
      }
      setFieldValid (ifds::MinToFundAmount, idDataGroup, false);

      RDRAdviceRelatedChanges(idDataGroup);

	  orderRoutingRelatedChanges (idDataGroup);
	   refreshIntradayPricing(idDataGroup);
	  if(idField == ifds::ToFund)
	  {
		  hasWaiveGatingFund(idDataGroup);
   }
   }
   else if (idField == ifds::FromFundNumber)
   {
      DString fundNumber;

      getField (ifds::FromFundNumber, fundNumber, idDataGroup, false);
      if (!fundNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCode (fundNumber, fundCode, classCode))
         {
            setField (ifds::FromFund, fundCode, idDataGroup, false, true);
            setField (ifds::FromClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::ToFundNumber)
   {
      DString fundNumber;

      getField (ifds::ToFundNumber, fundNumber, idDataGroup, false);
      if (!fundNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCode (fundNumber, fundCode, classCode))
         {
            setField (ifds::ToFund, fundCode, idDataGroup, false, true);
            setField (ifds::ToClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::FundISIN)
   {
      DString isinNumber;

      getField (ifds::FundISIN, isinNumber, idDataGroup, false);
      if (!isinNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByISIN (isinNumber, fundCode, classCode))
         {
            setField (ifds::FromFund, fundCode, idDataGroup, false, true);
            setField (ifds::FromClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::FundToISIN)
   {
      DString isinNumber;

      getField (ifds::FundToISIN, isinNumber, idDataGroup, false);
      if (!isinNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByISIN (isinNumber, fundCode, classCode))
         {
            setField (ifds::ToFund, fundCode, idDataGroup, false, true);
            setField (ifds::ToClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::FundWKN)
   {
      DString wknNumber;

      getField (ifds::FundWKN, wknNumber, idDataGroup, false);
      if (!wknNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByWKN (wknNumber, fundCode, classCode))
         {
            setField (ifds::FromFund, fundCode, idDataGroup, false, true);
            setField (ifds::FromClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::FundToWKN)
   {
      DString wknNumber;

      getField (ifds::FundToWKN, wknNumber, idDataGroup, false);
      if (!wknNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByWKN (wknNumber, fundCode, classCode))
         {
            setField (ifds::ToFund, fundCode, idDataGroup, false, true);
            setField (ifds::ToClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::FundLFC)
   {
      DString lfcNumber;

      getField (ifds::FundLFC, lfcNumber, idDataGroup, false);
      if (!lfcNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByLFC (lfcNumber, fundCode, classCode))
         {
            setField (ifds::FromFund, fundCode, idDataGroup, false, true);
            setField (ifds::FromClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::FundToLFC)
   {
      DString lfcNumber;

      getField (ifds::FundToLFC, lfcNumber, idDataGroup, false);
      if (!lfcNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByLFC (lfcNumber, fundCode, classCode))
         {
            setField (ifds::ToFund, fundCode, idDataGroup, false, true);
            setField (ifds::ToClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::CUSIP)
   {
      DString cusipNumber;

      getField (ifds::CUSIP, cusipNumber, idDataGroup, false);
      if (!cusipNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByCUSIP (cusipNumber, fundCode, classCode))
         {
            setField (ifds::FromFund, fundCode, idDataGroup, false, true);
            setField (ifds::FromClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::ToCUSIP)
   {
      DString cusipNumber;

      getField (ifds::ToCUSIP, cusipNumber, idDataGroup, false);
      if (!cusipNumber.empty())
      {
         DString fundCode, 
            classCode;

         if (getWorkSession ().GetFundClassCodeByCUSIP (cusipNumber, fundCode, classCode))
         {
            setField (ifds::ToFund, fundCode, idDataGroup, false, true);
            setField (ifds::ToClass, classCode, idDataGroup, false, true);
         }
      }
   }
   else if (idField == ifds::EffectiveDate || idField == ifds::TradeInDate)
   {
     /* DString tradeDate;
      getField(ifds::EffectiveDate, tradeDate, idDataGroup);

      validateDate ( DATE_VALIDATION::TRADE_DATE, 
                     ifds::EffectiveDate, 
                     tradeDate, 
                     idDataGroup);*/

//check the effectiveness of broker/branch/salesrep/address code
//controls re-loaded in GUI
      REVALIDATEFIELD (ifds::Broker, idDataGroup); 
      REVALIDATEFIELD (ifds::Branch, idDataGroup);
      REVALIDATEFIELD (ifds::SlsrepCode, idDataGroup);
      REVALIDATEFIELD (ifds::AddrCode, idDataGroup);

//we do not want the conditions attached on this field, 
//they will be attached on the revalidated fields

      setFieldValid (ifds::AccountNum, idDataGroup, false); // to force validation (can Account still trade?)
      setFieldValid (ifds::AccountTo, idDataGroup, false);  // to force validation (can Account still trade?)
      setFieldValid (ifds::FromFundClass, idDataGroup, false);    // to force validation (can Fund still trade?)
      setFieldValid (ifds::AcctableTradeDate, idDataGroup, false);     // to force validation
      setFieldValid (ifds::AmountAmtType, idDataGroup, false); //depends on redemption validations
      setFieldValid (ifds::DuplicateTrade, idDataGroup, false); //duplicate trade check
      setFieldValid (ifds::FundBrokerCode, idDataGroup, false);//if required, should be valid
      setFieldValid (ifds::TradePayTypeFundClass, idDataGroup, false); // force validation for backdate trade of direct deposit redemption
	  setFieldValid (ifds::TradeInDate, idDataGroup, false);

      accountableBackdatedRelatedChanges (idDataGroup);
      setTradeDateToRespDate (idDataGroup);
      setDilutionRespDateInvalid (idDataGroup);
      directOrderSettleDateRelatedChanges (idDataGroup);
      setExchRate (idDataGroup);
      setAllocField (ifds::EffectiveDate, ifds::EffectiveDate, idDataGroup);
      setFromAllocField (ifds::EffectiveDate, ifds::EffectiveDate, idDataGroup);
	  RDRAdviceRelatedChanges(idDataGroup);
      refreshSplitCommissions (idDataGroup);
      aggregateOptionRelatedChanges (idDataGroup);
	  setCommRedRateSubstitutionSet (idDataGroup);//Added for INC0028597
      setAccountabilityReasonCodeDefaultValues (idDataGroup);
      if (isBackdatedTrade (idDataGroup))
      {
         DString dstrAllEFTConsolActive,
            dstrBulkBackDate,
            dstrConsolidation,
            dstrConsolTransType;

         getWorkSession().getOption ( ifds::AllEFTConsolActive, 
            dstrAllEFTConsolActive, 
            BF::HOST,
            false); 

         getWorkSession().getOption ( ifds::BulkBackDate,
            dstrBulkBackDate, 
            BF::HOST,
            false);

         getWorkSession().getOption(ifds::Consolidation, 
            dstrConsolidation,
            BF::HOST,
            false);

         getWorkSession().getOption(ifds::ConsolTransType,
            dstrConsolTransType,
            BF::HOST,
            false);

         std::vector<DString> consolTransTypeList, consolEnableList;
         DSTCommonFunctions::tokenizeString(dstrConsolidation, consolEnableList);
         DSTCommonFunctions::tokenizeString(dstrConsolTransType, consolTransTypeList);

         unsigned int consolIndex;
         for( consolIndex = 0; consolIndex < consolTransTypeList.size(); consolIndex++)
         {
            if( consolTransTypeList[consolIndex] == PAYMENT_FOR::REDEMPTION)
               break;
         }

         if( dstrAllEFTConsolActive == I_("Y") &&
             isRedemption(idDataGroup) &&
             consolIndex < consolTransTypeList.size() &&
             consolEnableList[consolIndex] == Y )
         {
            DString dstrBulkBackDate, 
               dstrConsolType;

            getWorkSession().getOption(ifds::BulkBackDate,
                                       dstrBulkBackDate,
                                       BF::HOST,
                                       false);

            // BulkBackDate has 2 different possible values
            // 0 for Bulk and 1 for individual.
            // This is just opposite to the value of Consolidation Type.
            dstrConsolType = (dstrBulkBackDate == I_("0"))?
                              CONSOL_TYPE::BULKING :
                              CONSOL_TYPE::INDIVIDUAL_PAYMENT;	

            setConsolidationType (dstrConsolType, idDataGroup);
         }
         else
         {
            setConsolidationType (CONSOL_TYPE::INDIVIDUAL_PAYMENT, idDataGroup);
         }

         setFieldValid (ifds::FromSegTradeEntryCheck, idDataGroup, false);
      }
//reset the EUSD field
      setFieldNoValidate (ifds::OverrideCost, I_("N"), idDataGroup, true);
      setFieldNoValidate (ifds::OverrideTIS, I_("N"), idDataGroup, true);

      refreshSettleDateByCurrencyChanges(idDataGroup);
      reCall135ForSettleDateOnly (idDataGroup);      
      if (isAssociationWithBeneficiaryAllowed(idDataGroup))
         initBeneficiarySubList (idDataGroup);

      setFieldValid (ifds::LinkedEntityId, idDataGroup, false);
      setFieldValid (ifds::AssocTransId, idDataGroup, false);

      updateGIMaturityDate(idDataGroup);
      //RDRAdviceRelatedChanges(idDataGroup); 

	  TransactionList *pAdjTransactionList;
	  if(getAdjustTransactionList(pAdjTransactionList, idDataGroup)<=WARNING &&
		  pAdjTransactionList != NULL)
	  {
		  BFObjIter iter(*pAdjTransactionList, idDataGroup, BFObjIter::NON_DELETED);
		  
		  DString tradeDate, adjTradeDate;
		  getField(ifds::EffectiveDate, tradeDate, idDataGroup);
		  iter.getObject()->getField(ifds::EffectiveDate, adjTradeDate, idDataGroup);
		  if(tradeDate == adjTradeDate)
		  {
			  DString dstrSettleNetwork;
			  iter.getObject()->getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup);
			  setFieldNoValidate(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup);	  
		  }
	  }
	orderRoutingRelatedChanges (idDataGroup);
	 refreshIntradayPricing(idDataGroup);
   }
   else if (idField == ifds::Broker)
   {
      DString branch;
		if (brokerRelatedChanges (branch, idDataGroup) <= WARNING)
		{
			setFieldNoValidate ( ifds::Branch, branch, idDataGroup, false, 
							false, 
							true); //notify
		}
		//changing the broker affects the value of 'ExpGNSettle'
		orderTypeBrokerRelatedChanges (idDataGroup);
		//sets the pay instr option
		refreshTradePayInstructions (idDataGroup);
		//should blow the current splits list and reload (158)
		//refresh splits only if the value of broker/branch and sales rep are valid and non empty
		refreshSplitCommissions (idDataGroup);
		setFieldValid (ifds::MinFromFundAmount, idDataGroup, false); 
		setFieldValid (ifds::SettleSource, idDataGroup, false);

		setFieldNoValidate(ifds::SlsrepCode, NULL_STRING, idDataGroup, false, false, true);
		
		//validate cut off at broker level
		DString tradeDate;
		getField(ifds::EffectiveDate, tradeDate, idDataGroup, false);
		validateDate(DATE_VALIDATION::DEFAULT_TRADE_DATE, ifds::EffectiveDate, tradeDate, idDataGroup);
   }
   else if (idField == ifds::Branch)
   {
//this will call apply related changes in a cascade
//sales rep
       DString dstrRepByBranch, dstrBranch;
       getField(ifds::Branch, dstrBranch, idDataGroup);
       getWorkSession().getOption( ifds::RepByBranch, dstrRepByBranch, idDataGroup, false );

       if (dstrRepByBranch.stripAll().upperCase() == Y)
       {
           setFieldNoValidate ( ifds::SlsrepCode, NULL_STRING, idDataGroup, false, 
               false, 
               true);
       }

       setFieldValid (ifds::MinFromFundAmount, idDataGroup, false); 

//sets the pay instr option
      refreshTradePayInstructions (idDataGroup);
//should blow the current splits list and reload (158)
      refreshSplitCommissions (idDataGroup);
   } 
   else if (idField == ifds::SlsrepCode)
   {
       DString createRep;

       getField (ifds::CreateRep, createRep, idDataGroup);

       if (createRep == N)
       {
           //sets the pay instr option
           refreshTradePayInstructions (idDataGroup);
           //should blow the current splits list and reload (158)
           refreshSplitCommissions (idDataGroup);

           DString dstrRepByBranch;
           getWorkSession().getOption( ifds::RepByBranch, dstrRepByBranch, idDataGroup, false );

           if( dstrRepByBranch.stripAll().upperCase() == N )
           {
               Agent *pAgent = NULL;
               DString agentBranchCode;

               if (getAgent(pAgent, idDataGroup) <= WARNING && pAgent)
               {
                   pAgent->getField(ifds::BranchCode, agentBranchCode, idDataGroup);
                   setFieldNoValidate( ifds::Branch, agentBranchCode, idDataGroup, false, false, true);
               }
           }
       }

       setFieldValid (ifds::MinFromFundAmount, idDataGroup, false); 
   }
   else if (idField == ifds::OrderType)
   {
      orderTypeBrokerRelatedChanges (idDataGroup);
      orderTypeRelatedChanges (idDataGroup);
      aggregateOptionRelatedChanges (idDataGroup);
   }
//pay type/pay method/file proc
   else if (idField == ifds::TradesPayType)
   {
	  payTypeRelatedChanges (idDataGroup);
      fileProcessorRelatedChanges (idDataGroup);
      payMethodPropertyChanges (idDataGroup);
      settleCurrencyRelatedChanges (idDataGroup);
	  if(isFileProccessorApplicable (idDataGroup))
	  {
         DString dstrPayType, dstrPayMethod;
         getField (ifds::TradesPayType, dstrPayType, idDataGroup, false);
		 if(dstrPayType == PAYTYPE::DIRECT_DEPOSIT && DSTCommonFunctions::getMarket() == MARKET_IDS::CANADA)
            dstrPayMethod = I_("DDER");
		 else
            dstrPayMethod = DSTCommonFunctions::getMarket() != MARKET_IDS::CANADA ? I_("WIRE") : I_("EFT");
         setFieldNoValidate (ifds::PayMethod, dstrPayMethod, idDataGroup,
								  false, 
								  true, 
								  true, //notify
								  true); //no related changes
	  }
      setFieldValid (ifds::BankIdValue, idDataGroup, false);
      setFieldValid (ifds::AddrCode, idDataGroup, false);
      setFieldValid (ifds::AmtType, idDataGroup, false);
      setFieldValid (ifds::ESGSettle, idDataGroup, false);
   }
   else if (idField == ifds::ACHProcessor)
   {
      settleCurrencyRelatedChanges (idDataGroup);
      setTradePayInstructField (ifds::ACHProcessor, ifds::ACHProcessor, idDataGroup);
//should set the field on the banking info if exists
      TradeBankInstructionsList *pTradeBankInstructionsList = NULL;

      if (  getBankInstructionsList ( pTradeBankInstructionsList, 
                                       idDataGroup) <= WARNING &&
            pTradeBankInstructionsList)
      {
         BFObjIter iter (*pTradeBankInstructionsList, idDataGroup);

         if (!iter.end()) //the bank list has only one item
         {
            DString fileProcessor;

            getField (ifds::ACHProcessor, fileProcessor, idDataGroup, false);
            iter.getObject() ->setField (ifds::ACHProcessor, fileProcessor, idDataGroup, false);
         }
      }
   }
   else if (idField == ifds::PayMethod)
   {
      payMethodRelatedChanges (idDataGroup);
      settleCurrencyRelatedChanges (idDataGroup);
//load subst list for file processor for this idDataGroup
      fileProcessorRelatedChanges (idDataGroup);
      setTradePayInstructField (ifds::PayMethod, ifds::PayMethod, idDataGroup);
      if (isBankingNeeded (idDataGroup))
      {
         setFieldValid (ifds::PayTypeBankNum, idDataGroup, false);
      }
   }
   else if (idField == ifds::FromCurrency)
   {
      setExchRate (idDataGroup);
      setFieldValid (ifds::MinToFundAmount, idDataGroup, false);
   }
   else if (idField == ifds::SettleCurrency)
   {
      setExchRate (idDataGroup);
      // force system to do the minimum amount edit when switching to a different settle currency
      bankingRelatedChanges (idDataGroup); 
      fileProcessorRelatedChanges (idDataGroup);
      payMethodPropertyChanges (idDataGroup);
      setTradePayInstructField (ifds::SettleCurrency, ifds::Currency, idDataGroup);
      setFieldValid (ifds::TradesPayType, idDataGroup, false);
      setFieldValid (ifds::MinFromFundAmount, idDataGroup, false);
		revalidateField (ifds::MinFromFundAmount, idDataGroup);
      setFieldValid (ifds::AmtType, idDataGroup, false);
      setFieldValid (ifds::AmountAmtType, idDataGroup, false); //depends on redemption validations
//allocation/split commissions related changes
      setAllocField (ifds::SettleCurrency, ifds::Currency, idDataGroup);
      setFromAllocField (ifds::SettleCurrency, ifds::Currency, idDataGroup);

      refreshSettleDateByCurrencyChanges( idDataGroup );
      reCall135ForSettleDateOnly( idDataGroup );

      //DString settleDate;

      //getField (ifds::SettleDate, settleDate, idDataGroup);
      //validateDate ( DATE_VALIDATION::SETTLE_DATE, 
      //               ifds::SettleDate, 
      //               settleDate, 
      //               idDataGroup);
      refreshSplitCommissions (idDataGroup);
	  setFieldValid (ifds::DuplicateTrade, idDataGroup, false); //duplicate trade check
   }
   else if (idField == ifds::BankIdValue)
   {
      setFieldValid (ifds::TradesPayType, idDataGroup, false);
//call some of the related changes
      if (getErrorState (ifds::TradesPayType, idDataGroup) <= WARNING)
      {
         bankChrgsRelatedChanges (idDataGroup);
      }
   }
/*
   else if (idField == ifds::DealTime)
   {
//if DealDateTime is Yes and fund code is not blank and TradeCutOff is Yes and
//EffectiveDate = DealDate and EffectiveDate >= CurrBusinessDate,
//reassign EffectiveDate to SuggestTradeDate (acctually the TradeDate is assigned to EffectiveDate)
      DString dealDateTime,
         tradeCutOff,
         fundCode;

      getWorkSession ().getOption ( ifds::DealDateTime, 
                                    dealDateTime, 
                                    BF::HOST, 
                                    false);
      getWorkSession ().getOption ( ifds::TradeCutOff, 
                                    tradeCutOff, 
                                    BF::HOST, 
                                    false);
      getField (ifds::FromFund, fundCode, idDataGroup, false);
      if ( dealDateTime == Y && 
           tradeCutOff == Y && 
           !fundCode.empty())
      {
         DString effectiveDate, 
            dealDate;

         getField (ifds::EffectiveDate, effectiveDate, idDataGroup);
         getField (ifds::DealDate, dealDate, idDataGroup);

         if ( DSTCommonFunctions::CompareDates (effectiveDate, dealDate) == DSTCommonFunctions::EQUAL && 
               ( DSTCommonFunctions::CompareDates (_currentBusinessDate, effectiveDate) == DSTCommonFunctions::FIRST_EARLIER || 
                 DSTCommonFunctions::CompareDates (_currentBusinessDate, effectiveDate) == DSTCommonFunctions::EQUAL))
         {
            DString dealTime;

            validateDate ( DATE_VALIDATION::DEAL_TIME, 
                           ifds::DealDateTime, 
                           dealTime, 
                           idDataGroup);
         }
         setFieldValid (ifds::EffectiveDate, idDataGroup, false); //invalidate trade date field field
      }
   }
   else if (idField == ifds::DealDate)
   {
      setFieldValid (ifds::EffectiveDate, idDataGroup, false); //invalidate trade date field field
   }
*/
   else if (idField == ifds::DealDate ||
            idField == ifds::DealTime)
   {
      DString dealDateTime,
         tradeCutOff,
         fundCode;

      getWorkSession ().getOption ( ifds::DealDateTime, 
                                    dealDateTime, 
                                    BF::HOST, 
                                    false);
      getWorkSession ().getOption ( ifds::TradeCutOff, 
                                    tradeCutOff, 
                                    BF::HOST, 
                                    false);
      getField (ifds::FromFund, fundCode, idDataGroup, false);
      if ( dealDateTime == Y && 
           tradeCutOff == Y && 
           !fundCode.empty())
      {
         DString tradeDate;

         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         validateDate (DATE_VALIDATION::DEFAULT_TRADE_DATE, ifds::EffectiveDate, tradeDate, idDataGroup);
      }
      setFieldValid (ifds::EffectiveDate, idDataGroup, false); //invalidate trade date field field
	  refreshIntradayPricing(idDataGroup);
	  if(idField == ifds::DealDate)
		hasWaiveGatingFund(idDataGroup);
   }
   else if (idField == ifds::CreateRep)
   {
      DString createRep;

      getField (ifds::CreateRep, createRep, idDataGroup, false);
      if (createRep == Y)
      {
//should re-validate the Slsrep field
         revalidateField (ifds::SlsrepCode, idDataGroup);
      }
   }
   if (idField == ifds::CashDateXEdit)
   {
//If FundType is 'I' and EffectiveDate <= LastValDate and DividendType is 'S'
//and IntFromDateType is 'C' or IntToDateType is 'C', CashDate is updatable
      setCashDateUpdatable (idDataGroup);
	  revalidateField (ifds::CashDate, idDataGroup);
   }
   else if (idField == ifds::SettleDate)
   {
      DString dstrSettleNetwork;

      getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup, false);
      if(dstrSettleNetwork == I_("FSRV"))
      {
         DString dstrSettleDate;
         DSTCommonFunctions::addDays(_currentBusinessDate, dstrSettleDate, 1);
         setFieldNoValidate(ifds::SettleDate, dstrSettleDate, idDataGroup, false, false, false, false);
         
         DString dstrTradeDate, dstrDepositDate, dstrValueDate, dstrSettleInDate, dstrTradeInDate;

         getField( ifds::EffectiveDate,   dstrTradeDate,     idDataGroup );
         getField( ifds::DepositDate,     dstrDepositDate,   idDataGroup );
         getField( ifds::ValueDate,       dstrValueDate,     idDataGroup );
         getField( ifds::SettleInDate,    dstrSettleInDate,  idDataGroup );
		 getField( ifds::TradeInDate,     dstrTradeInDate,   idDataGroup );

         DateValidation *pTrade_DateValidation = NULL;

         if ( getTradeDateValidation ( pTrade_DateValidation, 
                                       DATE_VALIDATION::INPUT_SETTLE_DATE, 
                                       dstrTradeDate, // trade date
                                       dstrSettleDate, // settle date
                                       dstrDepositDate, 
                                       dstrValueDate, 
                                       dstrTradeDate, // settle in date
									   dstrTradeInDate,
                                       idDataGroup ) <= WARNING &&
            pTrade_DateValidation)
         {
            pTrade_DateValidation->getField( ifds::SettleDate, dstrSettleDate, idDataGroup, false ); 
            if ( !dstrSettleDate.empty() )
            {
               setFieldNoValidate ( ifds::SettleDate, dstrSettleDate, idDataGroup,  false, 
                                    false, 
                                    false,
                                    false); 
            }
			DString dstrCashDate,emptyDate;
			getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
			pTrade_DateValidation->getField( ifds::CashDate, dstrCashDate, idDataGroup, false );
			if(!dstrCashDate.empty())
				setFieldNoValidate ( ifds::CashDate, dstrCashDate, idDataGroup,  false, 
				false, 
				false,
				false);
			else if(!isRebook() )
				 setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false,
				 false,
				 false,
				 false);

         } 
      }

	  setCashDateUpdatable (idDataGroup);
      setTradeDateToRespDate (idDataGroup);
      setDilutionRespDateInvalid (idDataGroup);
      setFieldValid (ifds::SettleInDate, idDataGroup, false); //to trigger validation at the end
	  setFieldValid (ifds::DuplicateTrade, idDataGroup, false); //duplicate trade check
   }
   else if (idField == ifds::AmtType)
   {
	  reCall135ForSettleDateOnly( idDataGroup );
	  setFieldValid (ifds::MinFromFundAmount, idDataGroup, false);// to force validation
      setFieldValid (ifds::DuplicateTrade, idDataGroup, false); //duplicate trade check
      amtTypeExtraRelatedChanges (idDataGroup);
//allocation/split commissions related changes
      setAllocField (ifds::AmtType, ifds::AllocAmtType, idDataGroup);
      setFromAllocField (ifds::AmtType, ifds::AllocAmtType, idDataGroup);
      refreshSplitCommissions (idDataGroup);   
   }
   else if (idField == ifds::Amount)
   {
      setAllocField (ifds::Amount, ifds::Amount, idDataGroup); //this will set the correct amount on the splits, as well
      setFromAllocField (ifds::Amount, ifds::Amount, idDataGroup);
      setFieldValid (ifds::DuplicateTrade, idDataGroup, false); //duplicate trade check
      setRecptIssuedForRebook( idDataGroup );
      setRESP10xAssistedContrAmt( idDataGroup );
      investTypeRelatedChanges(idDataGroup);

      if(isGIInvestmentListApplicable(idDataGroup))
      {
         GIInvestmentDetailsList* pGIInvestmentDetailsList = NULL;
         getGIInvestmentDetails ( pGIInvestmentDetailsList, idDataGroup, true);
         if(pGIInvestmentDetailsList)
         {
            DString dstrTradeAmount;
            getField(ifds::Amount, dstrTradeAmount, idDataGroup);
            pGIInvestmentDetailsList->setField(ifds::TradeAmount, dstrTradeAmount, idDataGroup, false);
         }
      }
	 	 
   }
   else if (idField == ifds::FrSettlLocCode)
   {
      setSettleLocationDescription (ifds::FrSettlLocCode, ifds::FrSettlLocDescription, idDataGroup);
      setAccountNumbersFromSystemLevel(true ,idDataGroup);
   }
   else if (idField == ifds::ToSettlLocCode)
   {
      setSettleLocationDescription (ifds::ToSettlLocCode, ifds::ToSettlLocDescription, idDataGroup);
      setAccountNumbersFromSystemLevel(false ,idDataGroup);
   }
   else if (idField == ifds::FrSettlInstrCode)
   {
      DString settleInstrCode,
         accountNum;
      
      getField (ifds::FrSettlInstrCode, settleInstrCode, idDataGroup, false);
      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      accountNum.stripLeading ('0').strip();

      bool bNotApplicable = settleInstrCode == I_("N/A") || settleInstrCode.empty();
      setAccountNumbersFromSystemLevel(true ,idDataGroup);
      if (!bNotApplicable)
      {
         setAcctSettlementInstr (settleInstrCode, accountNum, idDataGroup);
      }
      else //blank out the fields
      {
         setFieldNoValidate (ifds::FrDeliveryTo, NULL_STRING, idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrInFavourOf, NULL_STRING, idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrForAccount, NULL_STRING, idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::FrCSDLocation, NULL_STRING, idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::FrCSDAcctNum, NULL_STRING, idDataGroup, false, false, true);
         for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrFrReadOnlyFields;	i++)
         {
           setFieldNoValidate ( SETL_LOC_FIELDS::SttlInstrFrReadOnlyFields[i], NULL_STRING, idDataGroup, false, false, true );
         }	
      }
      setFieldReadOnly (ifds::FrDeliveryTo, idDataGroup, !bNotApplicable);
      setFieldReadOnly (ifds::FrInFavourOf, idDataGroup, !bNotApplicable);
      setFieldReadOnly (ifds::FrForAccount, idDataGroup, !bNotApplicable);
	  setFieldReadOnly (ifds::FrCSDLocation, idDataGroup, !bNotApplicable);
	  setFieldReadOnly (ifds::FrCSDAcctNum, idDataGroup, !bNotApplicable);
      for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrFrReadOnlyFields;	i++)
      {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrFrReadOnlyFields[i],  idDataGroup, !bNotApplicable );
      }	
      for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
      {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
      }
   }
   else if (idField == ifds::ToSettlInstrCode)
   {
      DString settleInstrCode,
         accountNum;
      
      getField (ifds::ToSettlInstrCode, settleInstrCode, idDataGroup, false);
      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      accountNum.stripLeading ('0').strip();

      bool bNotApplicable = settleInstrCode == I_("N/A") || settleInstrCode.empty();
      setAccountNumbersFromSystemLevel(false, idDataGroup );
      if (!bNotApplicable)
      {
         setAcctSettlementInstr (settleInstrCode, accountNum, idDataGroup);
      }
      else //blank out the fields
      {
         setFieldNoValidate (ifds::ToDeliveryTo, NULL_STRING, idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToInFavourOf, NULL_STRING, idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToForAccount, NULL_STRING, idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::ToCSDLocation, NULL_STRING, idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::ToCSDAcctNum, NULL_STRING, idDataGroup, false, false, true);
         for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrToReadOnlyFields;	i++)
         {
           setFieldNoValidate ( SETL_LOC_FIELDS::SttlInstrToReadOnlyFields[i], NULL_STRING, idDataGroup, false, false, true );
         }	
      }
      setFieldReadOnly (ifds::ToDeliveryTo, idDataGroup, !bNotApplicable);
      setFieldReadOnly (ifds::ToInFavourOf, idDataGroup, !bNotApplicable);
      setFieldReadOnly (ifds::ToForAccount, idDataGroup, !bNotApplicable);
	  setFieldReadOnly (ifds::ToCSDAcctNum, idDataGroup, !bNotApplicable);
	  setFieldReadOnly (ifds::ToCSDLocation, idDataGroup, !bNotApplicable);
      for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrToReadOnlyFields;	i++)
      {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrToReadOnlyFields[i],  idDataGroup, !bNotApplicable );
      }	
        for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
      {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
      }
   }
   else if (idField == ifds::DiscountRate)
   {
      //this is mostly a display field...
      setFieldUpdated (ifds::DiscountRate, idDataGroup, false);
   }
   else if (idField == ifds::AmountPrecision)
   {
      setFieldValid (ifds::Amount, idDataGroup, false);// to force validation  
   }
   else if (idField == ifds::NetworkID)
   {
      networkIDRelatedChanges (idDataGroup);
      DString networkID, dstrAWDFieldFlag;
	  getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag,BF::HOST,false);
      getField (ifds::NetworkID, networkID, idDataGroup);
      if (!networkID.empty())
      {
         setNetworkIDSendRefNum (idDataGroup, false);         
         DString dealDateTime, tradeCutOff, fundCode;
         getWorkSession ().getOption ( ifds::DealDateTime, dealDateTime, BF::HOST, false);
         getWorkSession ().getOption ( ifds::TradeCutOff,  tradeCutOff,  BF::HOST, false);
         getField (ifds::FromFund, fundCode, idDataGroup, false);
         if ( YES == dealDateTime  &&  YES == tradeCutOff &&  !fundCode.empty())
         {
          DString tradeDate;
          getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
          validateDate (DATE_VALIDATION::DEFAULT_TRADE_DATE, ifds::EffectiveDate, tradeDate, idDataGroup);
         }
        setFieldValid (ifds::EffectiveDate, idDataGroup, false); //invalidate trade date field field
      }
	  if( networkID.empty() ||
		  ( I_("AWD") == networkID  && YES == dstrAWDFieldFlag)) 
	  {
		setFieldWithDefaultValue(ifds::SourceOfTrade, idDataGroup);
		setFieldWithDefaultValue(ifds::ChannelOfTrade, idDataGroup);
	  }
   }
   else if (idField == ifds::ExtTransNum)
   {
      extTransNumRelatedChanges (idDataGroup );
   }
   else if (idField == ifds::OtherConfirmType)
   {
      otherConfirmTypeRelatedChanges (idDataGroup);
   }
   else if (idField == ifds::FundIDType)
   {
      setFieldUpdated (ifds::FundIDType, idDataGroup, false);
   }
   else if (idField == ifds::ROAAmount)
   {
      roaAmountRelatedChanges (idDataGroup);
   }
   else if ( idField == ifds::ExchRate )
   {
      exchRateRelatedChanges( idDataGroup );
   }
   else if ( idField == ifds::SettleNetwork )
   {
	   DString dstrSettleNetwork;
	   getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup, false);

	  if(dstrSettleNetwork == I_("FSRV"))
	  {
		  DString date ;
		  DSTCommonFunctions::addDays(_currentBusinessDate, date, 1);
         setFieldNoValidate(ifds::SettleDate, date, idDataGroup, false);
         
		  setFieldReadOnly(ifds::SettleDate, idDataGroup, true);

		  if(isRebook() || isBackdatedTrade(idDataGroup)) 
		  {
			  setFieldNoValidate(ifds::TradesPayType, PAYTYPE::SYSTEM_CHEQUE, idDataGroup);
			  setFieldReadOnly(ifds::TradesPayType, idDataGroup, true);
		  }
	  }
	  else 
	  {
		  setFieldReadOnly(ifds::SettleDate, idDataGroup, false);
		  reCall135ForSettleDateOnly(idDataGroup);
		  setFieldReadOnly(ifds::TradesPayType, idDataGroup, false);
	  }
   }
   else if ( idField == ifds::Accountable || 
             idField == ifds::BackDatedReason)
   {
      DString  accountable, 
               backDatedReason; 

      getField (ifds::Accountable, accountable, idDataGroup);
      getField (ifds::BackDatedReason, backDatedReason, idDataGroup);

      DilutionAllocList *pDilutionAllocList = NULL;

      if ( getDilutionAllocList ( pDilutionAllocList, 
                                  idDataGroup, 
                                  false ) <= WARNING &&
         pDilutionAllocList)
      {
         BFObjIter iter ( *pDilutionAllocList, 
                           idDataGroup, 
                           false, 
                           BFObjIter::ITERTYPE::NON_DELETED);

         int numItems = iter.getNumberOfItemsInList ();


         if (numItems == 1)
         {
            iter.getObject()->setField ( ifds::Accountable, accountable, idDataGroup);
            iter.getObject()->setField ( ifds::BackDatedReason, backDatedReason, idDataGroup );
         }
         setFieldReadOnly (ifds::Accountable, idDataGroup, numItems != 1);
         setFieldReadOnly (ifds::BackDatedReason, idDataGroup, numItems != 1);
      }
   }
   else if (idField == ifds::OverrideTIS)
   {
      DString overrideTIS;

      getField (ifds::OverrideTIS, overrideTIS, idDataGroup);
      setFieldReadOnly (ifds::TIS, idDataGroup, overrideTIS != Y);
      if (overrideTIS != Y)
      {
         setFieldNoValidate (ifds::TIS, NULL_STRING, idDataGroup, false, false, true);
      }
   }
   else if (idField == ifds::OverrideCost)
   {
      DString overrideCost;
      getField ( ifds::OverrideCost, overrideCost, idDataGroup);
      setFieldReadOnly (ifds::Cost, idDataGroup, overrideCost != Y);
      if (overrideCost != Y)
      {
         setFieldNoValidate (ifds::Cost, NULL_STRING, idDataGroup, false, false, true);
      }
   } 
   else if (idField == ifds::AddrCode)
   {
      setFieldValid (ifds::ESGSettle, idDataGroup, false);
   }
   else if (idField == ifds::FromToFundClass)
   {
      amtTypeExtraRelatedChanges (idDataGroup);
      bool bReadOnly = hasAllocations (idDataGroup) ? true : false; 
      DString setttleInDate = NULL_STRING;

      if (!bReadOnly)
      {
         getField (ifds::SettleInDate, setttleInDate, idDataGroup);
      }

      setFieldNoValidate (ifds::SettleInDate, setttleInDate, idDataGroup, false, false, true);
      setFieldReadOnly (ifds::SettleInDate, idDataGroup, bReadOnly);
   }
   else if (idField == ifds::PayInstrOption)
   {
      DString payInstrOption;

      getField (ifds::PayInstrOption, payInstrOption, idDataGroup);
      if (I_("02") == payInstrOption || I_("03") == payInstrOption) //redirect to shareholder or to reg agent
      {
//clear the pay to entiy banking information, if exists
         removeTradeBankInstructionsList (idDataGroup);
      }
      if (payInstrOption == I_("03"))
      {
	      setFieldNoValidate ( ifds::TradesPayType,PAYTYPE::EFT, idDataGroup,  
                              false, 
                              false,
                              true); 
	      setFieldNoValidate ( ifds::PayMethod, DSTCommonFunctions::getMarket() != MARKET_IDS::CANADA ? I_("WIRE"): I_("EFT"), idDataGroup,  
                              false, 
                              false,
                              true);
         setFieldReadOnly (ifds::TradesPayType, idDataGroup, true);
         setFieldReadOnly (ifds::PayMethod, idDataGroup, true);
      }
   }
   else if ( idField == ifds::FrSettlCurrency ||
             idField == ifds::ToSettlCurrency)
   {
      reCall135ForSettleDateOnly( idDataGroup );

      //DString settleDate;

      //getField (ifds::SettleDate, settleDate, idDataGroup);
      //validateDate ( DATE_VALIDATION::SETTLE_DATE, 
      //               ifds::SettleDate, 
      //               settleDate, 
      //               idDataGroup);
   }
   else if ( idField == ifds::DepositType ||
             idField == ifds::RedCode)
   {
      if (isAssociationWithBeneficiaryAllowed(idDataGroup))
      {
         initBeneficiarySubList (idDataGroup);
      }
      else if (isAIPAllowed (idDataGroup))
      {
         initAccountHoldersSubList (idDataGroup);
      }
      else
      {
         DString strFormerSpouses;
           
         if (getFormerSpouseList (strFormerSpouses, idDataGroup) <= WARNING)
         {
            setFieldAllSubstituteValues (ifds::LinkedEntityId, idDataGroup, strFormerSpouses);
            if (strFormerSpouses.strip() == I_("0=N/A;"))
            {
               setFieldNoValidate (ifds::LinkedEntityId, I_("0"), idDataGroup, false, false, true);
            }
         } 
      }

      setFieldValid (ifds::LinkedEntityId, idDataGroup, false);
      setFieldValid (ifds::AssocTransId, idDataGroup, false);

      setFieldNoValidate  (ifds::CourseStart, NULL_STRING, idDataGroup, false, false, true);
      setFieldNoValidate  (ifds::CourseLen, NULL_STRING, idDataGroup, false, false, true);
      setFieldNoValidate  (ifds::PSEProgramLen, NULL_STRING, idDataGroup, false, false, true);
      setFieldNoValidate  (ifds::PSEProgramType, NULL_STRING, idDataGroup, false, false, true);
      setFieldNoValidate  (ifds::PSEProgramYear, NULL_STRING, idDataGroup, false, false, true);
      setFieldNoValidate  (ifds::EduInstPstl, NULL_STRING, idDataGroup, false, false, true);

	  isRDSPTransferAllowed (idDataGroup);
   }
   else if (idField == ifds::LinkedEntityId)
   {
      setFieldNoValidate (ifds::AssocTransId, I_("0"), idDataGroup, false, false, true);
      setFieldValid (ifds::DepositType, idDataGroup, false);
      setFieldValid (ifds::RedCode, idDataGroup, false);
   }
   else if (idField == ifds::GRRepayReason)
   {
      setFieldNoValidate (ifds::AssocTransId, I_("0"), idDataGroup, false, false, true);
   }
   else if ( idField == ifds::PSEProgramLen ||
             idField == ifds::PSEProgramType ||
             idField == ifds::PSEProgramYear )
   {
      BFFieldId PSEFieldId (ifds::NullFieldId);

      // assign field id
      if(idField == ifds::PSEProgramLen)
         PSEFieldId = ifds::PSEProgramLenList;
      else if(idField == ifds::PSEProgramType)
         PSEFieldId = ifds::PSEProgramTypeList;
      else if(idField == ifds::PSEProgramYear)
         PSEFieldId = ifds::PSEProgramYearList;

      DString dstrPSEValue;
      getField (idField, dstrPSEValue, idDataGroup, false);

      setFieldNoValidate( PSEFieldId, 
                          dstrPSEValue, 
                          idDataGroup, 
                          false, 
                          false,   // valid
                          true,    // side effect
                          false ); // no ApplyRelatedChange
   }
   else if (idField == ifds::IntCalcMthd)
   {
      intCalcMthdRelatedChanges(idDataGroup);
      investTypeRelatedChanges(idDataGroup);
   }
   else if (idField == ifds::InvestTerm)
   {
      refreshSplitCommissions (idDataGroup);
      updateGIMaturityDate(idDataGroup);
      investTypeRelatedChanges(idDataGroup);
      if(isExchangeLike (idDataGroup) || isTransfer (idDataGroup))
      {
         TransFeeList *pTransFeeList = NULL;
         DString strKey = I_("TransFeeList");

         pTransFeeList = dynamic_cast <TransFeeList *> (getObject (strKey, idDataGroup));
         if (pTransFeeList)
         {
            pTransFeeList->setForcingRefresh(true);
            pTransFeeList->onNotify (FIELD_NOTIFICATIONS, E_EVENT_VALUE_CHANGE, I_("ForceRefresh")); 
         }
      }
   }
   else if (idField == ifds::CommRedRate)
   {
      refreshSplitCommissions (idDataGroup);
      investTypeRelatedChanges (idDataGroup);
   }
   else if (idField == ifds::ForcedRate)
   {
      forcedRateRelatedChanges(idDataGroup);
   }
   else if (idField == ifds::IntCredFreq)
   {
      refreshSplitCommissions (idDataGroup);
      updateGIMaturityDate(idDataGroup);
   }
   else if( idField == ifds::IntInvestType)
   {
      investTypeRelatedChanges(idDataGroup);
   }
   else if (idField == ifds::ForcedRateAmt)
   {
      investTypeRelatedChanges(idDataGroup);
   }
   else if (idField == ifds::AddlAmt)
   {
      investTypeRelatedChanges(idDataGroup);
   }
   else if(idField == ifds::GoodBad)
   {
      PendTrdContractRelatedChanges (idDataGroup); 
   }
   else if (idField == ifds::IsAllocationChanged)
   {
      updateGuaranteeFeeOverride (idDataGroup);
      setFieldUpdated (idField, idDataGroup, false);
   }
   //P0186486_FN15_The Source of Funds
   else if (idField == ifds::SrcOfFund)
   {
      DString srcOfFund;
      getField(ifds::SrcOfFund, srcOfFund, idDataGroup, false); 
      srcOfFund.stripAll().upperCase();

      if(!srcOfFund.empty())
      {	 
         if (isRedemption (idDataGroup))
         {
            setFieldRequired (ifds::TradesPayType, idDataGroup, true);
            setValidFlag ( ifds::TradesPayType, idDataGroup, false );
         } 
         //if not read-only it shouldn't be blank
         BFProperties * pBFProperties = NULL;
         pBFProperties = getFieldProperties( ifds::BankSrcAcct, idDataGroup );
         if( pBFProperties )
         {
            if( !pBFProperties->isReadOnly() )
            {
               if(getWorkSession ().isSrcOfFundRequired(srcOfFund, idDataGroup))
               {
                  setFieldRequired (ifds::SrcOfAccount, idDataGroup, true);
                  setValidFlag ( ifds::SrcOfAccount, idDataGroup, false ); 
               }
               else
               {
                  setFieldRequired (ifds::SrcOfAccount, idDataGroup, false);
                  setValidFlag ( ifds::SrcOfAccount, idDataGroup, true );   
               }
            }
         }

      }

   }
   else if (idField == ifds::RDRAdvice)
   {
	   DString dstrRDRAdvice;
	   getField(ifds::RDRAdvice,dstrRDRAdvice,idDataGroup);

	   TradeFundAllocList *pTradeFundAllocList = NULL;

		if (getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING && pTradeFundAllocList)
		{
			TradeFundAlloc *pTradeFundAlloc = NULL;
			BFObjIter iter (*pTradeFundAllocList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

			while (!iter.end ()) 
			{
				pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());

				if (pTradeFundAlloc)
				{
					SplitCommissionList* pSplitCommissionList = NULL;

					pTradeFundAlloc->getSplitCommissionList( pSplitCommissionList,
															idDataGroup,
															true,
															false);
					if( pSplitCommissionList)
					{
						if(dstrRDRAdvice == RDR_ADVICE_PROVIDED )
						{
							pSplitCommissionList->changeToRDRAdviceProvided(idDataGroup);
						}
						pSplitCommissionList->setField(ifds::RDRAdvice, dstrRDRAdvice, idDataGroup, false);
					}
				}
				++iter;
			}
		}
   } 
   else if ( ifds::DeliveryNetwork ==  idField )
   {
    setOtherConfirmTypeDefaultValues(idDataGroup);
   }
   

   if (idField == ifds::EffectiveDate ||
      idField == ifds::SettleSource ||
	   idField == ifds::Broker ||
	   idField == ifds::OrderType ||
	   idField == ifds::Fund ||
	   idField == ifds::Class)
   {
      if (!isDilutionAllowed(idDataGroup))
      {
        setFieldNoValidate(ifds::SettleNetwork, I_(""), idDataGroup, false);
      }
      else
      {
		   DilutionAllocList *pDilutionAllocList;
		   getDilutionAllocList(pDilutionAllocList, idDataGroup);
		   if(pDilutionAllocList != NULL) 
		   {
			   pDilutionAllocList->refreshNSMEligibility(ifds::IsNetworkSettleEligible, idDataGroup);
			
			   DString dstrSettleNetwork;
			   pDilutionAllocList->getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup, false);
			   setFieldNoValidate(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup, false, true);
		   }
      }

      setFieldValid(ifds::SettleType, idDataGroup, false);
      setFieldValid(ifds::SettleNetwork, idDataGroup, false);
      setFieldValid(ifds::SettleTypeNetworkSettleXEdit, idDataGroup, false); 
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::doValidateAll ( const BFDataGroupId& idDataGroup, 
                                long lValidateGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("doValidateAll"));

//only validate for the main group...   
   if (lValidateGroup == 0)
   {      
//TODO, look at this later!!!
      if (GETCURRENTHIGHESTSEVERITY () <= WARNING)
      {
         // Following logic was added by Celia for the ticket 10018935: 
         // Modify logic to allow user modifying
         // a Pending trade for a RESP account, 
         // but give a warning "RESP specific eidt check is not being performed"

         DString dstrAccountNum, 
               dstrTaxType;
         MFAccount *pMFAccount = NULL;

         getField (ifds::AccountNum, dstrAccountNum, idDataGroup);
         dstrAccountNum.strip ().stripLeading ('0');
         if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum,
            pMFAccount) <= WARNING && pMFAccount)
         {
            pMFAccount->getField (ifds::TaxType, dstrTaxType, idDataGroup);
            dstrTaxType.strip ().upperCase ();
            if ( ( dstrTaxType == I_("9") || //RESP
                  dstrTaxType == I_("M")) && //Family RRSP
                  !isNew() )
            {
               getErrMsg ( IFASTERR::RESP_SPECIFIC_EDIT_CHECK_NOT_PERFORMED, 
                           CND::ERR_RESP_SPECIFIC_EDIT_CHECK_NOT_PERFORMED, 
                           CND::WARN_RESP_SPECIFIC_EDIT_CHECK_NOT_PERFORMED, 
                           idDataGroup); 
            }
			if(isUpdatedForDataGroup (idDataGroup))
			{	
				bool bDisplyWarnSICAV ,bDisplyWarnOEIC;
				pMFAccount->displayEnvXrefWarningOnUpdate(idDataGroup, bDisplyWarnSICAV, bDisplyWarnOEIC);
				if(bDisplyWarnSICAV)
					ADDCONDITIONFROMFILE (CND::WARN_DATA_UPDATE_IMPACTS_EXTERNAL_ENV_SICAV);
				if(bDisplyWarnOEIC)
					ADDCONDITIONFROMFILE (CND::WARN_DATA_UPDATE_IMPACTS_EXTERNAL_ENV_OEIC);
			} 
         }
      }

      DString mfPayment;

      getField (ifds::MFPayment, mfPayment, idDataGroup, false);

      if (mfPayment == NA)
      {
         getErrMsg ( IFASTERR::INVALID_MF_PAYMENT,
                     CND::ERR_INVALID_MF_PAYMENT, 
                     CND::WARN_INVALID_MF_PAYMENT, 
                     idDataGroup);
      }

	  // validation for the parent fund class.
	  validateAMSTradeViaParentFundClass(idDataGroup);

   //cross validation on To Fund and From fund lists, if they exist;
   //apply this validation only if we are in an environment that 
   //allows multifund transfer and the trade type is Transfer or Exchange
   //this check is anyhow made in the getter for the TradeFromFundAllocList, 
   //so there is no need to repeat it here just get the list and 
   //if it doesn't return null then we perform the validation

      TradeFromFundAllocList *pTradeFromFundAllocList = NULL;

      //do not create the list if it doesn't exist
      if ( getFromFundAllocationList ( pTradeFromFundAllocList, 
                                       idDataGroup, 
                                       false) <= WARNING && 
         pTradeFromFundAllocList)
      {
         //get the to fund alloc list

         TradeFundAllocList *pTradeToFundAllocList = NULL;

         if ( getFundAllocationList ( pTradeToFundAllocList, 
                                    idDataGroup) <= WARNING && 
            pTradeToFundAllocList)
         {
            //validate the all around currencies
            //if the system is not multi-currency then
            //the from side and the two side should have the same
            //curreny; we are assured by the validation of both lists
            //that the funds in each lists have already the same currency 
            if (_multiCurrency != I_ ("Y"))
            {
               //get the first fund of the from side and the first fund of
               //the to side and see whether the currencies match

               BFObjIter iter1 ( *pTradeFromFundAllocList, 
                                 idDataGroup, 
                                 false, 
                                 BFObjIter::ITERTYPE::NON_DELETED);
               BFObjIter iter2 ( *pTradeToFundAllocList, 
                                 idDataGroup, 
                                 false, 
                                 BFObjIter::ITERTYPE::NON_DELETED);
               DString fromFundCode, 
                  fromClassCode, 
                  toFundCode, 
                  toClassCode;

               iter1.begin ();
               if (!iter1.end ())
               {       
                  iter1.getObject ()->getField (ifds::FundCode, fromFundCode, idDataGroup, false);
                  iter1.getObject ()->getField (ifds::ClassCode, fromClassCode, idDataGroup, false);
               }
               iter2.begin ();
               if (!iter2.end ())
               {
                  iter2.getObject ()->getField (ifds::FundCode, toFundCode, idDataGroup, false);
                  iter2.getObject ()->getField (ifds::ClassCode, toClassCode, idDataGroup, false);
               }

               FundDetail *pFundDetailFrom = NULL,
                        *pFundDetailTo = NULL;
               DString     toCurrency, 
                           fromCurrency;

               if ( getWorkSession ().getFundDetail ( fromFundCode, 
                                                      fromClassCode, 
                                                      idDataGroup, 
                                                      pFundDetailFrom) && 
                  pFundDetailFrom)
               {
                  pFundDetailFrom->getField (ifds::Currency, fromCurrency, idDataGroup, false);
               }
               if ( getWorkSession ().getFundDetail ( toFundCode, 
                                                      toClassCode, 
                                                      idDataGroup, 
                                                      pFundDetailTo) && 
                  pFundDetailTo)
               {
                  pFundDetailTo->getField (ifds::Currency, toCurrency, idDataGroup, false);
               }
               toCurrency.stripAll ().upperCase ();
               fromCurrency.stripAll ().upperCase ();

               if (toCurrency != fromCurrency)
               {
                  DString strIDI;

                  addIDITagValue (strIDI, I_ ("FROM"), fromCurrency);
                  addIDITagValue (strIDI, I_ ("TO"), toCurrency);
                  ADDCONDITIONFROMFILEIDI (CND::ERR_FROM_TO_CURRENCIES_DO_NOT_MATCH, strIDI);
               }
            } //non-multi currency environment

            if (GETCURRENTHIGHESTSEVERITY () <= WARNING)
            {
               //validate if the from funds are allowed to be 
               //traded/exchanged against the to funds 
               BFObjIter iter1 ( *pTradeFromFundAllocList, 
                                 idDataGroup, false, 
                                 BFObjIter::ITERTYPE::NON_DELETED);
               DString fromFund, 
                  fromClass; 
            
               iter1.begin ();
               while (!iter1.end ())
               {
                  iter1.getObject ()->getField (ifds::FundCode, fromFund, idDataGroup, false);
                  iter1.getObject ()->getField (ifds::ClassCode, fromClass, idDataGroup, false);
                  if (!fromFund.empty() && !fromClass.empty())
                  {                
                     BFObjIter iter2 ( *pTradeToFundAllocList, 
                                       idDataGroup, 
                                       false, 
                                       BFObjIter::ITERTYPE::NON_DELETED);
                     DString toFund, 
                        toClass;

                     iter2.begin ();
                     while (!iter2.end ())
                     {
                        iter2.getObject ()->getField (ifds::FundCode, toFund, idDataGroup, false);
                        iter2.getObject ()->getField (ifds::ClassCode, toClass, idDataGroup, false);
                        if (!toFund.empty() && !toClass.empty())
                        {
                           FundToList fundToList (*this);

                           if ( !fundToList.isTransferAllowed ( fromFund, 
                                                               fromClass, 
                                                               toFund, 
                                                               toClass)
                              )
                           {
                              DString strIDI;

                              addIDITagValue (strIDI, I_("FromFund"), fromFund);
                              addIDITagValue (strIDI, I_("FromClass"), fromClass);
                              addIDITagValue (strIDI, I_("ToFund"), toFund);
                              addIDITagValue (strIDI, I_("ToClass"), toClass);
                              ADDCONDITIONFROMFILEIDI (CND::ERR_TRANSFER_NOT_ALLOWED, strIDI);
                              break;
                           }
                        }
                        ++iter2;
                     }               
                  }
                  if (GETCURRENTHIGHESTSEVERITY () > WARNING) //if an error exit anyhow
                  {
                     break;
                  }
                  ++iter1;
               }
            }
         }
      }

      if (isAIPAllowed (idDataGroup))
      {
         validateAIPEntity (idDataGroup);
      }
      //P0185010.FN02.R02.01 - Delivering EAP written notice and tax info return
      else if(isEAPAllowed(idDataGroup))
      {
         validateEAPEntityAddress(idDataGroup);
      }
      //--
      else
      {
         DString strSubstVal, strLinkedEntityId;
         BFProperties *pBFProperties = getFieldProperties (ifds::LinkedEntityId, idDataGroup);
         pBFProperties->getAllSubstituteValues (strSubstVal);
         if ( !strSubstVal.strip().empty() &&
            strSubstVal != I_("0=N/A;"))
         {
            getField( ifds::LinkedEntityId, strLinkedEntityId, idDataGroup, false );
            if (strLinkedEntityId.strip().empty() ||
               strLinkedEntityId == I_("0"))
            {
               ADDCONDITIONFROMFILE (CND::WARN_ASSOCIATED_ENTITY_NOT_PROVIDED);
            }
         }
      }

      WorksessionTradesList *pWorksessionTradesList = NULL;

      if (getWorkSession().getTradesList (pWorksessionTradesList, idDataGroup) <= WARNING && 
         pWorksessionTradesList)
      {
         DString autoBatching;

         getWorkSession ().getOption (ifds::AutoBatch, autoBatching, idDataGroup, false);
         if( autoBatching.asInteger () == AUTO_BATCHING )
         {
            DString batchName;

            getField (ifds::BatchName, batchName, idDataGroup, false);

            pWorksessionTradesList->setBatchName (batchName);
         }
      }

      if (!isNew()) //for pending trades...
      {
         validateClosedCountryForPendingTrades (idDataGroup);
      }

      validateBankVerifyStatus (idDataGroup);

      validateTUP (idDataGroup);

      validateRESPTrade(idDataGroup);

      if(isPSEEAPAllowed (idDataGroup) && isTradeOnOrAfterPSEEAPEditDate (idDataGroup))
      {
         DString dstrPSEProgramLenList, dstrPSEProgramTypeList, dstrPSEProgramYearList;
         getField(ifds::PSEProgramLenList, dstrPSEProgramLenList, idDataGroup, false);
         getField(ifds::PSEProgramTypeList, dstrPSEProgramTypeList, idDataGroup, false);
         getField(ifds::PSEProgramYearList, dstrPSEProgramYearList, idDataGroup, false);

         if(dstrPSEProgramLenList.empty())
         {
            ADDCONDITIONFROMFILE(CND::ERR_PSE_LEN_INVALID);
         }
         else if(dstrPSEProgramTypeList.empty())
         {
            ADDCONDITIONFROMFILE(CND::ERR_PSE_TYPE_INVALID);
         }
         else if(dstrPSEProgramYearList.empty())
         {
            ADDCONDITIONFROMFILE(CND::ERR_PSE_YEAR_INVALID);
         }
      }
      // validate Don't bust the rules project
      validateSegTrx(idDataGroup);
	  DString dstrTransType;
	  getField(ifds::TradesTransType, dstrTransType, idDataGroup, false);
  
	  if( (dstrTransType == I_("XR")) && (hasAllocations(idDataGroup)) )
	  {
		  validateSegExch(idDataGroup);
	  }

      if (isOneSideTrade (idDataGroup))
      {
         validateAllSegTransfer(idDataGroup);
      }
      DString dstrEventReceiptDate,dstrEventReceiptTime;
      bool bEventReceiptDateTimeAppl = bIsEventReceiptDateTimeAppl(idDataGroup);
      getField(ifds::EventReceiptDate, dstrEventReceiptDate, idDataGroup, false);
      getField(ifds::EventReceiptTime, dstrEventReceiptTime, idDataGroup, false);
      if(dstrEventReceiptDate.stripAll().empty() && dstrEventReceiptTime.stripAll().empty()&&
         bEventReceiptDateTimeAppl	&&	GETCURRENTHIGHESTSEVERITY() <= WARNING ) //Display the warning first and assign the systime and date.
      {
         getErrMsg ( IFASTERR::EVENT_RECIEPT_DATE_AND_TIME_EMPTY,
                     CND::ERR_EVENT_RECIEPT_DATE_AND_TIME_EMPTY,
                     CND::WARN_EVENT_RECIEPT_DATE_AND_TIME_EMPTY,
                     idDataGroup); 
      }
   }

   if(isGIInvestmentListApplicable(idDataGroup))
   {
      GIInvestmentDetailsList* pGIInvestmentDetailsList = NULL;
      getGIInvestmentDetails ( pGIInvestmentDetailsList, idDataGroup, true);
      if(pGIInvestmentDetailsList)
         pGIInvestmentDetailsList->validateAll(idDataGroup, 0);

   }

   if (isSegEnvironment (idDataGroup))
   {
	   validateAnnuitantGender(idDataGroup);
   }

   //do from first and if no error then to
   if( WARNING >= doSIFRegulationSpecificValidations(idDataGroup, FROM_TO::FROM ))
       doSIFRegulationSpecificValidations(idDataGroup, FROM_TO::TO );

   validatePSEInformation (idDataGroup, MYFRAME()); 

   validateCashDateMandatory (idDataGroup);

   validateUnusualTrading (idDataGroup);
   validateSuspendedFund (idDataGroup);
   DString dstrTransType;
   getField (ifds::TradesTransType, dstrTransType, idDataGroup);
   dstrTransType.stripAll().upperCase();
   if(dstrTransType == TRADETYPE::REFUND_REDEMPTION)
      revalidateField (ifds::MinFromFundAmount, idDataGroup);//Forcing VEW167 call

   validateRDSPTrade (idDataGroup);

   return GETCURRENTHIGHESTSEVERITY ();
}

//validation methods,
//account validation
//******************************************************************************
SEVERITY Trade::canAccountTrade ( MFAccount *pMFAccount, 
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("canTradeAccount"));

   DString taxType;

   pMFAccount->getField (ifds::TaxType, taxType, idDataGroup);
   if (DSTCommonFunctions::codeInList (taxType, I_("9,M")))     //RESP,family RRSP
   {
      if (isNew ())
      {
         getErrMsg ( IFASTERR::TRADING_ON_RESPACCT_NOT_ALLOWED, 
                     CND::ERR_RESP_TRADE_NOT_ALLOW, 
                     CND::WARN_RESP_TRADE_NOT_ALLOW, 
                     idDataGroup); 
      }

      DString respAcctInfoExist;
      pMFAccount->getField (ifds::RESPAcctInfoExists, respAcctInfoExist, idDataGroup, false);
      respAcctInfoExist.strip().upperCase();
      
      if (respAcctInfoExist != I_("Y"))
      {
         ADDCONDITIONFROMFILE (CND::ERR_RESP_ACCOUNT_INFO_MISSING);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateAccountNum ( const DString &accountNum,
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAccountNum"));

   DString accountNum_ (accountNum);

   if (accountNum_.strip().empty() || !accountNum_.isAllDigits())
   {
      ADDCONDITIONFROMFILE (CND::ERR_INVALID_ACCOUNT_NUMBER);
   }
   else
   {
//get the AccShrNumCheck
      AccShrNumCheck *pAccShrNumCheck = NULL;

      if ( getAccShrNumCheck ( accountNum_,
                               pAccShrNumCheck,
                               idDataGroup) <= WARNING &&
           pAccShrNumCheck)
      {
         DString dataFound;
   
         pAccShrNumCheck->getField (ifds::DataFound, dataFound, BF::HOST, false);
         if (dataFound.strip() != Y)
         {
            ADDCONDITIONFROMFILE (CND::ERR_INVALID_ACCOUNT_NUMBER);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateAccount ( MFAccount *pMFAccount, 
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAccount"));
   DString accountNum;

   validateClearingAccount (pMFAccount, idDataGroup);
   pMFAccount->getField (ifds::AccountNum, accountNum, idDataGroup, false);
// Following logic is based on the rule in RIF/LIF/LRIF Functionality version 2.0 (Angela Kapetanios)
// Desktop will provide a warning message to the user when they attempt to process a Trade
// (Redemption is a exception, it has specific logic) where the Birth Date information is
// missing for the supported Registered Products, and also when the 'Spousal Birth Date' 
// information is missing for a LIFs, LRIFs and RRIFs.
   DString taxType;

   pMFAccount->getField (ifds::TaxType, taxType, idDataGroup, false);
   taxType.upperCase ();
   bool bIsLIFLike = getWorkSession ().isLIFLike (taxType);
   bool bIsLIRALike = getWorkSession ().isLIRALike (taxType);
   if (bIsLIFLike || bIsLIRALike || DSTCommonFunctions::codeInList (taxType, I_("1,2,L,R"))) //RRSP,RRIF,LIF,LRIF,LIRA,PRIF
   {
      DString accHldDofB;

      pMFAccount->getDofBirthofOwnerSeq01 (accHldDofB, idDataGroup);
      if (accHldDofB.empty())
      {
         if (!isRedemptionLike (idDataGroup))
         {
            ADDCONDITIONFROMFILE (CND::ERR_WARN_ACCTHOLDER_BIRTHDAY_MISSING);
         }
         else
         {
            // for the Redemption, error or warnning base on user's setup in the error table
            bool bIsLIFLike = getWorkSession ().isLIFLike (taxType);
            bool bIsLIRALike = getWorkSession ().isLIRALike (taxType);

            if (bIsLIFLike || bIsLIRALike || DSTCommonFunctions::codeInList (taxType, I_("2,L,R"))) //RRIF,LIF,LRIF,LIRA,PRIF
            {
               getErrMsg ( IFASTERR::ACCOUNT_HOLDERS_BIRTH_DATE_IS_MISSING, 
                           CND::ERR_ACCTHOLDER_DOFB_MISSING, 
                           CND::ERR_WARN_ACCTHOLDER_BIRTHDAY_MISSING, 
                           idDataGroup); 
            }
         }
         // in the case of account holder's birth date is missing, the spouse birth date
         // should be checked for LIF, RRIF and LRIF I_("2,B,BR, L,R")(Redemption is an expection)
         if (getWorkSession ().isIntRIFPlan (taxType)) 
         {
//get the AccShrNumCheck
            AccShrNumCheck *pAccShrNumCheck = NULL;

            if ( getAccShrNumCheck ( accountNum,
                                     pAccShrNumCheck,
                                     idDataGroup) <= WARNING &&
                 pAccShrNumCheck)
            {
               DString spouseBirth;

               pAccShrNumCheck->getField (ifds::SpouseBirth, spouseBirth, idDataGroup, false);
               if (spouseBirth.empty())
               {
                  if (!isRedemptionLike (idDataGroup))
                  {
                     ADDCONDITIONFROMFILE (CND::ERR_WARN_SPOUSE_BIRTHDAY_MISSING);
                  }
                  else
                  {
                     // only LIF account holder's spousal birth date need to be check for Redemption
                     if (getWorkSession ().isLIFLike (taxType)) //LIF
                     {
                        getErrMsg ( IFASTERR::BIRTH_DATE_OF_ACCOUNT_HOLDER_OR_SPOUSE_IS_MISSING, 
                                    CND::ERR_SPOUSE_BIRTHDAY_MISSING, 
                                    CND::ERR_WARN_SPOUSE_BIRTHDAY_MISSING, 
                                    idDataGroup); 
                     }
                  }
               }
            } 
         } 
      } // end of {if (accHldDofB.strip () == NULL_STRING}
   }
//extra checks
   DString cotClient;

   getWorkSession ().getOption ( ifds::CotClient, 
                                 cotClient, 
                                 BF::HOST, 
                                 false);
   if (cotClient == Y)
   {
      DString deathStat, 
         deathClaim;

      pMFAccount->getField (ifds::DeathStat, deathStat, idDataGroup, false);
      deathStat.upperCase();
      pMFAccount->getField (ifds::DeathClaim, deathClaim, idDataGroup, false);
      deathClaim.upperCase();

      if ( deathStat == Y) // || deathClaim == Y)
      {
         getErrMsg ( IFASTERR::CONTRACT_ACCOUNT_STATUS_IS_DEATH_STATUS, 
                     CND::ERR_CONTRACT_ACCT_STATUS_INACTIVE, 
                     CND::ERR_WARN_CONTRACT_ACCT_STATUS_INACTIVE, 
                     idDataGroup);   
      }
   }
   //For Manulife
   //If account level split commission does not exist trading is not allowed.
   DString acctCommExists;

   pMFAccount->getField (ifds::AcctCommExists, acctCommExists, idDataGroup);
   if ( SplitCommission::isTypeTWO (getWorkSession ()) && 
        acctCommExists == N) 
   {
      ADDCONDITIONFROMFILE (CND::ERR_TRADING_NOT_ALLOWED_WITHOUT_ACCT_SPLIT_COMM);
   }
//   validateClearingAccount (pMFAccount, idDataGroup); - as of Incident 943174
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline SEVERITY Trade::canAccountToTrade ( MFAccount *pMFAccount, 
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("canAccountToTrade"));

   DString taxType;

   pMFAccount->getField (ifds::TaxType, taxType, idDataGroup);
   if (DSTCommonFunctions::codeInList (taxType, I_("9,M")))     //RESP,family RRSP
   {
      if (isNew())
      {
         getErrMsg (IFASTERR::TRADING_ON_RESPACCT_NOT_ALLOWED, 
                    CND::ERR_RESP_TRADE_NOT_ALLOW, 
                    CND::WARN_RESP_TRADE_NOT_ALLOW, 
                    idDataGroup); 
      }

      DString respAcctInfoExist;
      pMFAccount->getField (ifds::RESPAcctInfoExists,respAcctInfoExist, idDataGroup, false);
      respAcctInfoExist.strip().upperCase();
      
      if (respAcctInfoExist != I_("Y"))
      {
         ADDCONDITIONFROMFILE (CND::ERR_RESP_ACCOUNT_INFO_MISSING);
      }
   }

//method implemented in Rollover/Transfer
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline SEVERITY Trade::validateAccountTo ( MFAccount *pMFAccountTo, 
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAccountTo"));
//method implemented in Rollover/Transfer
   validateClearingAccount (pMFAccountTo, idDataGroup);
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateClearingAccount ( MFAccount *pMFAccount, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateClearingAccount"));

   assert (pMFAccount);
//cannot trade clearing account if no settlement location has been set
   if ( pMFAccount->isClearingAcount (idDataGroup) && 
        !pMFAccount->hasSettlementLocation (idDataGroup))
   {
      // "No Settlement Location has been setup for this Clearing Account."
      ADDCONDITIONFROMFILE (CND::ERR_TRADING_SETTLEMENT_LOCATION_HAS_NOT_BEEN_SETUP_FOR_CLEARING_ACCOUNT);
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//fund validation
//******************************************************************************
inline SEVERITY Trade::validateFundCode ( const DString &fundCode, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundCode"));
//method implemented in Purchase/Rollover/Transfer
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline SEVERITY Trade::validateToFundCode ( const DString &fundCode, 
                                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateToFundCode"));
//method implemented in Rollover
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateSegBackdates (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateSeqBackdates"));

   DString fundCode, classCode, transType;
   DString accountNum, tradeDate;

   SeqFundValidation *pSeqFundValidation = NULL;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   if (!accountNum.empty ())
   {
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::EffectiveDate, tradeDate, idDataGroup);
      getField (ifds::FromFund, fundCode, idDataGroup, false);
      getField (ifds::FromClass, classCode, idDataGroup, false);

      if (isBackdatedTrade (idDataGroup))
      {
         if (hasAllocations (idDataGroup))
         {
            TradeFundAllocList *pTradeFundAllocList = NULL;

            if (getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING && pTradeFundAllocList)
            {
               TradeFundAlloc *pTradeFundAlloc = NULL;
               BFObjIter iter (*pTradeFundAllocList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

               while (!iter.end ()) 
               {
                  pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());

                  if (pTradeFundAlloc)
                  {
                     pTradeFundAlloc->getField (ifds::FundCode, fundCode, idDataGroup);
                     pTradeFundAlloc->getField (ifds::ClassCode, classCode, idDataGroup);

                     if (getSegFundValidation ( pSeqFundValidation, fundCode, classCode, 
                                                accountNum, tradeDate, idDataGroup, 
                                                NULL_STRING, transType, NULL_STRING, 
                                                NULL_STRING, NULL_STRING) <= WARNING && pSeqFundValidation)
                     {
                        if (pSeqFundValidation->checkBackdatedAllowed (tradeDate, idDataGroup) > WARNING)
                        {
                           break;
                        }
                     }

                     DString transId;
                     getField (ifds::TransId, transId, idDataGroup,false);

                     // view 436
                     if( validateFromSegTradeEntryCheck(accountNum,
                                                        fundCode,
                                                        classCode,
                                                        tradeDate,
                                                        transType,
                                                        transId,
                                                        idDataGroup) > WARNING )
                     {
                        break;
                     }
                  }
                  ++iter;
               }//while
            }
         }
         else
         {
            if (getSegFundValidation ( pSeqFundValidation, fundCode, classCode, 
                                       accountNum, tradeDate, idDataGroup, 
                                       NULL_STRING, transType, NULL_STRING, 
                                       NULL_STRING, NULL_STRING) <= WARNING && pSeqFundValidation)
            {
               pSeqFundValidation->checkBackdatedAllowed (tradeDate, idDataGroup);
            }

            DString transId;
            getField (ifds::TransId, transId, idDataGroup,false);

            // view 436
            validateFromSegTradeEntryCheck(accountNum,
                                          fundCode,
                                          classCode,
                                          tradeDate,
                                          transType,
                                          transId,
                                          idDataGroup);
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateClassCode ( const DString &fundCode, 
                                    const DString &classCode, 
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateClassCode"));

   FundDetail *pFundDetail = NULL;

   if ( !fundCode.empty() && !classCode.empty() &&
        !getWorkSession().getFundDetail ( fundCode, 
                                          classCode, 
                                          idDataGroup, 
                                          pFundDetail) ||
        !pFundDetail)
   {
      ADDCONDITIONFROMFILE (CND::ERR_INVALID_FUND_CLASS_CODES);
   }
   else if (!fundCode.empty() && !classCode.empty())
   {
      DString currency,
         sysCurrency;

      pFundDetail->getField (ifds::Currency, currency, idDataGroup);
      getWorkSession ().getOption ( ifds::SysCurrency, 
                                    sysCurrency, 
                                    BF::HOST,
                                    false);
      currency.strip ().upperCase ();
      sysCurrency.strip ().upperCase ();
      if (currency != sysCurrency)
      {
         DString idiStr, 
            currencyName, 
            transNum;
         
         pFundDetail->getField (ifds::Currency, currencyName, idDataGroup, true);
         getField (ifds::TransNum, transNum, idDataGroup);
         addIDITagValue (idiStr, I_("FUND"), fundCode);
         addIDITagValue (idiStr, I_("CLASS"), classCode);
         addIDITagValue (idiStr, I_("TRANS_NUM"), transNum);
         addIDITagValue (idiStr, I_("FOREIGN_CURRENCY"), currencyName);

		 getErrMsg (IFASTERR::FUND_IN_FOREIGN_CURRENCY,
			        CND::ERR_ERR_FUND_IN_FOREIGN_CURRENCY,
				    CND::ERR_WARN_FUND_IN_FOREIGN_CURRENCY,
				    idDataGroup,
				    idiStr);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//****************************************************************************** 
SEVERITY Trade::validateFundClass (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundClass"));

   DString fundCode,
      classCode,
      accountNum;

   getField (ifds::FromFund, fundCode, idDataGroup);
   getField (ifds::FromClass, classCode, idDataGroup);
   getField (ifds::AccountNum, accountNum, idDataGroup);
   accountNum.stripLeading ('0').strip ();
   if (!accountNum.empty() &&
       !fundCode.empty() &&
       !classCode.empty())
   {
      validateFundClass ( fundCode,
                          classCode,
                          accountNum,
                          idDataGroup);

      validateMasterActAMS(idDataGroup);

      if( WARNING >=  GETCURRENTHIGHESTSEVERITY() )
      {
          doSIFRegulationSpecificValidations(idDataGroup, FROM_TO::FROM );
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//****************************************************************************** 
SEVERITY Trade::validateMasterActAMS(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateMasterActAMS"));

   return GETCURRENTHIGHESTSEVERITY ();
}

//****************************************************************************** 
SEVERITY Trade::validateFundClass ( const DString &fundCode, 
                                    const DString &classCode, 
                                    const DString &accountNum, 
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundClass"));

   return GETCURRENTHIGHESTSEVERITY ();
}

//****************************************************************************** 
SEVERITY Trade::validateToFundClass (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateToFundClass"));

   DString fundCode,
      classCode,
      accountNum;

   getField (ifds::ToFund, fundCode, idDataGroup);
   getField (ifds::ToClass, classCode, idDataGroup);
   getField (ifds::AccountTo, accountNum, idDataGroup);
   validateToFundClass ( fundCode,
                         classCode,
                         accountNum,
                         idDataGroup);

   validateMasterActAMS(idDataGroup);

   if( WARNING >=  GETCURRENTHIGHESTSEVERITY() )
   {
       doSIFRegulationSpecificValidations(idDataGroup, FROM_TO::TO );
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateToFundClass ( const DString &fundCode, 
                                      const DString &classCode, 
                                      const DString &accountNum, 
                                      const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateToFundClass"));
   Trade::validateFundClass ( fundCode,
                              classCode,
                              accountNum,
                              idDataGroup);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateFromToFundClass (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFromToFundClass"));
   DString fromFund,
      fromClass,
      toFund,
      toClass;

   getField (ifds::FromFund, fromFund, idDataGroup, false);
   getField (ifds::FromClass, fromClass, idDataGroup, false);
   getField (ifds::ToFund, toFund, idDataGroup, false);
   getField (ifds::ToClass, toClass, idDataGroup, false);
   if ( !fromFund.empty() &&
        !fromClass.empty() &&
        !toFund.empty() &&
        !toClass.empty())
   {
      validateFromToFundClass ( fromFund,
                                fromClass,
                                toFund,
                                toClass,
                                idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//********************************************************************************************
inline SEVERITY Trade::validateFromToFundClass ( const DString &fromFund,
                                                 const DString &fromClass,
                                                 const DString &toFund,
                                                 const DString &toClass,
                                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFromToFundClass"));
   return GETCURRENTHIGHESTSEVERITY();
}

//**********************************************************
SEVERITY Trade::validatePUEVCapableFund ( const DString &fundCode, 
                                          const DString &accountNum, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validatePUEVCapableFund"));
   //check if the account is PUEV capbale
   //get account category list for category '09'
   
   if ( accountHasCategory( I_("09"), idDataGroup ) )
   {
      //check if fund is PUEV capable
      FundMasterList *pFundMasterList = NULL;
     if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
          pFundMasterList)
      {
         if (!pFundMasterList->isPUEVCapableFund (fundCode))
         {
            ADDCONDITIONFROMFILE (CND::ERR_FUND_NOT_PUEV_CAPABLE);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::validateAMSTradeViaParentFundClass ( const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAMSTradeViaParentFundClass"));

   /*
      The validation for AMS Model C.
      - For Purchase, the fund class must be a parent or child funds.
      - For Redemption, the fund class must not be other parent fnd/cls of AMS plans that an account hasn't been attached to.
      - Transfer/Exchange, Cannot do TI/EI for parent fund/class will be validated by stop transfer/exchange.
                           As parent fund/class will have stop Transfer/Exchange.
                           So the fund class must be child funds.
   */

   bool bIsMasterActWithOneChild = getWorkSession().isMasterActWithOneChild(idDataGroup);

   // In the master account with one child environment, it support money-in with non-ams fund
   // even when account attached with AMS record (either global or account level)
   // while master account with multiple children environment won't.

   if( isAMSTradeViaParentFundClass(idDataGroup) )
   {
      BFFieldId acctFieldId, fundFieldId, classFieldId;
      DString accNum, fundCode, classCode;
      bool bErrMsgOnlyChild = false;

      if ( isPurchase(idDataGroup) || isRedemption(idDataGroup))
      {
         getField(ifds::AccountNum, accNum, idDataGroup, false);
         getField(ifds::FromFund, fundCode, idDataGroup, false);
         getField(ifds::FromClass, classCode, idDataGroup, false);
      }
      else if ( isTransfer (idDataGroup) || isExchange (idDataGroup) || isInterClassSwitch(idDataGroup))
      {
         bErrMsgOnlyChild = true;
         getField(ifds::AccountTo, accNum, idDataGroup, false);
         getField(ifds::ToFund, fundCode, idDataGroup, false);
         getField(ifds::ToClass, classCode, idDataGroup, false);
      }
      else
         return GETCURRENTHIGHESTSEVERITY();

      MFAccount *pMFAccount = NULL;
      if ( getWorkSession().getMFAccount ( idDataGroup, accNum, pMFAccount) <= WARNING &&
         pMFAccount )
      {
         // get AMS info and AMS alloc to validate the fund class 
         // if it is Parent or child underlying the AMS.
         AmsMstrInfo* pAMSMstrInfo = NULL;
         AMSMstrList* pAMSMstrList = NULL;
         FundDetail *pFundDetail = NULL;
         DString dstrAMSCode, dstrTradeDate, dstrAssocFund, dstrAssocClass;
         bool bFound = false;

         getField(ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);

         if ( pMFAccount->getAMSMstrList ( pAMSMstrList, 
                                           idDataGroup, 
                                           dstrTradeDate) <= WARNING &&
                                           pAMSMstrList )
         {
            pMFAccount->getField (ifds::AMSCode, dstrAMSCode, idDataGroup, false);
            pAMSMstrList->getAMSMstrInfo ( I_("RB"),
                                           dstrAMSCode, 
                                           dstrTradeDate, 
                                           pAMSMstrInfo, 
                                           idDataGroup );
            if (pAMSMstrInfo)
            {
               // check if the fund is Parent fund or not.
               pAMSMstrInfo->getField(ifds::AssocFund, dstrAssocFund, idDataGroup, false);
               pAMSMstrInfo->getField(ifds::AssocClass, dstrAssocClass, idDataGroup, false);

               if ((dstrAssocFund != fundCode) || (dstrAssocClass != classCode))				   
               {
                  // 1. If fund/class is not a parent fnd/cls of other AMS plans, ALLOW.
                  // 2. If fund/class is a parent fnd/cls of other AMS plans, DO NOT ALLOW.

                  if (isRedemption(idDataGroup) && 
                     getWorkSession().getFundDetail(fundCode, classCode, idDataGroup, pFundDetail) && pFundDetail)
                  {
                     DString dstrAMSModelType;
                     pFundDetail->getField(ifds::AMSModelType, dstrAMSModelType, idDataGroup, false);

                     if (dstrAMSModelType == MODEL_PARENT_FUND_CLASS )
                     {
                        DString idiStr;
                        addIDITagValue (idiStr, I_("AMSCODE"), dstrAMSCode);
                        ADDCONDITIONFROMFILEIDI (CND::ERR_FUND_CLASS_MUST_BE_PARENT, idiStr);
                     }
                  }
                  else
                  {
                     // This is not Parent fund class, check child fund underlying AMS.
                     AmsFundAllocList *pAMSFundAllocList = NULL;
                     DString dstrFundAlloc, dstrChildFund, dstrChildClass, dstrLevel;

                     pAMSMstrInfo->getField(ifds::FundAlloc, dstrFundAlloc, idDataGroup, false);

                     if (dstrFundAlloc == YES)
                     {
                        pMFAccount->getAMSFundAllocList ( I_("RB"), 
                           dstrTradeDate, 
                           pAMSFundAllocList, 
                           idDataGroup );

                        BFObjIter iter ( *pAMSFundAllocList, 
                           idDataGroup, 
                           false, 
                           BFObjIter::ITERTYPE::NON_DELETED );	

                        AmsFundAlloc *pAMSFundAlloc = NULL;
                        /*
                        This means user modify fund/class after parent fund/class has been set.
                        */
                        if (!fundCode.empty() && !classCode.empty())
                        {
                           while (!iter.end ()) 
                           {
                              pAMSFundAlloc = dynamic_cast <AmsFundAlloc*> (iter.getObject ());

                              pAMSFundAlloc->getField (ifds::FundCode, dstrChildFund, idDataGroup);
                              pAMSFundAlloc->getField (ifds::ClassCode, dstrChildClass, idDataGroup);

                              if ( (dstrChildFund == fundCode) && (dstrChildClass == classCode) )
                              {
                                 bFound = true;
                                 break;
                              }
                              ++iter;
                           }
                        }
                        else
                        {
                           /*
                           Fund/class are blank, meaning users set up allocation for trade.
                           */
                           TradeFundAllocList *pTradeFundAllocList;
                           TradeFundAlloc *pTradeFundAlloc;
                           bErrMsgOnlyChild = true;

                           if ( getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING &&
                              pTradeFundAllocList )
                           {

                              BFObjIter iterTradeAlloc ( *pTradeFundAllocList, 
                                 idDataGroup, 
                                 false, 
                                 BFObjIter::ITERTYPE::NON_DELETED );	
                              DString dstrTradeAllocFund, dstrTradeAllocClass;

                              while (!iterTradeAlloc.end ()) 
                              {
                                 pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iterTradeAlloc.getObject ());
                                 pTradeFundAlloc->getField (ifds::FundCode, dstrTradeAllocFund, idDataGroup);
                                 pTradeFundAlloc->getField (ifds::ClassCode, dstrTradeAllocClass, idDataGroup);
                                 dstrTradeAllocFund.strip().upperCase();
                                 dstrTradeAllocClass.strip().upperCase();

                                 while (!iter.end ()) 
                                 {
                                    bFound = false;
                                    pAMSFundAlloc = dynamic_cast <AmsFundAlloc*> (iter.getObject ());

                                    pAMSFundAlloc->getField (ifds::FundCode, dstrChildFund, idDataGroup);
                                    pAMSFundAlloc->getField (ifds::ClassCode, dstrChildClass, idDataGroup);
                                    dstrChildFund.strip().upperCase();
                                    dstrChildClass.strip().upperCase();

                                    if ( (dstrChildFund == dstrTradeAllocFund) && (dstrChildClass == dstrTradeAllocClass) )
                                    {
                                       /*
                                       If trade allocation funds are valid,
                                       bFound should be set to yes every
                                       repetition. One record in repeat means 1 alloc fund.
                                       */
                                       bFound = true;
                                       break;
                                    }
                                    ++iter;
                                 }
                                 /*
                                 If any funds in trade allocation does not match the 
                                 AMS Allocation funds, do not need to check others.
                                 We can raise the error then.
                                 */
                                 if (bFound == false)

                                    break;
                                 ++iterTradeAlloc;
                              }
                           }
                        }
                     }

                     if (!bFound && !bIsMasterActWithOneChild)
                     {
                        /* Should be purchase or transfer/exchange here, so "else" would be ex/tr */
                        DString idiStr;
                        addIDITagValue (idiStr, I_("AMSCODE"), dstrAMSCode);

                        if (!bErrMsgOnlyChild)
                        {
                           ADDCONDITIONFROMFILEIDI(CND::ERR_FUND_CLASS_MUST_BE_PARENT_CHILD, idiStr);
                        }
                        else 
                        {
                           // Transfer/Exchange or Allocation for Purchase.
                           if (!allowToFndClsBeParentAMS(idDataGroup))
                              ADDCONDITIONFROMFILEIDI(CND::ERR_FUND_CLASS_MUST_BE_CHILD, idiStr);
                        }
                     }
                  } // end check Parent Fund/Class
               }
            }	// end pAMSMstrInfo
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::allowToFndClsBeParentAMS(const BFDataGroupId &idDataGroup)
{
    return false;
}

//******************************************************************************
SEVERITY Trade::validateInvestroCapableFund ( const DString &fundCode, 
                                              const DString &accountNum, 
                                              const BFDataGroupId &idDataGroup)
{
//called in validateFundCode, by Redemption/Purchase   
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateInvestroCapableFund"));
   DString fundBrokerApplicable;

   getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                fundBrokerApplicable,
                                BF::HOST,
                                false);

   if (fundBrokerApplicable == Y)
   {
      FundMasterList *pFundMasterList = NULL;
      if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
           pFundMasterList)
      {
         //check if fund is Investro capable,
         //it only applies for 3rd party funds
         if ( pFundMasterList->is3rdPartyFund (fundCode) && 
              pFundMasterList->isInvestroCapableFund (fundCode))
         {
            //check if default fund broker is investro capable
            DString routingType;

            if (getFundBrokerRoutingType (accountNum, fundCode, routingType, idDataGroup) <= WARNING)
            {
               if (routingType != I_("02")) //not investro capable
               {
                  DString defaultBrokerCode,
                     idiStr,dstrFdBrokerDefaultLevel;
                  
                  getDefaultFundBrokerCode (accountNum, fundCode, defaultBrokerCode,dstrFdBrokerDefaultLevel, idDataGroup);
                  addIDITagValue (idiStr, I_("fund"), fundCode);
                  addIDITagValue (idiStr, I_("fundbroker"), defaultBrokerCode);
                  getErrMsg ( IFASTERR::FUND_INVESTRO_CAPABLE_WHILE_FUND_BROKER_IS_NOT,
                              CND::ERR_FUND_INVESTRO_CAPABLE_WHILE_FUND_BROKER_IS_NOT, 
                              CND::WARN_FUND_INVESTRO_CAPABLE_WHILE_FUND_BROKER_IS_NOT, 
                              idDataGroup, idiStr);
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::canFundTrade ( const DString &broker,
                               const DString &branch,
                               const DString &agent,
                               const DString &transType,
                               const DString &accountNum,
                               const DString &fundCode,
                               const DString &classCode,
                               long lErrorId,
                               long lWarnId,
                               const BFDataGroupId &idDataGroup,
                               bool bCheckBrokerPermits) /*=false*/ //flag is set to true by purchases/rollovers
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("canFundTrade"));
   MFAccount *pMFAccount = NULL;

   if ( getWorkSession().getMFAccount ( idDataGroup, 
                                        accountNum, 
                                        pMFAccount) <= WARNING && 
        pMFAccount)
   {
      DString brokerPermits;

      if (!fundCode.empty() && !classCode.empty())
      {
         if ( validateBrokerFund ( broker, 
                                   transType, 
                                   accountNum, 
                                   fundCode, 
                                   classCode, 
                                   brokerPermits, //retrieve also the value of AddPerm, just in case
                                   idDataGroup) <= WARNING &&
              validateAgentFund  ( broker,
                                   branch,
                                   agent,
                                   transType, 
                                   accountNum, 
                                   fundCode, 
                                   classCode, 
                                   idDataGroup) <= WARNING)
         {
            DString tradeDate;
            DString transType_ (transType);

            getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
   //unfortunately this is necessary, due to the inconsistency of request codes
            if ( transType == TRADETYPE::TRANSFER_OUT ||
                 transType == TRADETYPE::EXCHANGE_OUT ||
                 transType == TRADETYPE::INTER_CLASS_SWITCH_OUT)
            {
               transType_ = I_("XFOUT");  // transfer/exchange out code, for fund/account validation
            }
            else if ( transType == TRADETYPE::TRANSFER_IN ||
                      transType == TRADETYPE::EXCHANGE_IN ||
                      transType == TRADETYPE::INTER_CLASS_SWITCH_IN)
            {
               transType_ = I_("XFIN");  // transfer/exchange out code, for fund/account validation
            }
            if (pMFAccount->canTradeFundClass ( fundCode, 
                                                classCode, 
                                                transType_, 
                                                tradeDate, 
                                                idDataGroup) <= WARNING)
            {
               bool bStopFlag (false);
               bool bErrorSeverity (true);
               if(isTradeLevelOverrideRuleApplicable(transType, idDataGroup)) //For applicable environment use new 462 view call logic
               {   
                DString dstrEffectiveDate;
                TradeLevelOverrideRules tradeLevelOverrideRules(*this);
                getField (ifds::EffectiveDate, dstrEffectiveDate, idDataGroup, false);
                if( transType == TRADETYPE::EXCHANGE_IN ||
                    transType == TRADETYPE::INTER_CLASS_SWITCH_IN ||
                    transType == TRADETYPE::TRANSFER_IN )//Send the to broker,branch,slsrep code
                    { 
                    MFAccount *pMFAccountTo = NULL;
                    DString dstrToBroker, dstrToBranch, dstrToRep;
                    if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccountTo) <= WARNING &&
                        pMFAccountTo)
                        {
                        pMFAccountTo->getField (ifds::BrokerCode, dstrToBroker, idDataGroup); 
                        pMFAccountTo->getField (ifds::BranchCode, dstrToBranch, idDataGroup);
                        pMFAccountTo->getField (ifds::Slsrep, dstrToRep, idDataGroup);
                        }
                        tradeLevelOverrideRules.init(accountNum, fundCode, classCode, transType,
                                                    dstrEffectiveDate, dstrToBroker, dstrToBranch, dstrToRep );
                    }
                    else
                    {
                        tradeLevelOverrideRules.init(accountNum, fundCode, classCode, transType,
                                                    dstrEffectiveDate, broker, branch, agent );
                    }
                tradeLevelOverrideRules.addConditions(idDataGroup);
               }
               else
               {

               readStopFlag ( transType, 
                              fundCode, 
                              classCode, 
                              accountNum, 
                              bStopFlag, 
                              bErrorSeverity, 
                              idDataGroup);
               if (bStopFlag) //raise error/warning if stop flag is on, and
               {
   //check if broker still permits the trade even if the stop flag is on 
   //(purchase/rollover makes the request, it is possible that stop purchse flag is overriden at the broker level)
                  if ( !bCheckBrokerPermits || //if not asked to check if broker permits, or
                        brokerPermits == N) //if asked to check if broker permits and it doesn't
                  {
                     DString idiStr;

                     addIDITagValue (idiStr, I_("FUND"), fundCode);
                     addIDITagValue (idiStr, I_("CLASS"), classCode);
                     if (bErrorSeverity)
                     {
                        ADDCONDITIONFROMFILEIDI (lErrorId, idiStr);
                     }
                     else 
                     {
                        ADDCONDITIONFROMFILEIDI (lWarnId, idiStr);
                     }
                  }//
                }//bStopFlag == true
               } //isTradeLevelOverrideRuleApplicable(idDataGroup)
            }//can trade fund class
         }//validate broker/branch/agent
      }
   }//pMFAccount
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isFundSoftCapped ( const DString &fundCode, 
                               const DString &classCode, 
                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isFundSoftCapped"));
   FundDetail *pFundDetail = NULL;
   bool bIsFundSoftCapped = false;

   if ( getWorkSession().getFundDetail ( fundCode, 
                                         classCode, 
                                         idDataGroup, 
                                         pFundDetail) &&
        pFundDetail)

   {
      bIsFundSoftCapped = pFundDetail->isFundSoftCapped(idDataGroup);
   }
   return bIsFundSoftCapped;
}

//******************************************************************************
SEVERITY Trade::readStopFlag ( const DString &transType,
                               const DString &fundCode,
                               const DString &classCode,
                               const DString &accountNum,
                               bool &bStopFlag, 
                               bool &bErrorSeverity, 
                               const BFDataGroupId &idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("readStopFlag"));
    FundDetail *pFundDetail = NULL;
    DString dstrBroker, dstrBranch, dstrRep, dstrTradeDate;
    getField (ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);
    getField (ifds::Broker, dstrBroker, idDataGroup); 
    getField (ifds::Branch, dstrBranch, idDataGroup);
    getField (ifds::SlsrepCode, dstrRep, idDataGroup);

    if ( getWorkSession().getFundDetail ( fundCode, 
                                          classCode, 
                                          idDataGroup, 
                                          pFundDetail) &&
        pFundDetail)
   {
      FundTransTypeList *pFundTransTypeList = NULL;

      if ( pFundDetail->getFundTransTypeList (pFundTransTypeList) <= WARNING &&
           pFundTransTypeList)
      {
         FundTransType *pFundTransType = NULL;

         if ( pFundTransTypeList->getFundTransType ( transType, 
                                                     pFundTransType, 
                                                     idDataGroup) <= WARNING &&
              pFundTransType)
         {
            DString stopFlag,
               stopSeverityCode;

            if ( pFundTransType->getStopFlag ( getWorkSession(),
                                               accountNum, 
                                               stopFlag, 
                                               stopSeverityCode, 
                                               idDataGroup) <= WARNING)
            {
               bStopFlag = stopFlag == Y && 
                           ( stopSeverityCode == I_("E") ||
                             stopSeverityCode == I_("W"));
               bErrorSeverity = stopSeverityCode == I_("E");
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::checkEntityOverride ( const DString &transType,
                                      const DString &fundCode,
                                      const DString &classCode,
                                      const DString &accountNum,
                                      bool &bOverride, 
                                      bool &bErrorSeverity, 
                                      const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("checkEntityOverride"));
   FundDetail *pFundDetail = NULL;

   if ( getWorkSession().getFundDetail ( fundCode, 
                                         classCode, 
                                         idDataGroup, 
                                         pFundDetail) &&
        pFundDetail)
   {
      FundTransTypeList *pFundTransTypeList = NULL;

      if ( pFundDetail->getFundTransTypeList (pFundTransTypeList) <= WARNING &&
           pFundTransTypeList)
      {
         FundTransType *pFundTransType = NULL;

         if ( pFundTransTypeList->getFundTransType ( transType, 
                                                     pFundTransType, 
                                                     idDataGroup) <= WARNING &&
              pFundTransType)
         {
            DString entityOverride,
               overrideSeverityCode;

            if ( pFundTransType->getEntityOverride ( getWorkSession(),
                                                     accountNum, 
                                                     entityOverride, 
                                                     overrideSeverityCode, 
                                                     idDataGroup) <= WARNING)
            {
               bOverride = entityOverride == Y && 
                           (overrideSeverityCode == I_("E") || overrideSeverityCode == I_("W"));
               bErrorSeverity = overrideSeverityCode == I_("E");
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateBrokerFund ( const DString &broker,
                                     const DString &transType,
                                     const DString &accountNum,
                                     const DString &fundCode, 
                                     const DString &classCode, 
                                     DString &brokerPermits,
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateBrokerFund"));

   DString fundAllowed (Y);
   DString brokerFund;

   brokerPermits = N;
   getWorkSession ().getOption ( ifds::BrokerFund, 
                                 brokerFund, 
                                 BF::HOST,
                                 false);

   if ( brokerFund == Y &&
        !fundCode.empty() &&
        !classCode.empty() &&
        !accountNum.empty())
   {
      BrokerList brokerList (*this);

      if ( !broker.empty() &&
            brokerList.initFundAllowed (broker, fundCode, classCode, accountNum, transType) <= WARNING)
      {
         BFObjIter bfIter (brokerList, idDataGroup);

         bfIter.begin ();
         if (!bfIter.end ())
         {
// fundAllowed (FundAllow) indicates if the broker is allowed to trade the fund/class
            bfIter.getObject()->getField (ifds::FundAllow, fundAllowed, idDataGroup);
// brokerPermits (AddPerm) indicates if the broker is allowed to trade 
// the fund/class even though the fund/class has a stop purchase turned on
            bfIter.getObject()->getField (ifds::AddPerm, brokerPermits, idDataGroup);
            fundAllowed.strip();
            brokerPermits.strip();
         }
      }
   }
   if (!isBrokerAllowed (transType, accountNum, fundCode, classCode, idDataGroup) && fundAllowed != Y)
   {
      DString idiStr;

      addIDITagValue (idiStr, I_("FUND"), fundCode);
      addIDITagValue (idiStr, I_("CLASS"), classCode);
      addIDITagValue (idiStr, I_("BROKER"), broker);
      ADDCONDITIONFROMFILEIDI (CND::ERR_FUND_CLASS_NOT_AVAILABLE_FOR_BROKER, idiStr);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isBrokerAllowed ( const DString &transType,
                              const DString &accountNum,
                              const DString &fundCode, 
                              const DString &classCode,
                              const BFDataGroupId &idDataGroup)
{
//this implementation is overriden in redemption/transfer (for trsf out and in-kind)
   return false;
}

//******************************************************************************
SEVERITY Trade::validateAgentFund ( const DString &broker,
                                    const DString &branch,
                                    const DString &agent,
                                    const DString &transType,
                                    const DString &accountNum,
                                    const DString &fundCode, 
                                    const DString &classCode, 
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("validateAgentFund"));

   SEVERITY sevRtn = NO_CONDITION;
   DString fundAllowed (Y);
   DString fundEligSlsRepLvl;

   getWorkSession ().getOption ( ifds::FundEligSlsRepLvl, 
                                 fundEligSlsRepLvl, 
                                 BF::HOST,
                                 false);

   if ( fundEligSlsRepLvl == Y &&
        !fundCode.empty() &&
        !classCode.empty() &&
        !accountNum.empty())
   {
      AgentList agentList (*this);

      if ( !broker.empty() &&
           !branch.empty() &&
           !agent.empty() &&
           (sevRtn = agentList.init2 ( broker, 
                                       branch, 
                                       agent,
                                       fundCode, 
                                       classCode, 
                                       accountNum)) <= WARNING)
      {
         BFObjIter bfIter (agentList, idDataGroup);

         bfIter.begin ();
         if (!bfIter.end ())
         {
            bfIter.getObject()->getField (ifds::ValidationPassed, fundAllowed, idDataGroup);
            fundAllowed.strip();
         }
      }
   }   
   if (sevRtn <= WARNING && !isAgentAllowed (idDataGroup) && fundAllowed != Y)
   {
      DString idiStr;

      addIDITagValue (idiStr, I_("FUND"), fundCode);
      addIDITagValue (idiStr, I_("CLASS"), classCode);
      addIDITagValue (idiStr, I_("AGENT"), agent);
      ADDCONDITIONFROMFILEIDI (CND::ERR_FUND_CLASS_NOT_AVAILABLE_FOR_SALESREP, idiStr);
   }
   else if (sevRtn > WARNING)
   {
      int count = CONDITIONCOUNT();
      Condition   *c = NULL;
      for( int i = 0; i < count; i++ )
      {
         c = GETCONDITION( i );
         int condCode = c->getCode();
         if (condCode == CND::ERR_NO_BRANCH_FOUND)
         {
            CLEARCONDITION( i );
            break;
         }
      }

      DString idiStr,
         agent_(agent),
         broker_(broker),
         branch_(branch);
      
      addIDITagValue( idiStr, I_("AGENT"), agent_.upperCase() );
      addIDITagValue( idiStr, I_("BROKER"), broker_.upperCase() );
      addIDITagValue( idiStr, I_("BRANCH"), branch_.upperCase() );
      ADDCONDITIONFROMFILEIDI( CND::ERR_AGENT_NOT_FOUND_FOR_BROKER_BRANCH, idiStr.c_str() ); 
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isAgentAllowed (const BFDataGroupId &idDataGroup)
{
//this is currently not overriden - just a place holder for future overrides at agent level   
   return false;
}

//******************************************************************************
SEVERITY Trade::validateFundBrokerCode ( const DString &fundBrokerCode,
                                         const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("validateFundBrokerCode"));
   DString fundBrokerApplicable;

   getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                fundBrokerApplicable,
                                BF::HOST,
                                false);

   if (fundBrokerApplicable == Y && !fundBrokerCode.empty())
   {
      FundBroker *pFundBroker = NULL;

      if ( getFundBroker (fundBrokerCode, pFundBroker, idDataGroup) <= WARNING && 
           pFundBroker)
      {
         DString tradeDate,
            fbEffectiveDate,
            fbStopDate;
      
         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         pFundBroker->getField (ifds::EffectiveDate, fbEffectiveDate, idDataGroup, false);
         pFundBroker->getField (ifds::StopDate, fbStopDate, idDataGroup, false);
         //check if fund broker is effective
         if (!DSTCommonFunctions::IsDateBetween (fbEffectiveDate, fbStopDate, tradeDate))
         {
            ADDCONDITIONFROMFILE (CND::ERR_FUND_BROKER_IS_NOT_EFFECTIVE);
         }
         if (GETCURRENTHIGHESTSEVERITY() <= WARNING) //still in business?
         {
            //check if fund broker is eligible
            FundBrokerElig fundBrokerElig (*this);
            DString fundCode;

            getField (ifds::FromFund, fundCode, idDataGroup, false);
            if (!fundCode.empty()) //do not want to get all eligible funds
            {
               if (fundBrokerElig.init (fundBrokerCode, fundCode) <= WARNING)
               {
                  if (!fundBrokerElig.isFundBrokerEligToTradeFund ( fundBrokerCode, 
                                                                     fundCode, 
                                                                     idDataGroup))
                  {
                     DString idiStr;
               
                     addIDITagValue (idiStr, I_ ("fund"), fundCode);
                     ADDCONDITIONFROMFILEIDI (CND::ERR_FUND_BROKER_NOT_ELIGIBLE_TO_TRADE_FUND, idiStr);
                  }
               }
            }
         }
         if (GETCURRENTHIGHESTSEVERITY() <= WARNING) //still good to go?
         {
            DString routingType;

            pFundBroker->getField (ifds::RoutingType, routingType, idDataGroup, false);
            if (routingType == I_("02")) //fund broker is Investro capable
            {
               FundMasterList *pFundMasterList = NULL;
               DString fundCode;

               getField (ifds::FromFund, fundCode, idDataGroup, false);
               if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
                     pFundMasterList)
               {
            //check if fund is not investro capable,
            //it only applies for 3rd party funds
                  if ( pFundMasterList->is3rdPartyFund (fundCode) && 
                        !pFundMasterList->isInvestroCapableFund (fundCode))
                  {
                     DString idiStr;

                     addIDITagValue (idiStr, I_("fund"), fundCode);
                     addIDITagValue (idiStr, I_("fundbroker"), fundBrokerCode);
                     getErrMsg ( IFASTERR::FUND_BROKER_INVESTRO_CAPABLE_WHILE_FUND_IS_NOT,
                                 CND::ERR_FUND_BROKER_INVESTRO_CAPABLE_WHILE_FUND_IS_NOT, 
                                 CND::WARN_FUND_BROKER_INVESTRO_CAPABLE_WHILE_FUND_IS_NOT, 
                                 idDataGroup,
                                 idiStr);

                  }
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::aggregateOptionRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("aggregateOptionRelatedChanges"));
   bool bReadOnly = true,
      b3rdPartyFund = false;
   DString aggregateOption;

   FundMasterList *pFundMasterList = NULL;
   if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
        pFundMasterList)
   {
      DString fundCode;

      getField (ifds::FromFund, fundCode, idDataGroup, false);
      if (!fundCode.empty() && (b3rdPartyFund = pFundMasterList->is3rdPartyFund (fundCode)))
      {
         aggregateOption = I_("0"); //this is the default value for 3rd party funds
         DString redCode,
            depositType;

         getField (ifds::RedCode, redCode, idDataGroup, false);
         getField (ifds::DepositType, depositType, idDataGroup, false);
         if (DSTCommonFunctions::codeInList (redCode, I_("16,17")) ||  //bearer certificate red code list
             DSTCommonFunctions::codeInList (depositType, I_("9,10")))  //bearer certificate deposit type list
         {
            aggregateOption = I_("1"); //supress send
            bReadOnly = true;
         }
         else //look at the order type
         {
            DString orderType;
            
            getField (ifds::OrderType, orderType, idDataGroup, false);
            if (orderType == N)  // direct order
            {
               aggregateOption = I_("1"); //supress send
               bReadOnly = true;
            }
            else //look at the dates
            {
               if (isBackdatedTrade (idDataGroup))
               {
                  aggregateOption = I_("1"); //supress send
                  bReadOnly = true;
               }
               else
               {
                  bReadOnly = false;
               }
            }
         }
      }
   }
   if (!_bInitPending)
   {
      setFieldNoValidate ( ifds::AggregateOption, aggregateOption, idDataGroup, false, 
                           true, //valid
                           true  //notify
                         );
   }
   setFieldReadOnly (ifds::AggregateOption, idDataGroup, 
         !getWorkSession().hasUpdatePermission (UAF::AGGREGATE_OPTION) || bReadOnly);
   setFieldRequired (ifds::AggregateOption, idDataGroup, b3rdPartyFund);
   setFieldValid (ifds::AggregateOption, idDataGroup, !b3rdPartyFund);
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::fromFundClassRelatedChanges ( const DString &fundCode, 
                                              const DString &classCode, 
                                              const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("fromFundClassRelatedChanges"));
   DString fundCurrency;
   
   //do not refresh split commissions until all the apply related changes are done
   _bShouldRefreshSplitCommissions = false; 

// fromCurrency represents from fund currency for all transaction types, 
// however, this value is only shown on the screen for Exchange/Transfer/Rollover; 
// assign it for Purchase and Redemption anyway in order to trigger 
// the doApplyRelatedChanges to set ExchRate accordingly
   if ( !fundCode.empty() &&
        !classCode.empty())
   {

      // only wire-support sytem and not in pending mode is required to 
      // set default order type
      if (isWireSupported (idDataGroup) && !_bInitPending )
      {
         setDefaultOrderType (idDataGroup);
      }
      getFundField (fundCode, classCode, ifds::Currency, fundCurrency);
      setFieldNoValidate ( ifds::FromCurrency, fundCurrency, idDataGroup, true, 
                           true, true); 
                         
// do this for multi-cycle processing, assign the currBusDate based on the fund
      getFundField (fundCode, classCode, ifds::NextNightRun, _currentBusinessDate);

      DString accountNum;
      MFAccount *pMFAccount;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      if ( getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount) <= WARNING &&
         pMFAccount)
      {
         if (pMFAccount->isClearingAcount (idDataGroup))
         {
            clearingRelatedChanges (idDataGroup);
         }
      }

      DString tradeDate;
      
      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
//based on the new values of fund/class
      validateDate (DATE_VALIDATION::DEFAULT_TRADE_DATE, ifds::EffectiveDate, tradeDate, idDataGroup);
      setFieldValid (ifds::AmountPrecision, idDataGroup, false); //to validate the precisions

      ////PET 212427 FN 01 - Project Thunder
      ////Default the source of fund for pending trade if the value is specified in ApplySrcofFund field. 
      ////If the default is available, user cannot override it. 
      //FundToList fundToList (*this);

      //DString dstrApplySrcOfFund = fundToList.getApplySrcOfFund(fundCode, classCode, NULL, NULL);
      //bool bApplySrcOfFund = !dstrApplySrcOfFund.empty() && (dstrApplySrcOfFund  != SOURCE_OF_FUND::TRANSITION);

      ////if( bApplySrcOfFund ) {
      ////   setFieldNoValidate(ifds::SrcOfFund, dstrApplySrcOfFund, idDataGroup, false, false, false);
      ////} else {
      ////   setFieldNoValidate(ifds::SrcOfFund, NULL_STRING, idDataGroup, false, false, false);
      ////}
      //setFieldNoValidate(ifds::SrcOfFund, dstrApplySrcOfFund, idDataGroup, false, false, false);
      //setFieldReadOnly (ifds::SrcOfFund, idDataGroup, bApplySrcOfFund);
	  DString orderType;
	  getField(ifds::OrderType,orderType,idDataGroup,false);
	  if (orderType == I_("Y"))
	  {
		  DString settleDate;
		  getField (ifds::SettleDate, settleDate, idDataGroup, false);
		  validateDate (DATE_VALIDATION::SETTLE_DATE, ifds::SettleDate, settleDate, idDataGroup);
		  setFieldValid (ifds::SettleDate, idDataGroup, false); 
	  }
   }
   else if (fundCode.empty () && classCode.empty ()) //alocation
   {
//restore the currBusDate with the nextCycleDate come from view 127 if fund and class are blank out
      _currentBusinessDate = _nextCycleDate;
//reset the 'from currency'
      setFieldNoValidate ( ifds::FromCurrency, NULL_STRING, idDataGroup, true, 
                           true, 
                           true);
                          //if fund is empty set from currency to NULL_STRING
   }

//lsif code initialization
   FundMasterList *pFundMasterList; 

   if ( !fundCode.empty() && 
         getMgmtCo().getFundMasterList (pFundMasterList) && 
         pFundMasterList)
   {
      bool bIsLisfFund = pFundMasterList->isLSIFFund (fundCode);

      setFieldReadOnly (ifds::LSIFCode, idDataGroup, !bIsLisfFund);

      DString lsifSubstVal;
      BFProperties *pBFProperties = getFieldProperties ( ifds::LSIFCode, 
                                                         idDataGroup);
      pBFProperties->getAllSubstituteValues (lsifSubstVal);
      if (bIsLisfFund && !lsifSubstVal.empty())
      {
         setFieldNoValidate ( ifds::LSIFCode, I_("0"), // 'as charged'
                              idDataGroup, false, false, true);
      }
      else
      {
         setFieldNoValidate ( ifds::LSIFCode, NULL_STRING, 
                              idDataGroup, false, false, true);
      }
      
      setFieldValid (ifds::MCHFileIndicator, idDataGroup, false); //to validate 
   }

   setUnitRoundMethodDefaultValue( idDataGroup );
   setGIDIFTradePayType (idDataGroup);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::amtTypeExtraRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("amtTypeRelatedChanges"));

   DString amtType;
   DString dstrTransType;
   getField (ifds::TradesTransType, dstrTransType, idDataGroup);
   dstrTransType.stripAll().upperCase();

   getField (ifds::AmtType, amtType, idDataGroup);
   amtType.stripAll().upperCase();
   if (DSTCommonFunctions::codeInList (amtType, I_("F,T,Y,X,M")))
   {
      setFieldReadOnly (ifds::Amount, idDataGroup, true);
      setFieldNoValidate (ifds::Amount, I_( "0.00" ), idDataGroup);
   }
   else
   {
      setFieldReadOnly( ifds::Amount, idDataGroup, false );      
   }

   if(dstrTransType == TRADETYPE::REFUND_REDEMPTION)//For both placing Refund redemption and Modifying it
   {
      MFAccount *pMFAccount = NULL;
	  DString taxType,accountNum;
	  getField (ifds::AccountNum, accountNum, idDataGroup, false);
	  if ( getWorkSession().getMFAccount ( idDataGroup, 
		  accountNum, 
		  pMFAccount) <= WARNING && 
		  pMFAccount)
	  {
		  pMFAccount->getField (ifds::TaxType, taxType, idDataGroup);
		  if(DSTCommonFunctions::codeInList (taxType, I_("SA,OA,SR")))
		  {
			   setFieldReadOnly( ifds::Amount, idDataGroup, true);
		  }
	  }
	}

   setUnitRoundMethodDefaultValue(idDataGroup);   

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::thirdPartyFundRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("thirdPartyFundRelatedChanges"));
//method called in Purchase/Redemption
   DString defaultFundBrokerCode,
		   fundBrokerApplicable, dstrFdBrokerDefaultLevel;
   bool bIs3rdPartyFund = false;

   getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                fundBrokerApplicable,
                                BF::HOST,
                                false);

   if (fundBrokerApplicable == Y)
   {
      DString fundCode;
   
      getField (ifds::FromFund, fundCode, idDataGroup, false);
   //if fund is not 3rd party, the related fields should be set to read only
      //fund broker
      FundMasterList *pFundMasterList = NULL;
      if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
           pFundMasterList)
      {
         bIs3rdPartyFund = pFundMasterList->is3rdPartyFund (fundCode);
         if (bIs3rdPartyFund && !_bInitPending)
         {
            DString accountNum;

            getField (ifds::AccountNum, accountNum, idDataGroup, false);
            accountNum.stripLeading ('0').strip();
            //read the default value of the fund broker code
            getDefaultFundBrokerCode (accountNum, fundCode, defaultFundBrokerCode, dstrFdBrokerDefaultLevel, idDataGroup);
            if((accountHasCategory(ACCTCAT_ROUTINGCLIENT,idDataGroup)) && dstrFdBrokerDefaultLevel != I_("03"))	// 01-shareholder level, 02-fund level, 03-account group fund group level
				defaultFundBrokerCode = I_("");//hard set the field to empty 
			aggregateOptionRelatedChanges (idDataGroup);
            setFieldNoValidate ( ifds::GrossOrNet, Y, idDataGroup, false, //gross
                                 true,
                                 true);

           MFAccount *pMFAccount = NULL;
           if ( getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount) <= WARNING &&
                pMFAccount )
           {
                DString dstrAccountLvlAggrType;
                pMFAccount->getField( ifds::AggregationType, dstrAccountLvlAggrType, idDataGroup );
                setFieldNoValidate( ifds::AggregationType, dstrAccountLvlAggrType, idDataGroup, false );
           }
       
         }
         setFieldReadOnly (ifds::GrossOrNet, idDataGroup, !bIs3rdPartyFund);
      }
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::FundBrokerCode, defaultFundBrokerCode, idDataGroup, false, 
                              true, // valid
                              true);  // notify
      }
   }
   //to trigger validation, if required/effective
   setFieldRequired (ifds::FundBrokerCode, idDataGroup, bIs3rdPartyFund);
   setFieldValid (ifds::FundBrokerCode, idDataGroup, !bIs3rdPartyFund);
   setFieldReadOnly (ifds::AggOrdAdjustNum, idDataGroup, !bIs3rdPartyFund);
   if (!bIs3rdPartyFund && !_bInitPending) //blank it out
   {
      setFieldNoValidate ( ifds::AggOrdAdjustNum, NULL_STRING, idDataGroup, false, 
                           true, // valid
                           true);  // notify
      setFieldNoValidate( ifds::AggregationType, NULL_STRING, idDataGroup, false, true );
   }
   setFieldReadOnly( ifds::AggregationType, idDataGroup, !bIs3rdPartyFund);
   
   return GETCURRENTHIGHESTSEVERITY();
}


//******************************************************************************
SEVERITY Trade::toFundClassRelatedChanges ( const DString &fundCode, 
                                            const DString &classCode, 
                                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("toFundClassRelatedChanges"));

   ////PET 212427 FN 01 - Project Thunder  
   ////Default the source of fund for pending trade if the value is specified in ApplySrcofFund field. 
   ////If the default is available, user cannot override it. 
   //FundToList fundToList (*this);
   //DString fromFundCode, fromClassCode;

   //getField (ifds::FromFund, fromFundCode, idDataGroup, false);
   //getField (ifds::FromClass, fromClassCode, idDataGroup, false);

   //DString dstrApplySrcOfFund = fundToList.getApplySrcOfFund (fromFundCode, fromClassCode, fundCode, classCode);
   //bool bApplySrcOfFund = !dstrApplySrcOfFund.empty();

   //if( bApplySrcOfFund ) {
   //   setFieldNoValidate(ifds::SrcOfFund, dstrApplySrcOfFund, idDataGroup, false, false, false);
   //} else {
   //   setFieldNoValidate(ifds::SrcOfFund, NULL_STRING, idDataGroup, false, false, false);
   //}
   //setFieldReadOnly (ifds::SrcOfFund, idDataGroup, bApplySrcOfFund);
   //

   DString accountNum;
   MFAccount *pMFAccount;

   getField (ifds::AccountTo, accountNum, idDataGroup);

   if ( getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount) <= WARNING &&
        pMFAccount)
   {
      if (pMFAccount->isClearingAcount (idDataGroup))
      {
         clearingRelatedChanges (idDataGroup);
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//order type, wire order validation and related changes
//******************************************************************************
inline SEVERITY Trade::validateOrderType ( const DString &orderType,
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateOrderType"));
   //logic placed in transfer/exchange, redemption
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline SEVERITY Trade::validateNetOrdType (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateNetOrdType"));
//logic placed in purchase/rollovers
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateGrossOrNet ( const DString &grossOrNet, 
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateNetOrdType"));
   FundMasterList *pFundMasterList = NULL;
   if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
        pFundMasterList)
   {
      DString fundCode;

      getField (ifds::FromFund, fundCode, idDataGroup, false);
      if (!fundCode.empty() && pFundMasterList->is3rdPartyFund (fundCode))
      {
         DString grossOrNet;

         getField (ifds::GrossOrNet, grossOrNet, idDataGroup, false);
         if (grossOrNet == N) //net
         {
            ADDCONDITIONFROMFILE (CND::ERR_NET_TRADE_NOT_ALLOWED_FOR_THIRD_PARTY_FUNDS);
         }
      }
	  /*
	   * IN3249502(PRB0041279) - T907-Net Purchase (net of fees and taxes)
	   * Add following process to prevent creation of 
	   * NET settlement transaction on Clawback funds 
	   */
	  if (isPurchase (idDataGroup))
	  {
		bool bIsClawBackFund = false;
		DString classCode;
		FundDetail *pFundDetail = NULL;

		getField (ifds::FromFund, fundCode, idDataGroup, false);
		getField (ifds::FromClass, classCode, idDataGroup, false);
   
		if ( !fundCode.empty() &&
			 !classCode.empty() &&
			 getWorkSession().
				getFundDetail (fundCode, classCode, idDataGroup, pFundDetail) && 
				pFundDetail)
		{
			DString overrideDSCAllow,
			loadType;
      
			pFundDetail->getField (ifds::OverrideDSCAllow, overrideDSCAllow, idDataGroup, false);
			pFundDetail->getField (ifds::LoadType, loadType, idDataGroup, false);
			bIsClawBackFund = overrideDSCAllow == I_("Y") && (loadType == I_("CB") || loadType == I_("BEL")); //charge back
		}
		if (bIsClawBackFund)
		{
			if (grossOrNet == N) //net
			{
				getErrMsg ( IFASTERR::NET_SETTLEMENT_NOT_ALLOWED_FOR_PURCHASE, 
                CND::ERR_Net_SETTLEMENT_NOT_ALLOWED, 
                CND::WARN_Net_SETTLEMENT_NOT_ALLOWED, 
                idDataGroup); 
			}
		}
	  }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::brokerRelatedChanges ( DString &branch, 
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("brokerRelatedChanges"));

   DString slsepByBranch,
      brokerBranch;

   getWorkSession ().getOption ( ifds::RepByBranch, 
                                 slsepByBranch, 
                                 BF::HOST,
                                 false);
   getWorkSession().getOption ( ifds::BrokerBranch, 
                                brokerBranch, 
                                BF::HOST, 
                                false);

   if (slsepByBranch == N)
   {
      if (brokerBranch == Y)
      {
         getField (ifds::Broker, branch, idDataGroup, false);
      }
      else
      {
         branch = I_("0000");
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::orderTypeBrokerRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("orderTypeBrokerRelatedChanges"));
   
   DString orderType,
      expGNSettle (I_("G")); //gross
   
   getField (ifds::OrderType, orderType, idDataGroup, false);
   if (orderType == Y)  // wire order
   {
      Broker *pBroker;

      if ( getBroker ( pBroker, idDataGroup) <= WARNING &&
           pBroker)
      {
         DString brokerNetAllowed;

         pBroker->getField (ifds::NetAllowed, brokerNetAllowed, idDataGroup, false);
         expGNSettle = brokerNetAllowed == Y ? N :         //net
                                               I_("G");    //gross
      }
   }
   setFieldNoValidate (ifds::ExpGNSettle, expGNSettle, idDataGroup, false,
                        true, //valid
                        true);  //notify observers
   setFieldReadOnly (ifds::ExpGNSettle, idDataGroup, orderType != Y);
   return GETCURRENTHIGHESTSEVERITY();
}

//virtual method, Redemption has some specific implementation
//******************************************************************************
SEVERITY Trade::orderTypeRelatedChanges ( const BFDataGroupId &idDataGroup, 
                                          bool bValidateDate /*= true*/) 
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("orderTypeRelatedChanges"));

   DString orderType;

   getField (ifds::OrderType, orderType, idDataGroup, false);
//whether wire order number is supposed to be mandatory or not
   DString wireNumMand;

   getWorkSession ().getOption ( ifds::WireNumMandatory, 
                                 wireNumMand, 
                                 BF::HOST,
                                 false);
   getField (ifds::OrderType, orderType, idDataGroup, false);

   bool bWireOrdNumReq = orderType == Y && wireNumMand == Y;

   
   setFieldRequired (ifds::WireOrdNum, idDataGroup, bWireOrdNumReq);
   setFieldValid (ifds::WireOrdNum, idDataGroup, !bWireOrdNumReq);

   // Not applicable with PET 2292 FN01 - Switch Settlement
   DString settleDate, settleInDate;

   getField (ifds::SettleDate, settleDate, idDataGroup);
   getField (ifds::SettleInDate, settleInDate, idDataGroup);
   if (bValidateDate && !_bInitPending)
   {
       validateDate ( DATE_VALIDATION::SETTLE_DATE, 
                        ifds::SettleDate, 
                        settleDate, 
                        idDataGroup);

	   validateDate ( DATE_VALIDATION::SETTLE_DATE, 
		   ifds::SettleInDate, 
		   settleInDate, 
		   idDataGroup);
   }

   if (orderType == Y)  // Wire Order : reset and enable SettleDate, enable GrossOrNet
   {
 /*     DString settleDate;

      getField (ifds::SettleDate, settleDate, idDataGroup);
      if (bValidateDate && !_bInitPending)
      {
         validateDate ( DATE_VALIDATION::SETTLE_DATE, 
                        ifds::SettleDate, 
                        settleDate, 
                        idDataGroup);
      }*/
	  setFieldValid (ifds::SettleDate, idDataGroup, false); 
      DString manualSettleDates,
         wireNumDefault;

      getWorkSession ().getOption ( ifds::ManualSettleDates, 
                                    manualSettleDates, 
                                    BF::HOST, 
                                    false);
      getWorkSession ().getOption ( ifds::WireNumDefault, 
                                    wireNumDefault, 
                                    BF::HOST,
                                    false);
      setFieldReadOnly (ifds::SettleDate, idDataGroup, manualSettleDates != Y);
      setFieldReadOnly (ifds::SettleInDate, idDataGroup, manualSettleDates != Y);
      if (!_bInitPending)
      {
         //unknown for wire order
         setFieldNoValidate ( ifds::SettledBy, NULL_STRING, idDataGroup, false,
                              true, //valid
                              true);  //notify observers
      }
      setFieldReadOnly (ifds::SettledBy, idDataGroup, true);
      if (wireNumDefault == Y && !_bInitPending)
      {
         DString wireOrderNum;

         getField (ifds::WireOrdNum, wireOrderNum, idDataGroup, false);
         wireOrderNum.stripLeading ('0');

         if (wireOrderNum.empty ())
         {
            DString transNum;

            getField (ifds::TransNum, transNum, idDataGroup, false);
            // only assign the last 8 characters from the right 
            transNum.right (8).strip ().stripLeading ('0');
            setFieldNoValidate (ifds::WireOrdNum, transNum, idDataGroup, false,
                                true, //valid
                                true);  //notify observers
         }
      }
      
      DString valueDateApplic;

//read mgmt company option, is value date applicable
      getWorkSession ().getOption ( ifds::ValueDateApplic, 
                                    valueDateApplic, 
                                    BF::HOST, 
                                    false);         
      if (valueDateApplic == Y && !isPurchase(idDataGroup))
      {
// default to settlement date and validate by calling view 135 to check if it is a valid valuation date
         if (!_bInitPending)
         {
            getField (ifds::SettleDate, settleDate, idDataGroup, false);
            //set and validate the value date
            setFieldNoValidate ( ifds::ValueDate, settleDate, idDataGroup, false,
                                 true, //valid
                                 true);  //notify observers
            validateValueDate (settleDate, idDataGroup);
         }
         
      }
   }
   else // Direct Order
   {
      directOrderSettleDateRelatedChanges (idDataGroup);
      setFieldReadOnly (ifds::SettleDate, idDataGroup, true);
      setFieldReadOnly (ifds::SettledBy, idDataGroup, false);
   }
   
   setFieldReadOnly (ifds::ValueDate, idDataGroup, true);
   
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::directOrderSettleDateRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("directOrderSettleDateRelatedChanges"));
   DString orderType;

   getField (ifds::OrderType, orderType, idDataGroup, false);

   if (orderType == N && !_bInitPending) //direct
   {
      DString tradeDate;
// reset settledate to trade date if trade date >= currBusDate else, set settlement date to CurrBusDate
      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      if (DSTCommonFunctions::
            CompareDates (tradeDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER)
      {
         setFieldNoValidate ( ifds::SettleDate, _currentBusinessDate, idDataGroup, false,
                              false, //invalid
                              true);  //notify observers
      }
      else
      {
         setFieldNoValidate ( ifds::SettleDate, tradeDate, idDataGroup, false, 
                              false, //invalid
                              true);  //notify observers
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateWireOrderNum ( const DString &wireOrdNum,
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateWireOrderNum"));

   DString orderType, 
      charWireNum;

   getField (ifds::OrderType, orderType, idDataGroup, false);
   getWorkSession ().getOption ( ifds::CharWireNum, 
                                 charWireNum, 
                                 BF::HOST,
                                 false);

   if (charWireNum == N && !wireOrdNum.isAllDigits ()) 
   {
      ADDCONDITIONFROMFILE (CND::ERR_WIRE_NUM_NOT_NUMERIC);
   } 
   else if (orderType == Y) //Wire Order
   {       
      /*if (wireOrdNum.empty())
      {
         getErrMsg ( IFASTERR::WIRE_ORDER_NUMBER_REQUIRED,
                     CND::ERR_WIRE_ORDER_NUMBER_REQUIRED, 
                     CND::WARN_WIRE_ORDER_NUMBER_REQUIRED, 
                     idDataGroup);
      }
      else */if (wireOrdNum.length () > 10)
      {
         getErrMsg ( IFASTERR::WIRE_ORDER_ALLOWED_SIZE,
                     CND::ERR_ONLY_10_CHARATERS_ALLOWED, 
                     CND::WARN_ONLY_10_CHARATERS_ALLOWED, 
                     idDataGroup);

      }
      else if (wireOrdNum.length () > 20) // The following code for API
      {
         ADDCONDITIONFROMFILE (CND::ERR_ONLY_20_CHARATERS_ALLOWED);
      }
   
      if (GETCURRENTHIGHESTSEVERITY() <= WARNING) //exit if errors from previous checks
      {
         AmsMstrInfo* pAMSMstrInfo = NULL;
         DString amsCode;

         if ( getAMSMstrInfo (pAMSMstrInfo, amsCode, idDataGroup) <= WARNING &&
              pAMSMstrInfo
            )
         {
            DString wireEleg;

            pAMSMstrInfo->getField (ifds::WireEleg, wireEleg, idDataGroup, false);
            if (wireEleg == N) 
            {
               DString idiStr;
         
               addIDITagValue (idiStr, I_ ("CODE"), amsCode);
               ADDCONDITIONFROMFILEIDI (CND::AMS_ERR_TRADE_WIRE_ORDER_NOT_ALLOWED, idiStr);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::wireOrderAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("wireOrderAllowed"));

   DString orderType,
      fundCode,
      classCode;

   getField (ifds::OrderType, orderType, idDataGroup, false);
   getFundField (ifds::FundCode, fundCode, idDataGroup);
   getFundField (ifds::ClassCode, classCode, idDataGroup);
   if (orderType == Y)
   {
      if ( !fundCode.empty() && 
           !classCode.empty()
         )
      {
         DString wireElig;

         if (getFundField (ifds::WireElig, wireElig, idDataGroup) <= WARNING)
         {
            if (wireElig == N)
            {
               DString idiStr;

               addIDITagValue (idiStr, I_("FUND"),  fundCode);
               addIDITagValue (idiStr, I_("CLASS"), classCode);
               ADDCONDITIONFROMFILEIDI (CND::ERR_WIRE_ORDER_NOT_ALLOWED_FOR_FUND, idiStr);
            }
         }
      }
      else if ( fundCode.empty() && 
                classCode.empty())
      {
         DString accountNum;

         getAccountField (ifds::AccountNum, accountNum, idDataGroup);
         if (isAMSLimitationCheckRequired (accountNum, idDataGroup)) 
         {
            AmsMstrInfo* pAMSMstrInfo = NULL;
            DString amsCode;

            if ( getAMSMstrInfo (pAMSMstrInfo, amsCode, idDataGroup) <= WARNING &&
                 pAMSMstrInfo
               )
            {
               DString wireEleg;

               pAMSMstrInfo->getField (ifds::WireEleg, wireEleg, idDataGroup, false);
               if (wireEleg == N) 
               {
                  DString idiStr;
            
                  addIDITagValue (idiStr, I_ ("CODE"), amsCode);
                  ADDCONDITIONFROMFILEIDI (CND::AMS_ERR_TRADE_WIRE_ORDER_NOT_ALLOWED, idiStr);
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************************
SEVERITY Trade::validateOrderSource ( const DString &orderSource, 
                                      const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateOrderSource"));

   DString accountNum;
   MFAccount *pMFAccount = NULL;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   if ( getWorkSession().getMFAccount ( idDataGroup, 
                                        accountNum, 
                                        pMFAccount) <= WARNING && 
        pMFAccount)
   {
      DString acctDesignation;
         
      pMFAccount->getField (ifds::AcctDesignation, acctDesignation, idDataGroup, false);
      if ( acctDesignation != I_("3") &&  //intermediary
           orderSource == I_("I"))         //intermediary
      {
         getErrMsg ( IFASTERR::INVALID_ORDER_SOURCE_FOR_ACCOUNT_DESIGNATION,
                     CND::ERR_INVALID_ORDERSRC_FOR_ACCT_DESIGNATION, 
                     CND::ERR_WARN_INVALID_ORDERSRC_FOR_ACCT_DESIGNATION, 
                     idDataGroup);
      }
      else if ( !DSTCommonFunctions::codeInList (acctDesignation, I_("1,2,3")) && //client/nominee/intermediary
                orderSource == I_("D"))  //dealer
      {
         getErrMsg ( IFASTERR::INVALID_ORDER_SOURCE_FOR_ACCOUNT_DESIGNATION,
                     CND::ERR_INVALID_ORDERSRC_FOR_ACCT_DESIGNATION, 
                     CND::ERR_WARN_INVALID_ORDERSRC_FOR_ACCT_DESIGNATION, 
                     idDataGroup);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************************
SEVERITY Trade::validateOrderSourceOrderType (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateOrderSourceOrderType"));

   DString orderSource,
      orderType;

   getField (ifds::OrderSource, orderSource, idDataGroup, false);
   getField (ifds::OrderType, orderType, idDataGroup, false);   
   if (orderType == Y && orderSource == I_("F"))
   {
      ADDCONDITIONFROMFILE (CND::ERR_ORDERSRC_INVALID_FOR_WIRE_ORDER);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//pay type, file processor, settle currency, pay method, address code
//******************************************************************************
SEVERITY Trade::validatePayType ( const DString &payType,
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validatePayType"));

   MFAccount *pMFAccount = NULL;
   DString accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup);
   if ( getWorkSession().getMFAccount ( idDataGroup,
                                        accountNum, pMFAccount) <= WARNING &&
        pMFAccount)
   {
      if (payType == PAYTYPE::CLEARING)
      {
         if (!pMFAccount->isClearingAcount (idDataGroup))
         {
//"Pay Type Clearing cannot be selected for non Clearing Account"
            ADDCONDITIONFROMFILE (CND::ERR_TRADE_PAY_TYPE_INVALID_FOR_NON_CLEARING_ACCOUNT);
         }
         else
         {
            validateClearingAccount (pMFAccount, idDataGroup);
            //validateDefaultSettleInstr(accountNum,idDataGroup);
         }
      } 
      else if (payType == PAYTYPE::DIRECT) //check direct trading permission
      {
         DString dtaType;
   
         pMFAccount->getField (ifds::DTAType, dtaType, idDataGroup, false);
         if (dtaType.empty() || !pMFAccount->isAcctDTAEligible (idDataGroup))
         {
            ADDCONDITIONFROMFILE (CND::ERR_ACCT_NOT_DTA_ELIGIBLE);
         }
         if (GETCURRENTHIGHESTSEVERITY () <= WARNING)
         {
            validatePayTypeBroker (idDataGroup);
         }
      }
      else if( payType == PAYTYPE::SYSTEM_CHEQUE || 
               payType == PAYTYPE::MANUAL_CHEQUE )
      {
         validatePayTypeCheque(idDataGroup);
      }

      if (isBankingNeeded (idDataGroup))
      {
         DString bankIdValue;

         getField (ifds::BankIdValue, bankIdValue, idDataGroup, false);
         if (!bankIdValue.empty())
         {
//Incident#261420 - if more then one active shareholder banking instructions
            if (howManyActiveBankInstructions (idDataGroup) > 1)
            {
               ADDCONDITIONFROMFILE (CND::WARN_SHAREHOLDER_HAS_MULTIPLE_ACTIVE_BANK_ACCOUNTS);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//pay type, bankIDValue : ensure bank is set up for EFT
//******************************************************************************
SEVERITY Trade::validatePayTypeBank (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validatePayTypeBank"));

   if (isBankingNeeded (idDataGroup))
   {
//in a non-multi currency environment for a full redemption
//an EFT trade is not allowed if the account holdings are not in the same currency,
// -- banking information cannot be entered 
      if (_multiCurrency == N && (isFullRedemption (idDataGroup) || canCloseAccount (idDataGroup)))
      {
         MFAccountHoldingList *pMFAccountHoldings = NULL;
         
         if ( getAccountHoldings (pMFAccountHoldings, idDataGroup) <= WARNING &&
              pMFAccountHoldings)
         {
            BFObjIter bfIter (*pMFAccountHoldings, idDataGroup);

            if (!bfIter.end()) //do we have holdings?
            {
               DString accountHoldingsCurrency;

               if (getAccountHoldingsCurrency (accountHoldingsCurrency, idDataGroup) <= WARNING)
               {
                  if (accountHoldingsCurrency.empty())
                  {
                     ADDCONDITIONFROMFILE (CND::ERR_EFT_FULL_REDEMPTION_NOT_ALLOWED);
                  }
               }
            }
         }

      }
      if (GETCURRENTHIGHESTSEVERITY () <= WARNING) //do not want to raise too many errors...
      {
         DString bankIdValue;

         getField (ifds::BankIdValue, bankIdValue, idDataGroup, false);
         if (bankIdValue.empty())
         {
            ADDCONDITIONFROMFILE (CND::ERR_MISS_BANK_ACCT_INFO);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*******************************************************************************************************
int Trade::howManyActiveBankInstructions (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("howManyActiveBankInstructions"));
   DString accountNum,
      bankAcctUseCode;

   int nActiveBankingInstructions = 0;
   if (isPurchaseLike (idDataGroup))
   {
      bankAcctUseCode = AcctUseCode::EFT_PURCHASE;
   }
   else if (isRedemptionLike (idDataGroup))
   {
      bankAcctUseCode = AcctUseCode::EFT_REDEMPTION;
   }
   if (!bankAcctUseCode.empty())
   {
      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      accountNum.stripLeading ('0').strip();
      if (!accountNum.empty())
      {
         MFAccount *pMFAccount = NULL;

         if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
              pMFAccount)
         {
            DString shrNum;
            Shareholder *pShareholder = NULL;

            pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup, false);
            if ( getWorkSession().getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING && 
                 pShareholder)
            {
               ShareholderBankInstructionsList *pShareholderBankInstructionsList = NULL;

               if ( pShareholder->getShareholderBankInstructionsList ( pShareholderBankInstructionsList, 
                                                                       idDataGroup) <= WARNING &&
                  pShareholderBankInstructionsList)
               {
                  BFObjIter iter ( *pShareholderBankInstructionsList, 
                                    idDataGroup);

                  DString currency,
                     tradeDate;

                  getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
                  getField (ifds::SettleCurrency, currency, idDataGroup, false);
                  if (!currency.empty())
                  {
                     while (!iter.end())
                     {
                        DString bankAcctCurrency,
                           bankAcctUseCode_,
                           bankEffectiveDate,
                           bankStopDate;

                        iter.getObject()->
                              getField (ifds::BankAcctCurrency, bankAcctCurrency, idDataGroup, false);
                        iter.getObject()->
                              getField (ifds::AcctUseCode, bankAcctUseCode_, idDataGroup, false);
                        iter.getObject()->
                              getField (ifds::EffectiveDate, bankEffectiveDate, idDataGroup, false);
                        iter.getObject()->
                              getField (ifds::StopDate, bankStopDate, idDataGroup, false);
                        if ( bankAcctCurrency == currency && 
                             bankAcctUseCode_ == bankAcctUseCode &&
                             DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
                        {
                           ++nActiveBankingInstructions;
                        }
                        ++iter;
                     }
                  }
               }
            }
         }
      }
   }
   return nActiveBankingInstructions;
}

//*******************************************************************************************************
SEVERITY Trade::validateAddressCode ( const DString &addressCode,
                                      const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAddressCode"));

   if (isShareholderAddressNeeded (idDataGroup))
   {
      DString shrNum;

      if ( getAccountField (ifds::ShrNum, shrNum, idDataGroup) <= WARNING &&
           !shrNum.empty())
      {
         Shareholder *pShareholder = NULL;
   
         if (getWorkSession().
               getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING)
         {
            AddressList *pAddressList = NULL;

            if (pShareholder->getAddressList (pAddressList, idDataGroup) <= WARNING)
            {
               DString effectiveDate;

               getField (ifds::EffectiveDate, effectiveDate, idDataGroup, false);
               if (DSTCommonFunctions::
                     CompareDates (effectiveDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER)
               {
                  effectiveDate = _currentBusinessDate;
               }
               pAddressList->validateAddressCode ( addressCode, 
                                                   idDataGroup, 
                                                   effectiveDate);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::payTypeRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("payTypeRelatedChanges"));

   DString payType;

   getField (ifds::TradesPayType, payType, idDataGroup, false);
   clearingRelatedChanges (idDataGroup);

//take of the suppres fields
   bool isPayTypeSuppress = payType == PAYTYPE::SUPPRESS;

   setFieldRequired (ifds::SuppressCode, idDataGroup, !isHypo() && isPayTypeSuppress);
   setFieldReadOnly (ifds::SuppressCode, idDataGroup, !isPayTypeSuppress);
   setFieldValid (ifds::SuppressCode, idDataGroup, !isPayTypeSuppress); //invalidate the field...
//clear the supress code
   if (!isPayTypeSuppress)
   { 
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::SuppressCode, NULL_STRING, idDataGroup, false, 
                              false, //invalid
                              true); //notify observers
      }
   }
   bankingRelatedChanges (idDataGroup);
   addressRelatedChanges (idDataGroup);
//in all other cases remove address and banking
   if ( !isBankingNeeded (idDataGroup) && 
        !isShareholderAddressNeeded (idDataGroup))
   {
//clear the address code
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::AddrCode, NULL_STRING, idDataGroup, 
                              false, 
                              true,
                              true); //notify observers
         removeTradeBankInstructionsList (idDataGroup);
      }
   }
   bankChrgsRelatedChanges (idDataGroup);
   refreshTradePayInstructions (idDataGroup);
   setTradePayInstructField (ifds::TradesPayType, ifds::PayType, idDataGroup);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline bool Trade::isACHApplicable (const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
inline bool Trade::isFileProccessorApplicable (const BFDataGroupId &idDataGroup)
{
   DString payType;

   getField (ifds::TradesPayType, payType, idDataGroup, false);
   return (payType == PAYTYPE::EFT || payType == PAYTYPE::DIRECT_DEPOSIT) &&
	      isACHApplicable (idDataGroup); // removed multicurreny since FileProcessor is worked on both domestic and inter.
}

//******************************************************************************
SEVERITY Trade::addressRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("addressRelatedChanges"));
   if (isShareholderAddressNeeded (idDataGroup))
   {
      if (!_bInitPending)
      {
   //remove the banking information and clear the bank fields
         removeTradeBankInstructionsList (idDataGroup);
   //by default the address code is 01
         setFieldNoValidate ( ifds::AddrCode, I_("01"), idDataGroup, false, 
                              false, //invalid, do not know if it's effective (see 'validateAddressCode')
                              true);   //notify observers
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::bankChrgsRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("bankChrgsRelatedChanges"));

//set the correct bank charges flag, read default again from account
   DString bankCharge (I_("0"));

   DString payType;

   getField (ifds::TradesPayType, payType, idDataGroup, false);

   if (!_bInitPending)
   {
	  DString payMethod;

	  getField (ifds::PayMethod, payMethod, idDataGroup, false);

	  //IN2393911 - default bank charge with the value set at a/c level 
	  //			if pay type 'E', pay method = 'CHQ' 
      if (isBankingNeeded (idDataGroup)||
		  ((payType == PAYTYPE::EFT )&& (payMethod == I_("CHQ"))))
      {
         getAccountField (ifds::BankChrgs, bankCharge, idDataGroup);
      }

      if (!bankCharge.empty())
      {
         setFieldNoValidate ( ifds::BankChrgs, bankCharge, idDataGroup, false,
                              true,
                              true, //side effect
                              false);
      }
   }
//bank charges should be updatable if pay type is 'E'
   bool bCanBankChrgsOverride = ( payType == PAYTYPE::EFT && isRedemptionLike(idDataGroup) );

   setFieldReadOnly (ifds::BankChrgs, idDataGroup, !bCanBankChrgsOverride );
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::bankingRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("bankingRelatedChanges"));

//clear the address code
   if (isBankingNeeded (idDataGroup))
   {
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::AddrCode, NULL_STRING, idDataGroup, 
                              false, 
                              true,
                              true); //notify observers
      }
      
      DString currency;
      
      getField (ifds::SettleCurrency, currency, idDataGroup, false);
      if (!currency.empty())
      {
//initialize banking
         TradeBankInstructionsList *pTradeBankInstructionsList = NULL;

         getBankInstructionsList ( pTradeBankInstructionsList, 
                                   idDataGroup,
                                   true); //force creation/removal of bank instructions list
         if (pTradeBankInstructionsList)
         {
            BFObjIter iter (*pTradeBankInstructionsList, idDataGroup);

            if (!iter.end())
            {
               TradeBankInstructions *pTradeBankInstructions = 
                     dynamic_cast <TradeBankInstructions*> (iter.getObject());

               pTradeBankInstructions->copyToSpecificCBO (idDataGroup);
            }
         }
      }
   }
   else
   {
      //clear the banking fields
      //beneficial bank
      setFieldNoValidate (ifds::BankIdType, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::BankIdValue, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::TransitNo, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::BankAcctNum, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::BankAcctName, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::BankAcctType, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::InstName, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::BankAddr1, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddr2, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddr3, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddr4, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddr5, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankPostal, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankCountry, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankContact, NULL_STRING, idDataGroup, false);   
      setFieldNoValidate (ifds::SwiftCode, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::RefNumber, NULL_STRING, idDataGroup);
      //correspondent bank      
      setFieldNoValidate (ifds::BankIdTypeCB, NULL_STRING, idDataGroup);
      setFieldNoValidate (ifds::BankIdValueCB, NULL_STRING, idDataGroup, false);   
      setFieldNoValidate (ifds::TransitNoCB, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::InstNameCB, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddrCB1, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddrCB2, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddrCB3, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddrCB4, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankAddrCB5, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankPostalCB, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankCountryCB, NULL_STRING, idDataGroup, false);
      setFieldNoValidate (ifds::BankContactCB, NULL_STRING, idDataGroup, false);   
      setFieldNoValidate (ifds::PayReason1, NULL_STRING, idDataGroup, false);   
      setFieldNoValidate (ifds::PayReason2, NULL_STRING, idDataGroup, false);   
      setFieldNoValidate (ifds::FFC, NULL_STRING, idDataGroup, false);   
      setFieldNoValidate (ifds::FFC1, NULL_STRING, idDataGroup, false);   

   }
   setFieldValid (ifds::PayTypeBankNum, idDataGroup, false);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::fileProcessorRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("fileProcessorRelatedChanges"));

   DString substList;

   if (isFileProccessorApplicable (idDataGroup))
   {
      DynamicSubListHolder* pDynamicSubListHolder = 
         getMgmtCo ().getDynamicSubListHolder ();

      assert (pDynamicSubListHolder);
      
      DString  payMethod, 
               transType,
               currency;

      getField (ifds::PayMethod, payMethod, idDataGroup, false);
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::SettleCurrency, currency, idDataGroup, false);

      if (currency.empty())
      {
         substList = pDynamicSubListHolder->
               getFileProcSubList (transType, payMethod);
      }
      else
      {
         substList = pDynamicSubListHolder->
               getFileProcSubList (transType, payMethod, currency);
      }
   }

   bool bRequired = !substList.empty ();

   setFieldAllSubstituteValues (ifds::ACHProcessor, idDataGroup, substList);
   setFieldRequired (ifds::ACHProcessor, idDataGroup, bRequired && !isHypo());
   setFieldReadOnly (ifds::ACHProcessor, idDataGroup, !bRequired);
   setFieldValid (ifds::ACHProcessor, idDataGroup, !bRequired);
   if (!bRequired) //set the value to empty, since it does not apply
   {
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::ACHProcessor, NULL_STRING, idDataGroup, false, 
                              true, 
                              true, //notify
                              false); //no related changes
      }
   }
   else if (bRequired && !isHypo())
   {
      DString _dstrACHProcessor;
      getField (ifds::ACHProcessor, _dstrACHProcessor, idDataGroup);
      if(_dstrACHProcessor == NULL_STRING)
      {
         DString payType, amtType, frClearingMethod, fileProcessor;
         getTradeDefaults ( payType, 
                            amtType, 
                            frClearingMethod, //not set in here, see 'clearingRelatedChanges'
                            fileProcessor, 
                            idDataGroup);
         if (!fileProcessor.empty())
         {
            setFieldNoValidate (ifds::ACHProcessor, fileProcessor, idDataGroup, false, false, true, true);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::payMethodPropertyChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("payMethodPropertyChanges"));
   bool bIsFileProcApplic = 
         isFileProccessorApplicable (idDataGroup);

   DString dstrPayInstrOption, dstrPayType;
	
   getField (ifds::TradesPayType, dstrPayType, idDataGroup, false);
   getField (ifds::PayInstrOption, dstrPayInstrOption, idDataGroup, false);   
   if(dstrPayType == PAYTYPE::DIRECT_DEPOSIT && DSTCommonFunctions::getMarket() == MARKET_IDS::CANADA)
   {
      setFieldReadOnly (ifds::PayMethod, idDataGroup, true);
   }
   else
   {
	setFieldReadOnly (ifds::PayMethod, idDataGroup, !(bIsFileProcApplic && dstrPayInstrOption != I_("03")));
   }
   setFieldRequired (ifds::PayMethod, idDataGroup, bIsFileProcApplic && !isHypo());
   setFieldValid (ifds::PayMethod, idDataGroup, !bIsFileProcApplic);

   if (!_bInitPending)
   {
      if (!bIsFileProcApplic) //set the value to WIRE, if it does not apply, view likes this
      {
         setFieldNoValidate ( ifds::PayMethod,
                              ( (dstrPayType == PAYTYPE::DIRECT_DEPOSIT && DSTCommonFunctions::getMarket() == MARKET_IDS::CANADA) ? I_("DDER") : I_("WIRE") ),
                              idDataGroup,
                              false, 
                              true, 
                              true, //notify
                              false); //no related changes
      }
   }
   if (bIsFileProcApplic)
   {
      DString substList;
      DynamicSubListHolder* pDynamicSubListHolder = 
         getMgmtCo ().getDynamicSubListHolder ();

      assert (pDynamicSubListHolder);
      
      DString  transType,
               currency,
               fileProc;

      getField (ifds::ACHProcessor, fileProc, idDataGroup, false);
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::SettleCurrency, currency, idDataGroup, false);
	  
      if (currency.empty())
      {
         substList = pDynamicSubListHolder->
               getPayMethodSubList (transType, fileProc);
      }
      else
      {
         substList = pDynamicSubListHolder->
               getPayMethodSubList (transType, fileProc, currency);
      }
      if (!substList.empty ())
      {
         setFieldAllSubstituteValues (ifds::PayMethod, idDataGroup, substList);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateCurrency ( const DString &currency,
                                   const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateCurrency"));
//nothing much in here, check Purchase/Redemption/Transfers
//transfers should not call the base class method
//for them settle currency is not required, (set in doInitWithDefaultValues)
//and is read only
   setFieldRequired ( ifds::SettleCurrency, 
                      idDataGroup, 
                      !( _multiCurrency == N && 
                        ( hasAllocations (idDataGroup) || 
                          isFullRedemption (idDataGroup) ||
                          canCloseAccount (idDataGroup))));
   return GETCURRENTHIGHESTSEVERITY ();
}


//******************************************************************************
SEVERITY Trade::validateCurrencyTaxType ( const DString &accountNum_, 
                                          const DString &currency_, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("validateCurrencyTaxType"));

   DString currChkByTaxType;

   getWorkSession ().getOption ( ifds::CurrChkByTaxType, 
                                 currChkByTaxType, 
                                 BF::HOST, 
                                 false);
   currChkByTaxType.strip().upperCase();
   if (currChkByTaxType == Y)
   {
//    if View-83 : CurrChkByTaxType ( active flag) is 'Y', please perform the following checking :
//    if the input currency is in the InvalidCurr AND input taxtype is in the TaxTypeByCurrChk, 
//    then return false ( invalid combination). Else return true.
//    View-83 : InvalidCurr (list of currency code with ',' in between)
//    View-83 : TaxTypeByCurrChk ( list of tax type with ',' in between)
      DString accountNum (accountNum_),
         currency (currency_);
      
      accountNum.strip ().stripLeading ('0');
      MFAccount *pMFAccount = NULL;
      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING && 
           pMFAccount
         )
      {
         DString taxType,
            invalidCurr,
            taxTypeByCurrChk;

         pMFAccount->getField (ifds::TaxType, taxType, idDataGroup);
         getWorkSession().getOption ( ifds::TaxTypeByCurrChk,
                                      taxTypeByCurrChk,
                                      BF::HOST,
                                      false);
         getWorkSession().getOption ( ifds::InvalidCurr,
                                      invalidCurr,
                                      BF::HOST,
                                      false);
         if ( DSTCommonFunctions::codeInList (taxType, taxTypeByCurrChk) &&
              DSTCommonFunctions::codeInList (currency, invalidCurr))
         {
            ADDCONDITIONFROMFILE (CND::ERR_TAX_TYPE_CANNOT_TRADE_IN_THE_CURRENCY);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::setSettleCurrencyFromFund ( const DString &fundCode, 
                                            const DString &classCode, 
                                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setSettleCurrencyFromFund"));
   if ( !fundCode.empty() &&
        !classCode.empty())
   {
      DString fundCurrency;

      getFundField (fundCode, classCode, ifds::Currency, fundCurrency);
      if (_multiCurrency == N)
      {
         if (!_bInitPending)
         {
            setFieldNoValidate ( ifds::SettleCurrency, fundCurrency, idDataGroup, false, 
                                 false, //not valid
                                 true);  //side effect
         }
      }
   //if multi currency is active, then look at 'TrxSettCurrRefresh' the generic control,
   //to determine the default value of the settlement currency
      else if (_multiCurrency == Y)
      {
//PET1117.FN6.R6
         //first set the settlement currency subst set
         settleCurrencyRelatedChanges (idDataGroup);

         DString trxSettCurrRefresh,
            apiFundCurrency,
            settleCurrency;

         getField (ifds::FundCurrency, apiFundCurrency, idDataGroup, false);
         apiFundCurrency.strip ();
         getField (ifds::SettleCurrency, settleCurrency, idDataGroup, false);
         settleCurrency.strip();
		 //only set settelment currency to fund currency, only if settl currency is not set at acct level .
		 //if set at acc level this gets preceedence over the TradeDefult GC.
		 bool bAcctlevelDefaultCurr = false;
		 MFAccount *pMFAccount = NULL;
		 DString dstrAccDefaultCurrency,dstrAccountNum ;
		 getField (ifds::AccountNum, dstrAccountNum , idDataGroup);
		 if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) 
			<= WARNING && pMFAccount)
		 {
			pMFAccount->getField (ifds::SettleCurrency, dstrAccDefaultCurrency, idDataGroup);
			if(!dstrAccDefaultCurrency.empty())
			bAcctlevelDefaultCurr = true;
		 }
         getWorkSession().getOption ( ifds::TrxSettCurrRefresh, 
                                      trxSettCurrRefresh, 
                                      BF::HOST, 
                                      false);
         trxSettCurrRefresh.strip();
         //PET 1117/66/67/68, API conflicts with Desktop on-line 
         //this flag should be set to '0' if we are in a server context
         if (bfutil::isServerContext())
         {
            trxSettCurrRefresh = I_("0");
         }
         if (trxSettCurrRefresh == I_("0"))
         {
            //set settlement currency to fund currency if blank
            if (settleCurrency.empty())
            {
               if (!_bInitPending)
               {
                  setFieldNoValidate ( ifds::SettleCurrency, fundCurrency, idDataGroup, false, 
                                       false, //not valid
                                       true);  //side effect
               }
            }
         }
         else if (trxSettCurrRefresh == I_("1"))
         {
		 //set settlement currency to fund currency, always if no acct level default is defined
          if (!_bInitPending && !bAcctlevelDefaultCurr )
            {
                  setFieldNoValidate ( ifds::SettleCurrency, fundCurrency, idDataGroup, false, 
                                       false, //not valid
                                       true);  //side effect
            }
         }
         else if (trxSettCurrRefresh == I_("2"))
         {
            //set settlement currency to blank
            if (!_bInitPending)
            {
               setFieldNoValidate ( ifds::SettleCurrency, NULL_STRING, idDataGroup, false, 
                                    false, //not valid
                                    true);  //side effect
            }
         }
      }
   }
   else if (hasAllocations (idDataGroup) && _multiCurrency == N)
   {
      TradeFundAllocList *pTradeFundAllocList = NULL;
      
      if (getFundAllocationList (pTradeFundAllocList, idDataGroup, false) <= WARNING)
      {
         DString currency;

         pTradeFundAllocList->getAllocCurrency (currency, idDataGroup);
         if (!currency.empty ())
         {
            //try to set a settlement currency
            if (!_bInitPending)
            {
               setFieldNoValidate ( ifds::SettleCurrency, currency, idDataGroup, false, 
                                    false, //not valid
                                    true);  //side effect
            }
         }
      }
      else  
      {
         //the method itself will determine whether the currency needs to be set or not...
         setAccountHoldingsCurrency (idDataGroup);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}


//******************************************************************************
SEVERITY Trade::settleCurrencyRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("settleCurrencyRelatedChanges"));

   if (_multiCurrency == Y)
   {
      if (_dstrDefaultSettleCurrencySet.empty())
      {
         BFProperties *pProperties = 
	       getFieldProperties (ifds::SettleCurrency, BF::HOST);

         pProperties->getAllSubstituteValues (_dstrDefaultSettleCurrencySet);
      }

      DynamicSubListHolder* pDynamicSubListHolder = 
         getMgmtCo ().getDynamicSubListHolder ();

      assert (pDynamicSubListHolder);

      DString payMethod, 
         transType,
         fileProcessor,
         substList,
         payType;

      getField (ifds::PayMethod, payMethod, idDataGroup, false);
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::ACHProcessor, fileProcessor, idDataGroup, false);
      getField (ifds::TradesPayType, payType, idDataGroup, false);
      if (!fileProcessor.empty ())
      {
         substList = pDynamicSubListHolder->
            getCurrencySubList ( transType,
                                 payType == PAYTYPE::EFT ? payMethod : NULL_STRING, 
                                 fileProcessor);
      }
      else
      {
         substList = pDynamicSubListHolder->
               getCurrencySubList ( transType, 
                                    payType == PAYTYPE::EFT ? payMethod : NULL_STRING);
      }
      if (substList.empty ())
      { 
         substList = _dstrDefaultSettleCurrencySet;
      }

      assert (!substList.empty ()); //at this point subst set shouldn't be empty

//PET1117.FN6.R6
      DString filteredSubstList;

      filterSettleCurrencyForFund ( substList,           //in list
                                    filteredSubstList,   //out list 
                                    idDataGroup);
      if (!filteredSubstList.empty())
      {
         substList = filteredSubstList;//save the filtered list
      }
//set the substitution set on to the field
      setFieldAllSubstituteValues (ifds::SettleCurrency, idDataGroup, substList);
	  //filter based on Tax type rule and set to account default currency if valid
	  //except for transfers and exchanges
	  if(!substList.empty()&& !isExchangeLike (idDataGroup))
	  {
		  DString   dstrAccountNum,dstroutTaxCurrencySet;
		  MFAccount *pMFAccount = NULL;
		  getField (ifds::AccountNum, dstrAccountNum , idDataGroup);
		  if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) 
			  <= WARNING && pMFAccount)
		  {
			  //get the tax type  
			  TaxTypeRule *pTaxTypeRule = NULL;
			  DString dstrTaxCurrency,dstrAccDefaultCurrency;
			  if ( pMFAccount->getTaxTypeRule( pTaxTypeRule, idDataGroup ) <= WARNING && pTaxTypeRule )
			  {
				  pTaxTypeRule->getField (ifds::TaxTypeRuleCurrSet, dstrTaxCurrency, idDataGroup, false);
				  filterSettleCurrencybyTaxTypeRule(substList,dstrTaxCurrency,dstroutTaxCurrencySet,idDataGroup);
				  substList = dstroutTaxCurrencySet;
			  }
			  setFieldAllSubstituteValues (ifds::SettleCurrency, idDataGroup, substList);
				if(!_bInitPending)  	 //if for pending trade  dont reset it..
{   //get Account default currency and check if it is in the list....
					bool bValidDefaultAccCurrency = false;

               DString dstrCurrSettleCurrency;
               getField(ifds::SettleCurrency, dstrCurrSettleCurrency, idDataGroup, false);
               dstrCurrSettleCurrency.strip().upperCase();
               bool bValidSettleCurrency = !dstrCurrSettleCurrency.empty() && 
                     substList.find(dstrCurrSettleCurrency+I_("=")) != DString::npos;

               DString dstrCurrencyCode;
					pMFAccount->getField (ifds::SettleCurrency, dstrAccDefaultCurrency, idDataGroup);
					dstrAccDefaultCurrency.strip().upperCase();
 					if (!dstrAccDefaultCurrency.empty() && substList.find(dstrAccDefaultCurrency+I_("=")) != DString::npos)
               {
                  bValidDefaultAccCurrency  = true;
               }

               if(!bValidSettleCurrency)
               {
                  if(bValidDefaultAccCurrency)
					   {
						   //set the default selection to account level settelment currency.... 
						   setFieldNoValidate ( ifds::SettleCurrency, dstrAccDefaultCurrency, idDataGroup, 
							   false, false, false, true); 
					   }
					   else
					   {
						   //set the Fund currency as the defualt here ....		
						   DString dstrFundCurrency;
						   pMFAccount->getField(ifds::FundCurrency,dstrFundCurrency,idDataGroup);
						   if(!dstrFundCurrency.strip().empty())
                        setFieldNoValidate ( ifds::SettleCurrency, dstrFundCurrency, idDataGroup, false, false, false, true);
					   }
               }
				}				
		  }
	  }
//have to force validation, because substitute values have changed
      setFieldValid (ifds::SettleCurrency, idDataGroup, false);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
inline SEVERITY Trade::filterSettleCurrencyForFund ( const DString &inCurrSubstList, 
                                                     DString &currSubstList,
                                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("filterCurrencyForFund "));
//implementation in Purchase/Redemption/Rollover
   currSubstList = inCurrSubstList; //default implementation
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::filterSettleCurrencyForFund ( const DString &fundCode,
                                              const DString &classCode,
                                              const DString &inCurrSubstList,
                                              DString &currSubstList,
                                              const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("filterCurrencyForFund"));
//filter based on the fund field 'ValidSettleCurr'
   DString validSettleCurr;

   currSubstList = NULL_STRING;
   getFundField (fundCode, classCode, ifds::ValidSettleCurr, validSettleCurr);
   if (!validSettleCurr.empty())
   {
      I_CHAR *temp = const_cast<I_CHAR*> (inCurrSubstList.c_str ());

      do
      {
         DString currencyCode,
            currencyDescr;

         temp = parseIdiString (temp, currencyCode, currencyDescr);         
//find if currency code is valid
         if (isCodeInList (currencyCode, validSettleCurr))
         {
            currSubstList += currencyCode + I_("=") + currencyDescr + I_(";");
         }
      } while (temp && temp != NULL_STRING && *temp);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

/******************************************************************************
InPut :	DString inCurrentSubList,DString  TaxRuleCurrencySet,BFDataGroupId &idDataGroup
Out :   DString (Either a subset of both the input strings or the entire strinSubList )
Return:Severity

Functionality:
1.	Function take in the Fund and Tax currency settlement currency sets and returns an subset of Fund Settlement Currency Set which is common for Fund and TaxType
2.	If no match found it returns the inputcurrency set itself.

******************************************************************************/
SEVERITY Trade::filterSettleCurrencybyTaxTypeRule(const DString &dstrinSubList,const DString &dstrTaxTypeRuleCurrSet,
												  DString &dstroutCurrencySet,const BFDataGroupId &idDataGroup)
{

 MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("FilterSettleCurrencybyTaxTypeRule"));

   //filter based on the tax rules 'ValidSettleCurr'
   dstroutCurrencySet = NULL_STRING;
   if (!dstrTaxTypeRuleCurrSet.empty())
   {
      I_CHAR *temp = const_cast<I_CHAR*> (dstrinSubList.c_str ());
      
      do
      {
         DString currencyCode,
            currencyDescr;

         temp = parseIdiString (temp, currencyCode, currencyDescr);         
         if (isCodeInList (currencyCode, dstrTaxTypeRuleCurrSet))
         {
            dstroutCurrencySet += currencyCode + I_("=") + currencyDescr + I_(";");
         }
      } while (temp && temp != NULL_STRING && *temp);
             
   }
   if(dstroutCurrencySet.empty())   
	dstroutCurrencySet = dstrinSubList;
   
   return GETCURRENTHIGHESTSEVERITY ();
 
}


//******************************************************************************
SEVERITY Trade::payMethodRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("payMethodRelatedChanges"));

   bool bIsFileProcApplic = isFileProccessorApplicable (idDataGroup);

   if (bIsFileProcApplic)
   {      
      bankingRelatedChanges (idDataGroup);
      addressRelatedChanges (idDataGroup);
//load subst list for currency
      settleCurrencyRelatedChanges (idDataGroup);
//load subst list for ACHProcessor
      fileProcessorRelatedChanges (idDataGroup);
      payMethodPropertyChanges (idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::removeTradeBankInstructionsList (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("removeTradeBankInstructionsList"));
//blow the banking list
   BFObjIter iter (*this, idDataGroup);

   iter.positionByKey (I_("Trade_BankInstructionsList"));
   if (!iter.end ())
   {
      iter.removeObjectFromMap (true);
//clear the bank fields
      clearBankFields (idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::clearBankFields (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("clearBankFields"));

   BFFieldId bankFields[] = //bank fields array
   { ifds::BankIdType,
     ifds::BankIdValue,   
     ifds::TransitNo,     
     ifds::InstName,      
     ifds::BankPostal,    
     ifds::BankCountry,   
     ifds::BankContact,   
     ifds::BankAddr1,     
     ifds::BankAddr2,     
     ifds::BankAddr3,     
     ifds::BankAddr4,     
     ifds::BankAddr5,       
     ifds::BankId,        
     ifds::BankIdTypeCB,  
     ifds::BankIdValueCB, 
     ifds::TransitNoCB,   
     ifds::InstNameCB,    
     ifds::BankPostalCB,  
     ifds::BankCountryCB, 
     ifds::BankContactCB, 
     ifds::BankAddrCB1,   
     ifds::BankAddrCB2,   
     ifds::BankAddrCB3,   
     ifds::BankAddrCB4,   
     ifds::BankAddrCB5,   
//            ifds::CorrespBankId, 
     ifds::BankAcctNum,      
     ifds::BankAcctType,     
     ifds::BankAcctName,   
//            ifds::AcctUseCode,    
     ifds::SwiftCode,        
     ifds::RefNumber,        
//            ifds::BankAcctCurrency, 
     ifds::PayReason1,       
     ifds::PayReason2,
     ifds::FFC,
     ifds::FFC1,
     ifds::NullFieldId
   };    

   int i = 0;

   for ( BFFieldId idField = bankFields [i]; 
         idField != ifds::NullFieldId;
         idField = bankFields [i++])
    {
      setFieldNoValidate ( idField, NULL_STRING, idDataGroup,  false, 
                           true, 
                           true); //notify
    }
   return GETCURRENTHIGHESTSEVERITY ();
}

//rep info validation/related changes methods
//******************************************************************************
SEVERITY Trade::checkIfBrokerEffective (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("checkIfBrokerEffective"));
   Broker *pBroker = NULL;

   if ( getBroker (pBroker, idDataGroup) <= WARNING &&
        pBroker)
   {
      DString tradeDate;

      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      pBroker->checkEffective (tradeDate, idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::checkIfBranchEffective (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("checkIfBranchEffective"));
   Branch *pBranch = NULL;

   if ( getBranch (pBranch, idDataGroup) <= WARNING &&
        pBranch)
   {
      DString tradeDate;

      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      pBranch->checkEffective (tradeDate, idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::checkIfAgentEffective (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("checkIfAgentEffective"));
   Agent *pAgent = NULL;

   if ( getAgent (pAgent, idDataGroup) <= WARNING &&
        pAgent)
   {
      DString tradeDate;

      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      pAgent->checkEffective (tradeDate, idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validatePayTypeBroker (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validatePayTypeBroker"));
   
   DString payType;

   getField (ifds::TradesPayType, payType, idDataGroup, false);

   if (payType == PAYTYPE::DIRECT)
   {
      if (!isHouseBroker (idDataGroup))
      {
         ADDCONDITIONFROMFILE (CND::ERR_NON_HOUSE_BROKER_CAN_NOT_DO_DIRECT_TRADING);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//*********************************************************************************
SEVERITY Trade::getDefaultFundBrokerCode ( const DString &accountNum,
                                           const DString &fundCode,
                                           DString &defaultFundBrokerCode,
										   DString &dstrFdBrokerDefaultLevel,
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("getDefaultFundBrokerCode"));
   defaultFundBrokerCode = NULL_STRING;

   DString fundBrokerApplicable;

   getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                fundBrokerApplicable,
                                BF::HOST,
                                false);

   if (fundBrokerApplicable == Y)
   {
      DString strKey = I_("FundBrokerDefault_AccountNum=") + accountNum +
                       I_(";FundCode=") + fundCode;
      FundBrokerDefault *pFundBrokerDefault = 
            dynamic_cast <FundBrokerDefault*> (getObject (strKey, idDataGroup));

      if (!pFundBrokerDefault)
      {
         pFundBrokerDefault = new FundBrokerDefault (*this);   
         if (pFundBrokerDefault->init (fundCode, accountNum) <= WARNING)
         {
            setObject ( pFundBrokerDefault, 
                        strKey, 
                        OBJ_ACTIVITY_NONE, 
                        idDataGroup);
         }
         else
         {
            delete pFundBrokerDefault;
            pFundBrokerDefault = NULL;
         }
      }
      if (pFundBrokerDefault)
      {
         pFundBrokerDefault->getDefaultFundBrokerCode (defaultFundBrokerCode,dstrFdBrokerDefaultLevel, idDataGroup);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//*****************************************************************************
SEVERITY Trade::getFundBroker ( const DString &fundBrokerCode, 
                                FundBroker *&pFundBroker,
                                const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundBroker"));
   pFundBroker = NULL;

   DString fundBrokerApplicable;

   getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                fundBrokerApplicable,
                                BF::HOST,
                                false);

   if (fundBrokerApplicable == Y && !fundBrokerCode.empty()) //protection against erroneous calls
   {
      DString strKey = I_("FundBroker=") + fundBrokerCode;

      pFundBroker = dynamic_cast <FundBroker*> (getObject (strKey, idDataGroup));
      if (!pFundBroker)
      {
         FundBrokerList *pFundBrokerList = new FundBrokerList (*this);   

         if ( pFundBrokerList->init (fundBrokerCode, NULL_STRING, idDataGroup) <= WARNING &&
              pFundBrokerList->getFundBroker ( fundBrokerCode, 
                                               idDataGroup,
                                               pFundBroker) <= WARNING &&
              pFundBroker)
         {
            setObject ( pFundBroker, 
                        strKey, 
                        OBJ_ACTIVITY_NONE, 
                        idDataGroup);
         }
         else
         {
            delete pFundBrokerList;
            pFundBrokerList = NULL;
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//*********************************************************************************
bool Trade::isHouseBroker (const BFDataGroupId &idDataGroup)
{
   bool bHouseBroker = false;
   Broker *pBroker (NULL);

   if ( getBroker ( pBroker, 
                    idDataGroup) <= WARNING &&
        pBroker)
   {
      bHouseBroker = pBroker->isHouseBroker (idDataGroup);
   }
   return bHouseBroker;
}

//amount, amt type, gross net validation
//*********************************************************************************
SEVERITY Trade::getRedemptionValidation ( RedemptionValidation *&pRedemptionValidation,
                                          const BFDataGroupId &idDataGroup)
{

   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("getRedemptionValidation"));

   pRedemptionValidation = NULL;

   DString transType,
      fundCode, 
      classCode,
      amountType, 
      settleDate,
      settleCurrency,
      accountNum, 
      amount, 
      effectiveDate, 
      redCode,
      lsifCode,
      grossNet;

   getField (ifds::TradesTransType, transType, idDataGroup);
   getField (ifds::AccountNum, accountNum, idDataGroup);
   accountNum.stripLeading ('0').strip();
   getField (ifds::EffectiveDate, effectiveDate, idDataGroup, false);
   getField (ifds::FromFund, fundCode, idDataGroup);
   getField (ifds::FromClass, classCode, idDataGroup);
   getField (ifds::Amount, amount, idDataGroup);
   getField (ifds::AmtType, amountType, idDataGroup);
   getField (ifds::RedCode, redCode, idDataGroup);
   getField (ifds::SettleDate, settleDate, idDataGroup);
   getField (ifds::SettleCurrency, settleCurrency, idDataGroup);
   getField (ifds::LSIFCode, lsifCode, idDataGroup);
   getField (ifds::GrossOrNet, grossNet, idDataGroup);
   if (isNew() && grossNet.empty())
   {
      grossNet = YES;
   }
//   getField (ifds::Taxable, taxable, idDataGroup);
   transType.strip().upperCase();
   accountNum.strip();
   effectiveDate.strip();
   fundCode.strip().upperCase();
   classCode.strip().upperCase();
   amount.strip();
   amountType.strip().upperCase();
   redCode.strip().upperCase();
   settleDate.strip();
   settleCurrency.strip();
   lsifCode.strip().upperCase();

   if (!accountNum.empty())
   {
      DString strKey;

      RedemptionValidation::buildKey ( transType, 
                                       accountNum, 
                                       effectiveDate, 
                                       fundCode, 
                                       classCode, 
                                       amount, 
                                       amountType, 
                                       redCode, 
                                       settleDate, 
                                       settleCurrency, 
                                       lsifCode, 
                                       grossNet,
                                       strKey);
      pRedemptionValidation = 
            dynamic_cast<RedemptionValidation *> (BFCBO::getObject (strKey, idDataGroup));
      if (!pRedemptionValidation)
      {
         pRedemptionValidation = new RedemptionValidation (*this);
         if (pRedemptionValidation->init ( transType,
                                           accountNum,
                                           effectiveDate,    
                                           fundCode,
                                           classCode,        
                                           amount,
                                           amountType,       
                                           redCode,
                                           settleDate,       
                                           settleCurrency,
                                           lsifCode,
                                           grossNet,
                                           areTaxRatesAllowed (idDataGroup) ? Y : N) <= WARNING)
         {
            setObject ( pRedemptionValidation, 
                        strKey, 
                        OBJ_ACTIVITY_NONE, 
                        idDataGroup);
         }
         else
         {
            delete pRedemptionValidation;
            pRedemptionValidation = NULL;
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//***********************************************************************************
SEVERITY Trade::validateAmtType ( const DString &amtType, 
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAmtType"));
   if ( ( hasAllocations (idDataGroup) ||
          hasFromAllocations (idDataGroup)) &&
          amtType == I_("U")) //units
   {
      ADDCONDITIONFROMFILE (CND::ERR_UNIT_NOT_FOR_ALLOCATION);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//***********************************************************************************
inline SEVERITY Trade::validateAmtTypeGrossNet (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAmtTypeGrossNet"));
///purchases/redemptions/rollovers have implementations
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
// Amount cannot be greater than 999,999,999,999 
SEVERITY Trade::validateAmount ( const DString &amount, 
                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAmount"));

// purchase has additional logic
   double dec_amount = DSTCommonFunctions::convertToDouble (amount);
   
// cannot be  negative for all transtype; 
//empty implementation in ManualForeignCapGainAllocAdjustment
   validateNegativeAmount (amount, idDataGroup);
   if (dec_amount > 999999999999) //must be <= 12 digits
   {
      DString idiStr (DString (I_ ("Amount=")) + DString(I_("999,999,999,999.00")));
      ADDCONDITIONFROMFILEIDI (CND::ERR_AMOUNT_EXCEED_MAX_LIMIT, idiStr);
   }
   else if (dec_amount == 0) //purchase won't call this because error is raised if dec_amount is '0'
   {
      DString accountNum, 
         acctType;
      MFAccount *pMFAccount = NULL;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
           pMFAccount)
      {      
         pMFAccount->getField (ifds::AcctType, acctType, idDataGroup);
         if (acctType.strip ().upperCase () == I_("6")) //omnibus
         {
   // Full exchange/transfer out/redemption is not allowed for Ominibus Account Type
            ADDCONDITIONFROMFILE (CND::ERR_FULL_WITHDRAW_FOR_OMNIBUS_ACCT);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateSettleLocations (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateSettleLocations"));

   TradeSettlementLocationsList *pTradeSettlementLocationsList = NULL;

   if (!areMultipleSettleLocAllowed (idDataGroup))
   {
      // environment does not support multiple settlement instructions
      return GETCURRENTHIGHESTSEVERITY ();
   }

   if (getSettlementLocsList (pTradeSettlementLocationsList, idDataGroup, false) <= WARNING )
   {
      bool bNoInstructions = false;

      if (pTradeSettlementLocationsList == NULL)
      {
         bNoInstructions = true;
      }
      else
      {
         BFObjIter iter (*pTradeSettlementLocationsList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);
         iter.begin();

         if (iter.getNumberOfItemsInList() == 0)
         {
            bNoInstructions = true;
         }
      }

      if (bNoInstructions)
      {
         getErrMsg (IFASTERR::SETTL_LOC_IS_MISSING, 
                    CND::ERR_SETTL_LOC_IS_MISSING, 
                    CND::WARN_SETTL_LOC_IS_MISSING, 
                    idDataGroup); 
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
SEVERITY Trade::validateBeneficiaryAllocation (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateBeneficiaryAllocation"));

   RESPBeneficiaryAllocationList *pRESPBeneficiaryAllocationList = NULL;

   if (!areRESPBenefAllocationsAllowed (idDataGroup))
   {
      return GETCURRENTHIGHESTSEVERITY ();
   }

   if (getRESPBenefAllocationList (pRESPBeneficiaryAllocationList, idDataGroup, false) <= WARNING )
   {
      bool bNoAllocaitons = false;

      if (pRESPBeneficiaryAllocationList == NULL)
      {
         bNoAllocaitons = true;
      }
      else
      {
         BFObjIter iter (*pRESPBeneficiaryAllocationList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);
         iter.begin();

         if (iter.getNumberOfItemsInList() == 0)
         {
            bNoAllocaitons = true;
         }

		 if (pRESPBeneficiaryAllocationList)
		 {
			 DString tradeDate;
			     
			 getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);

			 pRESPBeneficiaryAllocationList->validateBeneficiaryEffectiveDate (tradeDate, idDataGroup);
		 }
      }

      if (bNoAllocaitons)
      {
		  
			ADDCONDITIONFROMFILE (CND::ERR_RESP_BENEF_ALLOCATIONS_MISSING);
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
SEVERITY Trade::validateAmountPrecision (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAmountPrecision"));
   DString chkRounding,
      amount;

   getField (ifds::Amount, amount, idDataGroup, false);
   getWorkSession ().getOption ( ifds::BusRounding, 
                                 chkRounding, 
                                 BF::HOST,
                                 false);

   // ensure only 2 decimals if business rounding is turned off
   if (chkRounding == N) 
   {
      if (DSTCommonFunctions::NumOfDecimals (amount) > 2)
      {
         ADDCONDITIONFROMFILE (CND::ERR_TWO_DECIMAL_POINT_ONLY);
      }
   }
   else
   {
   //only applies for redemption and purchase, 
   //also validate the precision, against the from fund
      DString currency,
         fundCode,
         classCode;

      
      double dec_amount = DSTCommonFunctions::convertToDouble (amount);
      
      getField (ifds::FromFund, fundCode, idDataGroup, false);
      getField (ifds::FromClass, classCode, idDataGroup, false);
      getField (ifds::SettleCurrency, currency, idDataGroup);
      if ( currency.empty() && 
           !fundCode.empty()&& 
           !classCode.empty())
      {
   //get the fund currency
         getFundField (fundCode, classCode, ifds::Currency, currency);
      }

   // get the currency list with the matching currency and compare number of decimal places
      CurrencyList *pCurrencyList = NULL;
      Currency *pCurrency = NULL;

      if (!currency.empty())
      {
         getMgmtCo ().getCurrencyList (pCurrencyList);

         if ( pCurrencyList && 
              pCurrencyList->getCurrency (currency, pCurrency, idDataGroup))
         {
            pCurrency->precisionOkay (amount, idDataGroup);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//**********************************************************
void Trade::getFormattedAmount ( const BFDataGroupId &idDataGroup, 
                                 DString &value) const
{
//format only if amount is valid
   if (getErrorState (ifds::Amount, idDataGroup) <= WARNING)
   {
      DString amtType, 
         settleCurrency;

      getField (ifds::AmtType, amtType, idDataGroup, false);
      amtType.strip ();
      getField (ifds::SettleCurrency, settleCurrency, idDataGroup, false);
      settleCurrency.strip ();

      if (amtType != I_("U"))
      {
         CurrencyClass::getFormattedValue (getWorkSession (), value, settleCurrency, amtType);
      }
      else
      {
         int iUnitsPrecision = 0;

         FundDetail *pFundDetail = NULL;
         DString unitsPrecision, 
				  unitsPrecisionAcct,
            fundCode, 
            classCode;

         getField (ifds::FromFund, fundCode, idDataGroup, false);
         getField (ifds::FromClass, classCode, idDataGroup, false);

		 if ( const_cast <Trade*>(this)->getAcctUnitsPrecision (unitsPrecisionAcct, idDataGroup) <= WARNING && !unitsPrecisionAcct.empty())
		 {
			 iUnitsPrecision = unitsPrecisionAcct.asInteger (); 
			 DSTCommonFunctions::formattedField (ifds::Amount, iUnitsPrecision, value); 
		 }
		 else
		 {
         if ( const_cast <Trade*>(this)->
                  getFundField ( fundCode, classCode, ifds::UnitsPrecision, unitsPrecision) <= WARNING &&
              !unitsPrecision.empty())
         {
            iUnitsPrecision = unitsPrecision.asInteger (); 
         }
		 }
         DSTCommonFunctions::formattedField (ifds::USDollar, iUnitsPrecision, value); 
      }
   }
   else //use a default formatter
   {
      formatField (ifds::Amount, value, idDataGroup);
   }
}

//******************************************************************************
SEVERITY Trade::validateAmountAmtType (const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAmountAmtType"));

//if amount type is percentage, amount can not be greater than 100
   DString amtType,
      amount;

   getField (ifds::Amount, amount, idDataGroup, false);
   getField (ifds::AmtType, amtType, idDataGroup, false);

   double dec_amount = DSTCommonFunctions::convertToDouble (amount);
   
   if (dec_amount > 100 && amtType == I_("P"))
   {
      ADDCONDITIONFROMFILE (CND::ERR_PERCENTAGE_HOLDINGS_OVER_100);
   }
   else
   {
      DString strAmt (amount);

      strAmt.stripAll ().stripAll ('.').stripAll (',').stripAll ('0');
      if (!strAmt.empty () && amtType == I_("F")) //free units
      {
         ADDCONDITIONFROMFILE (CND::ERR_ZERO_AMOUNT_ALL_FREE_UNITS);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//***********************************************************************************
SEVERITY Trade::validateMinFromFundAmount (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateMinFromFundAmount"));
   
   DString amtType,
      amount,
      fundCode,
      classCode,
      accountNum,
      broker,
      branch,
      slsrep,
      depositType; //in1419539

   getField (ifds::AmtType, amtType, idDataGroup);
   getField (ifds::Amount, amount, idDataGroup);
   //the 'from side'
   getField (ifds::FromFund, fundCode, idDataGroup);
   getField (ifds::FromClass, classCode, idDataGroup);
   getField (ifds::AccountNum, accountNum, idDataGroup);
   getField (ifds::Broker, broker, idDataGroup); 
   getField (ifds::Branch, branch, idDataGroup);
   getField (ifds::SlsrepCode, slsrep, idDataGroup);
   getField (ifds::DepositType, depositType, idDataGroup); //in1419539

   accountNum.stripLeading ('0').strip();
   if ( !accountNum.empty() && 
        !fundCode.empty() && 
        !classCode.empty() &&
        amtType == I_("D") || //amount
        amtType == I_("U") || //units
        amtType == I_("P"))   //percentage
   {
      validateMinFromFundAmount ( accountNum,
                                  fundCode,
                                  classCode,
                                  amtType,
                                  amount,
                                  broker,
                                  branch,
                                  slsrep,
                                  depositType, //in1419539
                                  idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//***********************************************************************************
SEVERITY Trade::validateMinFromFundAmount ( const DString &account,
                                            const DString &fundCode,
                                            const DString &classCode,
                                            const DString &amtType,
                                            const DString &amount,
                                            const DString &broker,
                                            const DString &branch,
                                            const DString &slsrep,
                                            const DString &depositType, //in1419539
                                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateMinFromFundAmount"));
//implementations in redemption/purchase/rollover
   return GETCURRENTHIGHESTSEVERITY ();

}

//***********************************************************************************
SEVERITY Trade::validateMinToFundAmount (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateMinFromFundAmount"));

   DString amtType,
      amount,
      fundCode,
      classCode,
      accountNum,
      broker,
      branch,
      slsrep,
      depositType; //in1419539

   getField (ifds::AmtType, amtType, idDataGroup);
   getField (ifds::Amount, amount, idDataGroup);
//the 'to side'
   getField (ifds::ToFund, fundCode, idDataGroup);
   getField (ifds::ToClass, classCode, idDataGroup);
   getField (ifds::AccountTo, accountNum, idDataGroup);
   getField (ifds::DepositType, depositType, idDataGroup); //in1419539

   MFAccount *pMFAccountTo = NULL;

    if (getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccountTo) <= WARNING && pMFAccountTo)
   {
      pMFAccountTo->getField (ifds::BrokerCode, broker, idDataGroup); 
      pMFAccountTo->getField (ifds::BranchCode, branch, idDataGroup);
      pMFAccountTo->getField (ifds::Slsrep, slsrep, idDataGroup);
    }

   if ( !accountNum.empty() && 
        !fundCode.empty() && 
        !classCode.empty() &&
		(amtType == I_("D") || amtType == I_("U")))  //amount
   {
      validateMinToFundAmount ( accountNum,
                                fundCode,
                                classCode,
                                amtType,
                                amount,
                                broker,
                                branch,
                                slsrep,
                                depositType, //in1419539
                                idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//***********************************************************************************
SEVERITY Trade::validateMinToFundAmount ( const DString &account,
                                          const DString &fundCode,
                                          const DString &classCode,
                                          const DString &amtType,
                                          const DString &amount,
                                          const DString &broker,
                                          const DString &branch,
                                          const DString &slsrep,
                                          const DString &depositType, //in1419539
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateMinToFundAmount"));
//implementations in transfer/exchange/rollover
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::amsMinAmtCheck ( const DString &transType,
                                 const DString &accountNum,
                                 const DString &fundCode, 
                                 const DString &classCode,
                                 const DString &amtType, 
                                 const DString &amount, 
                                 const DString &currency, 
                                 const DString &broker,
                                 const DString &branch,
                                 const DString &slsrep,
                                 const DString &depositType, //in1419539
                                 bool bOverrideFundLevelCheck,
								 const DString &tradeDate,
                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("amsMinimumAmtCheck"));
   if (!fundCode.empty() && !classCode.empty())
   {
      DString exchRate;
   
      getField (ifds::ExchRate, exchRate, idDataGroup, false);
      MFAccount *pMFAccount = NULL;

      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
           pMFAccount &&
           pMFAccount->isAMSAccount (idDataGroup))
      {
         DString amsCode;

         AmsMstrInfo* pAMSMstrInfo = NULL;
         AMSMstrList* pAMSMstrList = NULL;

         if ( pMFAccount->getAMSMstrList ( pAMSMstrList, 
                                           idDataGroup, 
                                           tradeDate) <= WARNING &&
              pAMSMstrList)
         {
            pMFAccount->getField (ifds::AMSCode, amsCode, idDataGroup, false);
            pAMSMstrList->getAMSMstrInfo ( I_("RB"),
                                           amsCode, 
                                           tradeDate, 
                                           pAMSMstrInfo, 
                                           idDataGroup);
            if (pAMSMstrInfo)
            {
               DString acctDesign,
                  accountType,
                  taxType,
                  shrNum;

               pMFAccount->getField (ifds::AcctDesignation, acctDesign, idDataGroup);
               pMFAccount->getField (ifds::AcctType, accountType, idDataGroup);
               pMFAccount->getField (ifds::TaxType, taxType, idDataGroup);
               pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup);

               Shareholder *pShareholder = NULL;
               if ( getWorkSession ().
                      getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING &&
                    pShareholder) 
               {
                  DString provResid, taxJuris;
                  DString dstrFromFund, dstrFromClass;
                  bool isFullExchgParentToParent = false;

                  pShareholder->getField (ifds::TaxJurisCode, taxJuris, idDataGroup);
                  pShareholder->getField (ifds::ResProvCode, provResid, idDataGroup);  

                  getField(ifds::FromFund, dstrFromFund, idDataGroup);
                  getField(ifds::FromClass, dstrFromClass, idDataGroup);

                  isFullExchgParentToParent = isFullExchgParentFndClsToParentFndCls(idDataGroup, dstrFromFund, dstrFromClass, fundCode, classCode);

                  amsFundClassTradeMinAmtCheck ( transType, 
                                                 accountNum,
                                                 fundCode, 
                                                 classCode,
                                                 amtType, 
                                                 amount, 
                                                 currency, 
                                                 exchRate, 
                                                 tradeDate, 
                                                 broker,
                                                 branch,
                                                 slsrep,
                                                 depositType, //in1419539
                                                 //ams   
                                                 amsCode,
                                                 pAMSMstrInfo,
                                                 taxJuris,
                                                 provResid,
                                                 accountType,
                                                 taxType,
                                                 acctDesign,
                                                 bOverrideFundLevelCheck,
                                                 idDataGroup,
                                                 isFullExchgParentToParent);
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//***********************************************************************************
SEVERITY Trade::validateFromSoftCapCheck (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFromSoftCapCheck"));
//implementations in purchase
   return GETCURRENTHIGHESTSEVERITY ();

}

//***********************************************************************************
SEVERITY Trade::validateToSoftCapCheck (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFromSoftCapCheck"));
//implementations in exchange
   return GETCURRENTHIGHESTSEVERITY ();

}

//******************************************************************************
SEVERITY Trade::fundClassTradeMinimumAmtCheck ( const DString &transType,
                                                const DString &accountNum,
                                                const DString &fundCode, 
                                                const DString &classCode,
                                                const DString &amtType, 
                                                const DString &amount, 
                                                const DString &currency, 
                                                DString &initPurch, 
                                                const DString &broker,
                                                const DString &branch,
                                                const DString &slsrep,
                                                const DString &depositType, //in1419539
												const DString &tradeDate,
                                                const BFDataGroupId &idDataGroup,
                                                bool bFullExchPrntToPrnt,
                                                const DString &Indc,
                                                const DString &adjForTransNum)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("fundClassTradeMinimum"));   
   if (!fundCode.empty() && !classCode.empty())
   {
      DString exchRate, depositType,orderType; //in1419539

      getField (ifds::ExchRate, exchRate, idDataGroup, false);
      getField (ifds::DepositType, depositType, idDataGroup); //in1419539
      getField (ifds::OrderType, orderType, idDataGroup);

      TradeMinAmtCheck *pTradeMinAmtCheck = NULL;
      DString strKey = 
         I_("TradeMinAmtCheck_Account=")  + accountNum +
         I_(";TransType=")    + transType +
         I_(";FundCode=")     + fundCode  +
         I_(";ClassCode=")    + classCode +
         I_(";AmtType=")      + amtType   +
         I_(";Amount=")       + amount    +
         I_(";Currency=")     + currency  +
         I_(";Broker=")       + broker    +
         I_("Branch=")        + branch    +
         I_("SlsRep=")        + slsrep    +
         I_("TradeDate=")     + tradeDate +
         I_("DepositType=")   + depositType+
         I_("OrderType=")     + orderType + //in1419539
         I_(";FullExchPrntToPrnt=")  + (bFullExchPrntToPrnt ? Y:N);

      pTradeMinAmtCheck = 
            dynamic_cast<TradeMinAmtCheck*> (getObject (strKey, idDataGroup));

      if (!pTradeMinAmtCheck)
      {
         pTradeMinAmtCheck = new TradeMinAmtCheck (*this);
         if ( pTradeMinAmtCheck->init ( accountNum, 
                                        fundCode, 
                                        classCode, 
                                        transType, 
                                        amtType,
                                        amount, 
                                        tradeDate, 
                                        currency, 
                                        exchRate,
                                        broker,
                                        branch,
                                        slsrep,
                                        NULL_STRING, // AMSCode
                                        NULL_STRING, // AMSType
                                        depositType, //in1419539
                                        orderType,
                                        true,
                                        bFullExchPrntToPrnt,
                                        Indc,
                                        adjForTransNum) <= WARNING)
         {
            setObject (pTradeMinAmtCheck, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
         }
         else
         {
            delete pTradeMinAmtCheck;
            pTradeMinAmtCheck = NULL;
         }
      }
      if (pTradeMinAmtCheck)
      {
         pTradeMinAmtCheck->addConditions ();
         pTradeMinAmtCheck->getField (ifds::InitPurch, initPurch, idDataGroup, false);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::fundClassSoftCapCheck ( const DString &transType,
                                        const DString &accountNum,
                                        const DString &fundCode, 
                                        const DString &classCode,
                                        const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("fundClassSoftCapCheck"));

   DString tradeDate;
   getField(ifds::EffectiveDate, tradeDate, idDataGroup, false);

   getWorkSession().fundClassSoftCappedCheck(accountNum, fundCode, classCode, transType, tradeDate, idDataGroup);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************    
bool Trade::isFullExchgParentFndClsToParentFndCls(const BFDataGroupId &idDataGroup,
                                        const DString &fromFund, 
                                        const DString &fromClass, 
                                        const DString &toFund, 
                                        const DString &toClass)
{
    FundDetail *pFromFund = NULL;
    FundDetail *pToFund = NULL;
    bool isParentToParent = false;
    DString amount;

    getField(ifds::Amount, amount, idDataGroup);

    if (fromFund != NULL_STRING && fromClass != NULL_STRING && 
        toFund != NULL_STRING && toClass != NULL_STRING &&
        getWorkSession().getFundDetail(fromFund, fromClass, idDataGroup, pFromFund) <= WARNING && pFromFund &&
        getWorkSession().getFundDetail(toFund, toClass, idDataGroup, pToFund) <= WARNING && pToFund &&
        pFromFund->isAMSParentFund(idDataGroup) &&
        pToFund->isAMSParentFund(idDataGroup))
    {
        isParentToParent = true;
    }

    return isParentToParent && DSTCommonFunctions::convertToDouble(amount) == 0.0;
}

//******************************************************************************        
SEVERITY Trade::amsFundClassTradeMinAmtCheck ( const DString &transType,
                                               const DString &accountNum,
                                               const DString &fundCode, 
                                               const DString &classCode,
                                               const DString &amtType, 
                                               const DString &amount, 
                                               const DString &currency, 
                                               const DString &exchRate, 
                                               const DString &effectiveDate, 
                                               const DString &broker,
                                               const DString &branch,
                                               const DString &slsrep,
                                               const DString &depositType, //in1419539
                                               //ams   
                                               const DString &amsCode,
                                               AmsMstrInfo *pAMSMstrInfo,
                                               const DString &taxJuris,
                                               const DString &provResid,
                                               const DString &accountType,
                                               const DString &taxType,
                                               const DString &acctDesign,
                                               bool &bOverrideFundLevelCheck,
                                               const BFDataGroupId &idDataGroup,
                                               bool bFullExchPrntToPrnt)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("amsFundClassTradeMinAmtCheck"));

   return GETCURRENTHIGHESTSEVERITY ();
}

//***************************************************************************************************
inline SEVERITY Trade::validateFundBalance ( const DString &accountNum,
                                             const DString &fundCode,
                                             const DString &classCode,
                                             const DString &amount,
                                             const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundBalance"));
//method fully implemented in Redemption
   return GETCURRENTHIGHESTSEVERITY ();
}

//dates, time, validation
//***********************************************************************************
SEVERITY Trade::getTradeDateValidation ( DateValidation *&pTrade_DateValidation, 
                                         const DString &validationType,
                                         const DString &tradeDate, 
                                         const DString &settleDate, 
                                         const DString &depositDate,
                                         const DString &valueDate, 
                                         const DString &settleInDate, 
										 const DString &tradeInDate,
                                         const BFDataGroupId &idDataGroup)
{
    MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                            CLASSNAME, 
                            I_("getTradeDateValidation"));
    DString fundCode, 
            classCode, 
            payType, 
            transType, 
            broker, 
            brokerTo,
            orderType, 
            settleCurrency,
            dealDate, 
            dealTime, 
            toFund, 
            toClass, 
            amount, 
            amtType,
            dstrPageName = NULL_STRING,
            valuationDt,
            dstrNetworkID;

    DString AccountNum, toAccountNum;
    DString fromCurrency, toCurrency;
    DString frSettlCurrency, toSettlCurrency; 
	DString valuationInDate;

    getField (ifds::FromFund, fundCode, idDataGroup);
    getField (ifds::FromClass, classCode, idDataGroup);
    getField (ifds::ToFund, toFund, idDataGroup);
    getField (ifds::ToClass, toClass, idDataGroup);
    getField (ifds::Amount, amount, idDataGroup);
    getField (ifds::AmtType, amtType, idDataGroup);
    getField (ifds::SettleCurrency, settleCurrency, idDataGroup);
    getField (ifds::TradesTransType, transType, idDataGroup);
    getField (ifds::TradesPayType, payType, idDataGroup);
    getField (ifds::Broker, broker, idDataGroup);
    getField (ifds::OrderType, orderType, idDataGroup);
    getField (ifds::DealDate, dealDate, idDataGroup);
    getField (ifds::DealTime, dealTime, idDataGroup);
    getField (ifds::AccountNum, AccountNum, idDataGroup);
    getField (ifds::AccountTo, toAccountNum, idDataGroup);
    //getField (ifds::FromCurrency, fromCurrency, idDataGroup);
    //getField (ifds::ToCurrency, toCurrency, idDataGroup);
    getField (ifds::FrSettlCurrency, frSettlCurrency, idDataGroup);
    getField (ifds::ToSettlCurrency, toSettlCurrency, idDataGroup);
    getField (ifds::ValuationDt, valuationDt, idDataGroup);
    getField (ifds::NetworkID, dstrNetworkID, idDataGroup);
	getField (ifds::ValuationInDt, valuationInDate, idDataGroup);

    transType.strip ().upperCase ();
    settleCurrency.strip ().upperCase ();
    payType.strip ().upperCase ();
    orderType.strip ().upperCase ();
    fundCode.strip ().upperCase ();
    classCode.strip ().upperCase ();
    toFund.strip ().upperCase ();
    toClass.strip ().upperCase ();
    //fromCurrency.strip ().upperCase ();
    //toCurrency.strip ().upperCase ();
    frSettlCurrency.strip ().upperCase ();
    toSettlCurrency.strip ().upperCase ();   
    amount.strip ();
    amtType.strip ();
    valuationDt.strip ();
	valuationInDate.strip ();

    MFAccount *pMFAccountTo = NULL;
    if ( getWorkSession().getMFAccount (idDataGroup, toAccountNum, pMFAccountTo) <= WARNING && pMFAccountTo)
    {
       pMFAccountTo->getField (ifds::BrokerCode, brokerTo, idDataGroup);
    }
   
//call 135 always, even if fund and class are empty, for allocations...
//   if (!fundCode.empty() && !classCode.empty())

    {
        DString strKey;

        DateValidation::buildKey (  validationType,
                                    tradeDate,
                                    settleDate,
                                    depositDate,
                                    valueDate,
                                    transType,
                                    payType,
                                    broker,
                                    fundCode,
                                    classCode,
                                    toFund,
                                    toClass,
                                    orderType,
                                    dealDate,
                                    dealTime,
                                    settleCurrency,
                                    amount,
                                    amtType,
                                    strKey,
                                    AccountNum,
                                    toAccountNum,
                                    frSettlCurrency,
                                    toSettlCurrency,
                                    settleInDate,
                                    valuationDt,
                                    dstrNetworkID,
									tradeInDate,
									valuationInDate
                                   );
        pTrade_DateValidation = 
            dynamic_cast<DateValidation *> (getObject (strKey, idDataGroup));
        if (!pTrade_DateValidation)
        {
            pTrade_DateValidation = new DateValidation (*this);
            if (pTrade_DateValidation->init (   validationType,
                                                tradeDate,
                                                settleDate,
                                                depositDate,
                                                valueDate,
                                                transType,
                                                payType,
                                                broker,
                                                fundCode,
                                                classCode,
                                                toFund,
                                                toClass,
                                                orderType,
                                                dealDate,
                                                dealTime,
                                                settleCurrency,
                                                amount,
                                                amtType,
                                                settleInDate,
                                                brokerTo,
                                                AccountNum,
                                                toAccountNum,
                                                frSettlCurrency,
                                                toSettlCurrency,
                                                I_("N"),
                                                dstrPageName,
                                                valuationDt,
                                                dstrNetworkID,
												tradeInDate,
												valuationInDate) <= WARNING)
            {
                setObject (pTrade_DateValidation, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
            }
            else
            {
                delete pTrade_DateValidation;
                pTrade_DateValidation = NULL;
            }
        }
    }
    return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
void Trade::checkBackdatedTrade ( bool check)
{
   _bBackDateCheck = check;
}

//**********************************************************************************************
void Trade::initRebookBatch (const DString &rebookBatch, const BFDataGroupId &idDataGroup)
{
   setFieldNoValidate (ifds::BatchName, rebookBatch, idDataGroup, false);
   initBatch (idDataGroup);
}
//**********************************************************************************************
bool Trade::isBackdatedTrade (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isBackdatedTrade"));

   if (!_bBackDateCheck) return false;


   DString tradeDate,
      fundCode,
      classCode,
   // Incident #780304 -- default the trade default date to the current business date
      tradeDefaultDate (_currentBusinessDate);

   getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
   getField (ifds::FromFund, fundCode, idDataGroup, false);
   getField (ifds::FromClass, classCode, idDataGroup, false);

   if (!fundCode.empty() && !classCode.empty()) 
   {
      getFundField ( fundCode, 
                     classCode, 
                     ifds::NextValDate, 
                     tradeDefaultDate);
   }
   else //for allocated trade - keep the old logic
   {
      DateValidation *pTrade_DateValidation = NULL;
      DString  depositDate,
               settleDate,
               settleInDate,
               valueDate,
			   tradeInDate;

      getField (ifds::SettleDate, settleDate, idDataGroup, false);
      getField (ifds::SettleInDate, settleInDate, idDataGroup, false);
      getField (ifds::DepositDate, depositDate, idDataGroup, false);
      getField (ifds::ValueDate, valueDate, idDataGroup, false);
	  getField (ifds::TradeInDate, tradeInDate, idDataGroup, false);
      if ( getTradeDateValidation ( pTrade_DateValidation, 
                                    DATE_VALIDATION::DEFAULT_TRADE_DATE,
                                    tradeDate, 
                                    settleDate,
                                    depositDate,
                                    valueDate, 
                                    settleInDate,
									tradeInDate,
                                    idDataGroup) <= WARNING &&
            pTrade_DateValidation)
      {
         DString _tradeDefaultDate;
         pTrade_DateValidation->getField (ifds::TradeDate, _tradeDefaultDate, idDataGroup, false);
         if (!_tradeDefaultDate.empty ())
         {
            tradeDefaultDate = _tradeDefaultDate; 
         }
      }
      else
      {
   //remove errors - no need to display them
         int count = CONDITIONCOUNT();
         for (int i = 0; i < count; i++)
         {
            CLEARCONDITION( i );
         }
      }
   }
   return DSTCommonFunctions::CompareDates (tradeDate, tradeDefaultDate) == DSTCommonFunctions::FIRST_EARLIER;
}

//**********************************************************************************************
SEVERITY Trade::accountableBackdatedRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("accountableBackdatedRelatedChanges"));
//if back dated trade, accountable should be updatable otherwise, 
//this field should be blank same for BackDatedReason
   DString splitAcCode, 
           accountableMandatory, 
           fundSERVClient;
   bool bReadOnly = true;

   getWorkSession ().getOption ( ifds::SplitAcCode, 
                                 splitAcCode, 
                                 BF::HOST, 
                                 false);
   getWorkSession ().getOption ( ifds::AccountableMandatory, 
                                 accountableMandatory, 
                                 BF::HOST, 
                                 false);
   getWorkSession ().getOption ( ifds::FundSERVClient, 
                                 fundSERVClient, 
                                 BF::HOST, 
                                 false);

   DilutionAllocList *pDilutionAllocList = NULL;

   if ( getDilutionAllocList ( pDilutionAllocList, 
                               idDataGroup, 
                               true) <= WARNING &&
        pDilutionAllocList)
   {
      BFObjIter iter ( *pDilutionAllocList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      int numItems = iter.getNumberOfItemsInList ();

      if (iter.getNumberOfItemsInList() == 1)
      {
         setFieldReadOnly (ifds::Accountable, idDataGroup, false);
         setFieldReadOnly (ifds::BackDatedReason, idDataGroup, (splitAcCode == N && fundSERVClient == N));
         bReadOnly = false;
      }
   }
   if (bReadOnly)
   {
      setFieldReadOnly (ifds::Accountable, idDataGroup, true);
      setFieldReadOnly (ifds::BackDatedReason, idDataGroup, true);
      setFieldNoValidate ( ifds::Accountable, NULL_STRING, idDataGroup, false, 
                           true, 
                           true);
      setFieldNoValidate ( ifds::BackDatedReason, NULL_STRING, idDataGroup, false, 
                           true, 
                           true);
   }
   return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
SEVERITY Trade::validateDate ( const DString &validationType, 
                               const BFFieldId &idField, 
                               const DString &strValue, 
                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateDate"));

   DString fundCode,
      classCode,
      settleDateOverriden,
      valueDateOverriden;

   getField (ifds::FromFund, fundCode, idDataGroup, false);
   getField (ifds::FromClass, classCode, idDataGroup, false);   
   getField (ifds::SettleDateOverriden, settleDateOverriden, idDataGroup, false);  
   getField (ifds::ValueDateOverriden, valueDateOverriden, idDataGroup, false);  
//do not set the settle date if user touches the field... (in the dialog)
   
   bool bIsSettleDateOverriden = settleDateOverriden.strip().upperCase() == Y;
   bool bIsValueDateOverriden =  valueDateOverriden.strip().upperCase() == Y;
   
   //Do not set CashDate, if CashDate is overriden by User
   DString cashDateOverriden;
   getField (ifds::CashDateOverriden,cashDateOverriden, idDataGroup, false);   
   bool bIsCashDateOverriden = cashDateOverriden.strip().upperCase() == Y; 
   
   if ( (fundCode.empty () || classCode.empty ()) &&
       !(fundCode.empty () && classCode.empty ()))
   {
// if either fund or class or blank but not both, then wait until both are filled in before
// invoking view 135; if both fund and class are blank, then should continue to check if the input date is business date
      return GETCURRENTHIGHESTSEVERITY (); 
   }
   else if (validationType == DATE_VALIDATION::BUSINESS_DATE && strValue == _currentBusinessDate)
   {
// if the input value is already current business date, no need to validate with view 135 again
      return GETCURRENTHIGHESTSEVERITY (); 
   }
   else 
   {
      DString validationType_ (validationType),
         tradeDate_, 
         settleDate_,
         settleInDate_,
         depositDate_,
         valueDate_,
         orderType,
		 tradeInDate_,
		 valuationInDate_;

      getField (ifds::EffectiveDate, tradeDate_, idDataGroup);
      getField (ifds::SettleDate, settleDate_, idDataGroup);
      getField (ifds::SettleInDate, settleInDate_, idDataGroup, false);
      getField (ifds::DepositDate, depositDate_, idDataGroup);
      getField (ifds::ValueDate, valueDate_, idDataGroup);
      getField (ifds::OrderType, orderType, idDataGroup);
	  getField (ifds::TradeInDate,tradeInDate_,idDataGroup );
	  getField (ifds::ValuationInDt,valuationInDate_,idDataGroup);
      if ( validationType == DATE_VALIDATION::TRADE_DATE || 
           validationType == DATE_VALIDATION::DEFAULT_TRADE_DATE)
	  {
		  if (idField == ifds::EffectiveDate)
		  {
			  tradeDate_    = strValue;
			  if (!isXferInDateActive(idDataGroup) && validationType == DATE_VALIDATION::TRADE_DATE
                                                   && !isOneSideTrade(idDataGroup))
			  {
				   setFieldNoValidate ( ifds::TradeInDate, tradeDate_, idDataGroup, false, 
					false, 
					false,
					false); //notify
			  }
		  }
		  else if (idField == ifds::TradeInDate)
		  {
			  tradeInDate_    = strValue;
		  }
         if (!bIsSettleDateOverriden)
         {
            settleDate_   = strValue;
         }
         settleInDate_ = strValue;
      }
      else if (validationType == DATE_VALIDATION::INPUT_SETTLE_DATE && idField == ifds::SettleInDate)
      {
         settleInDate_ = strValue;
      }
      else if ( validationType == DATE_VALIDATION::SETTLE_DATE || 
                validationType == DATE_VALIDATION::INPUT_SETTLE_DATE)
      {
         settleDate_ = strValue;
// if both the fund and class are blank, check only if the input settlement date is a business date
         if (fundCode.empty () && classCode.empty ())
         {
            validationType_ = DATE_VALIDATION::BUSINESS_DATE;  // check if business date
            depositDate_ = settleDate_;
         }
      }
      else if (validationType == DATE_VALIDATION::BUSINESS_DATE)
      {
         depositDate_ = strValue;
      }
      else if ( validationType == DATE_VALIDATION::VALUE_DATE || 
                validationType == DATE_VALIDATION::DEFAULT_VALUE_DATE || 
                validationType == DATE_VALIDATION::DEFAULT_TRADE_DATE)
      {
         valueDate_ = strValue;
         if (validationType == DATE_VALIDATION::DEFAULT_VALUE_DATE)
         {
            validationType_ = DATE_VALIDATION::DEFAULT_TRADE_DATE;
         }
      }

      DateValidation *pTrade_DateValidation = NULL;

      if ( getTradeDateValidation ( pTrade_DateValidation, 
                                    validationType_, 
                                    tradeDate_, 
                                    settleDate_,
                                    depositDate_, 
                                    valueDate_, 
                                    settleInDate_,
									tradeInDate_,
                                    idDataGroup) <= WARNING &&
           pTrade_DateValidation)
      {
         DString  tradeDate, 
                  settleDate,
                  suggestedSettleInDate,
                  depositDate,
                  valueDate,
                  businessDate,
				  valuationDate,
				  tradeInDate,
				  valuationInDate,
				  cashDate;

         //read trade date
         pTrade_DateValidation->getField (ifds::TradeDate, tradeDate, idDataGroup, false); 
         //read settle date
         pTrade_DateValidation->getField (ifds::SettleDate, settleDate, idDataGroup, false);
         //read value date
         pTrade_DateValidation->getField (ifds::ValueDate, valueDate, idDataGroup, false);
         //reade business date
         pTrade_DateValidation->getField (ifds::EffectiveDate, businessDate, idDataGroup, false);
		  //read valuation date
         pTrade_DateValidation->getField (ifds::ValuationDt, valuationDate, idDataGroup, false);
         //read suggest settele in date
         pTrade_DateValidation->getField (ifds::SuggestSettleInDate, suggestedSettleInDate, idDataGroup, false);
		 // read TradeIn Date
		 pTrade_DateValidation->getField (ifds::TradeInDate, tradeInDate, idDataGroup, false);
		 // read ValuationIn Date
		 pTrade_DateValidation->getField (ifds::ValuationInDt, valuationInDate, idDataGroup, false);
		 //read CashDate Value
		 pTrade_DateValidation->getField (ifds::CashDate, cashDate, idDataGroup, false);
         if (bIsSettleDateOverriden && validationType_ == DATE_VALIDATION::TRADE_DATE && tradeDate.empty())
         {
            return GETCURRENTHIGHESTSEVERITY ();
         }
//assign proper values
         if ( validationType_ == DATE_VALIDATION::TRADE_DATE ||  
              validationType_ == DATE_VALIDATION::DEFAULT_TRADE_DATE ||
              validationType_ == DATE_VALIDATION::DEAL_TIME)
         {
            DString oldTradeDate, oldTradeInDate;

            getField (ifds::EffectiveDate, oldTradeDate, idDataGroup, false);
            if (oldTradeDate != tradeDate && !tradeDate.empty())
            {
               setFieldNoValidate ( ifds::EffectiveDate, tradeDate, idDataGroup, false, 
                                    false, 
                                    true); //notify

				if (!isXferInDateActive(idDataGroup) && validationType_ == DATE_VALIDATION::TRADE_DATE &&
					!isOneSideTrade(idDataGroup))
				{
				   setFieldNoValidate ( ifds::TradeInDate, tradeDate, idDataGroup, false, 
					false, 
					false,
					false); //notify
				}
			}
			getField (ifds::TradeInDate, oldTradeInDate, idDataGroup, false);
			if (oldTradeInDate != tradeInDate && !tradeInDate.empty() && 
				!isOneSideTrade(idDataGroup))
			{
				setFieldNoValidate ( ifds::TradeInDate, tradeInDate, idDataGroup, false, 
					false, 
					true); //notify			
			}
            
// if direct order and back dated trade then assign settlement date = CurrBusDate
            if (orderType == N || fundCode.empty()) //direct order and allocated trade
            {
               if (!bIsSettleDateOverriden)
               {
                  if ( DSTCommonFunctions::
                     CompareDates ( !tradeDate.empty() ? tradeDate : oldTradeDate, _currentBusinessDate) == 
                                    DSTCommonFunctions::FIRST_EARLIER)
                  {
                     setFieldNoValidate ( ifds::SettleDate, _currentBusinessDate, idDataGroup, false, 
                                          false, 
                                          true); //notify
					 if (!suggestedSettleInDate.empty () && !isOneSideTrade(idDataGroup))
                     {
                        setFieldNoValidate ( ifds::SettleInDate, suggestedSettleInDate, idDataGroup, false, 
                                       false, true); //notify
                     }

                  }
                  else
                  {
                     setFieldNoValidate ( ifds::SettleDate, !tradeDate.empty() ? tradeDate : oldTradeDate, idDataGroup, false, 
                                          false, 
                                          true); //notify
                     if (!suggestedSettleInDate.empty () && !isOneSideTrade(idDataGroup))
                     {
                        setFieldNoValidate ( ifds::SettleInDate, suggestedSettleInDate, idDataGroup, false, 
                                          false, true); //notify
                     }
                  }
               }
			   
			   DString emptyDate;
			   getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
			   if (!bIsCashDateOverriden && !cashDate.empty() && 
				   !(DSTCommonFunctions::CompareDates (!tradeDate.empty() ? tradeDate : oldTradeDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER))
			   {
				   setFieldNoValidate ( ifds::CashDate, cashDate, idDataGroup, false, 
										false, 
										true); 
			   }
			   else if(!isRebook() && !bIsCashDateOverriden && cashDate.empty() )
				 setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false,
									 false,
									 true);
            }
            else
            {
               DString oldSettleDate;

               getField (ifds::SettleDate, oldSettleDate, idDataGroup, false);

               if (!bIsSettleDateOverriden)
               {
                  if (!suggestedSettleInDate.empty () && !isOneSideTrade(idDataGroup))
                  {
                     setFieldNoValidate ( ifds::SettleInDate, suggestedSettleInDate, idDataGroup, false, 
                           false, true); //notify
                  }
                  // if view returns a new valid value
                  if (!settleDate.empty())
                  {                  
                     setFieldNoValidate ( ifds::SettleDate, settleDate, idDataGroup, false, 
                                          false, 
                                          true); //notify
                  }
                  // if original value is different from what was sent to the view side 
                  // because for Direct Order settleDate_ was assigned with trade date in the above code.
                  else if (oldSettleDate != settleDate_)
                  {
                     setFieldNoValidate ( ifds::SettleDate, settleDate_, idDataGroup, false, 
                                          false, 
                                          true); //notify
                  }
               }
			   DString emptyDate;
			   getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
			   if (!bIsCashDateOverriden && !cashDate.empty() && 
				   !(DSTCommonFunctions::CompareDates (!tradeDate.empty() ? tradeDate : oldTradeDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER))
			   {
				   setFieldNoValidate ( ifds::CashDate, cashDate, idDataGroup, false, 
										false, 
										true); 
			   }
			   else if(!isRebook() && !bIsCashDateOverriden && cashDate.empty() )
				 setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false,
									 false,
									 true);
			}
            if (validationType_ == DATE_VALIDATION::DEFAULT_TRADE_DATE)
            {
               DString oldDepositDate;
// Setting DepositDate to be TradeDate is for the purpose of running a multiple cycle,
// Trade Date has been changed toward following date, the Deposit date should be changed 
// correspondingly in order to support future date trading

               getField (ifds::DepositDate, oldDepositDate, idDataGroup, false);
               if (oldDepositDate != tradeDate && !tradeDate.empty())
               {
                  setFieldNoValidate ( ifds::DepositDate, tradeDate, idDataGroup, false, 
                                       false, 
                                       true); //notify
               }
               if (!valueDate.empty())
               {
                  setFieldNoValidate ( ifds::ValueDate, valueDate, idDataGroup, false, 
                                       false, 
                                       true); //notify
               }
			   if (!valuationDate.empty())
               {
			      setFieldNoValidate ( ifds::ValuationDt, valuationDate, idDataGroup, false, 
                                       false, 
                                       true); 				  
               }
			   if (!valuationInDate.empty())
			   {
				   setFieldNoValidate ( ifds::ValuationInDt, valuationInDate, idDataGroup, false, 
					   false, 
					   true); 
			   }
            }
         }
         else if ( validationType_ == DATE_VALIDATION::SETTLE_DATE || 
                   validationType_ == DATE_VALIDATION::INPUT_SETTLE_DATE)
         {
            if (!settleDate.empty())
            {
// if both fund and class are blank, dstrDepositDate has the settlement date value 
               setFieldNoValidate ( ifds::SettleDate, settleDate, idDataGroup, false, 
                                    false, 
                                    true); //notify
            }

            if (!suggestedSettleInDate.empty () && !isOneSideTrade(idDataGroup))
            {
               setFieldNoValidate ( ifds::SettleInDate, suggestedSettleInDate, idDataGroup, false, 
                                    false, true); //notify
            }
            
            // Set value from #135 to Redemption CBO
            if ((isRedemption (idDataGroup)|| isAllPurchase(idDataGroup) ) && /*orderType == Y &&*/ !valueDate.empty() ) 
            {
               setFieldNoValidate ( ifds::ValueDate, valueDate, idDataGroup, false, 
                                    false, 
                                    true); //notify
            }
			
			DString oldTradeDate,emptyDate;
			getField (ifds::EffectiveDate, oldTradeDate, idDataGroup, false);
			getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
			if (!bIsCashDateOverriden && !cashDate.empty() && 
				!(DSTCommonFunctions::CompareDates (!tradeDate.empty() ? tradeDate : oldTradeDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER))
			{
				setFieldNoValidate ( ifds::CashDate, cashDate, idDataGroup, false, 
									 false, 
									 true); 
			} 
			else if(!isRebook() && !bIsCashDateOverriden && cashDate.empty() )
				setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false,
									false,
									true);
         } 
         else if (validationType_ == DATE_VALIDATION::BUSINESS_DATE)
         {
            if (!businessDate.empty())
            {
               setFieldNoValidate ( idField, businessDate, idDataGroup, false, 
                                    false, 
                                    true); //notify
            }
         }
// refresh value date when 10026848:
// 1. if user change value date, 
// 2. if user change order type (trigger DEFAULT_VALUE_DATE)
// 3. if user change the trade date (TRADE_DATE)
// 4. if user change fund and trigger change of default trade date (DEFAULT_TRADE_DATE)
         if ( validationType_ == DATE_VALIDATION::VALUE_DATE || 
              validationType_ == DATE_VALIDATION::DEFAULT_VALUE_DATE ||
              validationType_ == DATE_VALIDATION::TRADE_DATE || 
              validationType_ == DATE_VALIDATION::DEFAULT_TRADE_DATE)
         {
   // 10026848 W.Shiu Feb 2004
   // Value date cannot be greater than the next cycle date. 
   // Value date comes back from view 135 could be less then next cycle date for direct trade,
   // therefore, extra logic is required to compare the value date with the current business date 
   // and assign value date with current business date if the value date from view 135 is less then 
   // the next cycle date (validation exists in Redemption.cpp) 
   // View 135 comes back with the correct value date (equal to the settlement date) for wire order 
   // therefore no special logic is required for wire order
			 if (isPurchase(idDataGroup))
			 {
				 if( !valueDate.empty()) 
				 {
					 setFieldNoValidate ( ifds::ValueDate, valueDate, idDataGroup, false, 
						 false, 
						 true); 
				 }
			 }
			 else
			 {
				 if ( orderType == N && // Direct Order
					 DSTCommonFunctions::
					 CompareDates (valueDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER) 
				 {
					 setFieldNoValidate ( ifds::ValueDate, _currentBusinessDate, idDataGroup, false, 
						 false, 
						 true); //notify
				 }
				 else 
				 {
					 //for wire orders and if users touch the settle date, value date should not be refreshed -
					 if (!valueDate.empty() && !bIsSettleDateOverriden) 
					 {
						 setFieldNoValidate ( ifds::ValueDate, valueDate, idDataGroup, false, 
							 false, 
							 true); //notify
					 }
				 }
			 }
			 if ( !valuationDate.empty() )
			 {
				 setFieldNoValidate ( ifds::ValuationDt, valuationDate, idDataGroup, false, 
					 false, 
					 true); 				  
			 }
			 if ( !valuationInDate.empty() )
			 {
				 setFieldNoValidate (ifds::ValuationInDt, valuationInDate, idDataGroup, false, 
					 false, 
					 true);
			 }
         }

         if (idField == ifds::EffectiveDate || idField == ifds::TradeInDate)
         {
            CONDITIONVECTOR *pConditionVector = NULL;
            
            getFieldConditionVector (idField, idDataGroup, pConditionVector);
//if any condition error codes are returned by view 135, just add them
            pTrade_DateValidation->addConditions (validationType_, idDataGroup,idField, pConditionVector);
            if (pConditionVector)
            {
               setFieldConditionVector (idField, idDataGroup, pConditionVector);
               //field should be valid with warnings on it...if any
               setFieldValid (idField, idDataGroup, true);            
            }
         }
		 if (idField == ifds::SettleDate)
		 {
			 CONDITIONVECTOR *pConditionVector = NULL;
            
            getFieldConditionVector (idField, idDataGroup, pConditionVector);
			//if any condition error codes are returned by view 135, just add them
            pTrade_DateValidation->addConditions (validationType_, idDataGroup,idField,pConditionVector);
            if (pConditionVector)
            {
               setFieldConditionVector (idField, idDataGroup, pConditionVector);
               //field should be valid with warnings on it...if any
               setFieldValid (ifds::SettleDate, idDataGroup, true);            
            }
		 }
		 else if (idField == ifds::SettleInDate)
		 {
			 CONDITIONVECTOR *pConditionVector = NULL;
            
            getFieldConditionVector (idField, idDataGroup, pConditionVector);
			//if any condition error codes are returned by view 135, just add them
            pTrade_DateValidation->addConditions (validationType_, idDataGroup,idField,pConditionVector);
            if (pConditionVector)
            {
               setFieldConditionVector (idField, idDataGroup, pConditionVector);
               //field should be valid with warnings on it...if any
               setFieldValid (ifds::SettleInDate, idDataGroup, true);            
            }
		 }
      } //return > WARNING
//just pick whatever conditions are on the frame and build a new condition vector with it...
//we do this for related changes...
      else 
      {
		  if (idField == ifds::EffectiveDate || idField == ifds::TradeInDate)
         {
            CONDITIONVECTOR *pConditionVector = NULL;
            int count = CONDITIONCOUNT ();

            if (count > 0)
            {
               pConditionVector = new CONDITIONVECTOR;
            }
            for (int i = 0; i < count; i++)
            {
// add conditions to the conditions vector
               Condition *c = new Condition (*GETCONDITION (i));

               pConditionVector->push_back (c);
            }
            if (pConditionVector)
            {
               setFieldConditionVector (idField, idDataGroup, pConditionVector);
               setFieldValid (ifds::EffectiveDate, idDataGroup, false);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//trade date validation
//***********************************************************************************
SEVERITY Trade::validateTradeDate ( const DString &tradeDate, 
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateTradeDate"));

   DString accountNum, dstrSAGESDEff;

   getField (ifds::AccountNum, accountNum, idDataGroup);
   accountNum.stripLeading ('0').strip();
   if (!getWorkSession().hasReadPermission (UAF::BACKDATE_TRADES))
   {
      if (DSTCommonFunctions::CompareDates (
            tradeDate, _currentBusinessDate) == DSTCommonFunctions::FIRST_EARLIER)
      {
         ADDCONDITIONFROMFILE (CND::ERR_BACKDATE_TRADE_NOT_ALLOWED);
      }
   }
   else if (!tradeDate.empty () && !_currentBusinessDate.empty ())
   {
      if (getYear (tradeDate) < getYear (_currentBusinessDate))
      {
         ADDCONDITIONFROMFILE (CND::ERR_TRADE_DATE_IN_PRIOR_YEAR);
      }
   }
   else 
   {
//if AccountNum is not Null or allocationAllowed is No and AccountNum is Null 
//and EffectiveDate is later than today, issue warning
      DString allocationAllowed;

      getWorkSession ().getOption ( ifds::InvAdvice, 
                                    allocationAllowed,
                                    BF::HOST,
                                    false);
      if ( !accountNum.empty () || 
           (accountNum.empty () && 
            allocationAllowed == N))
      {
         if (DSTCommonFunctions::
               CompareDates (_currentBusinessDate, tradeDate) == DSTCommonFunctions::FIRST_EARLIER)
         {
            ADDCONDITIONFROMFILE (CND::ERR_FUTURE_DATED_TRADE);
         }
      }
   }

   validateSegBackdates (idDataGroup);

   DString dstrAccountNum, dstrTaxType, dstrEffectivedate, dstrDepositType, dstrRedCode;
   MFAccount *pMFAccount = NULL;

   getField (ifds::AccountNum, dstrAccountNum, idDataGroup);
   getField( ifds::EffectiveDate, dstrEffectivedate, idDataGroup, false );
   getField( ifds::DepositType, dstrDepositType, idDataGroup);
   getField (ifds::RedCode, dstrRedCode, idDataGroup, false);
   dstrAccountNum.strip ().stripLeading ('0');
   dstrDepositType.strip();
   dstrRedCode.strip();

   if ( !tradeDate.empty() && 
	   getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && pMFAccount)
   {
      pMFAccount->getField (ifds::TaxType, dstrTaxType, idDataGroup);
      //if( dstrTaxType.strip().upperCase() == TFSA_TAX_TYPE )
      {
        DString strStart, strEnd, strStartDesc, strEndDesc, idiStr, strTransType;
		getField( ifds::TradesTransType, strTransType, idDataGroup);
		if( isCheckStartEndDate() )
		{
			TaxTypeRule *pTaxTypeRule = NULL;
			if ( pMFAccount->getTaxTypeRule( pTaxTypeRule, idDataGroup ) <= WARNING && pTaxTypeRule )
			{
				pTaxTypeRule->getField (ifds::TradeStartDate, strStart, idDataGroup, false);
				pTaxTypeRule->getField (ifds::TradeStopDate, strEnd, idDataGroup, false);

				if( ( !strStart.strip().empty() && DSTCommonFunctions::CompareDates (tradeDate, strStart) == DSTCommonFunctions::FIRST_EARLIER ) ||
					( !strEnd.strip().empty() && DSTCommonFunctions::CompareDates (strEnd, tradeDate) == DSTCommonFunctions::FIRST_EARLIER ) )
				{
					pTaxTypeRule->getField (ifds::TradeStartDate, strStartDesc, idDataGroup, true);
					pTaxTypeRule->getField (ifds::TradeStopDate, strEndDesc, idDataGroup, true);
					addIDITagValue (idiStr, I_("START"), strStartDesc);
					addIDITagValue (idiStr, I_("END"), strEndDesc);
					ADDCONDITIONFROMFILEIDI (CND::ERR_TRADE_DATE_OUTSIDE_MIN_MAX, idiStr);   
				}
		    }		
		 }
	  }
   }

   if (getWorkSession().isSAGESClient() && isRESPTradeAccount (idDataGroup) && (dstrDepositType == I_("35") || dstrRedCode == I_("SC"))) // SAGES Grant Payment or SAGES Correction
   {
	   DString siblingOnly, dstrEntityId, dstrTaxJuris;
	   bool bSiblingOnly = false, bBenefSKResident = false;

	   if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && pMFAccount)
	   {
		   pMFAccount->getField (ifds::SiblingOnly, siblingOnly, idDataGroup, false);
		   if (siblingOnly == Y)
			   bSiblingOnly = true;

		   AccountEntityXref *pAccountEntityXref = NULL;
		   if (getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING && pAccountEntityXref)
		   {
			   ENTITIES_VECTOR respBeneficiaryEntities;
			   getField (ifds::AccountNum, dstrAccountNum, idDataGroup, false);
			   pAccountEntityXref->getRESPBeneficiaryEntities (respBeneficiaryEntities, dstrAccountNum, idDataGroup);

			   for (ENTITIES_VECTOR::size_type i = 0; i < respBeneficiaryEntities.size(); ++i)
			   {
				   dstrEntityId = respBeneficiaryEntities [i];
				   Entity *pEntity = NULL;
				   if  (getWorkSession().getEntity (idDataGroup, dstrEntityId, pEntity) <= WARNING && pEntity)
				   {
					   pEntity->getField( ifds::TaxJuris, dstrTaxJuris, idDataGroup, false );
					   if(dstrTaxJuris == I_("0003")) // Saskatchewan 
					   {
						   bBenefSKResident = true;
						   break;
					   }
				   }
			   }
		   }
	   }

	   getWorkSession().getOption (ifds::SAGESDeff, dstrSAGESDEff, BF::HOST, false);
	   dstrSAGESDEff.stripAll();

	   //Trade date must be equal or greater than 01Jan2013 (SAGES effective date)
	   if (bSiblingOnly && bBenefSKResident && !dstrSAGESDEff.empty() && DSTCommonFunctions::CompareDates (tradeDate, dstrSAGESDEff) == DSTCommonFunctions::FIRST_EARLIER)
	   {
		    getErrMsg ( IFASTERR::TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_SAGESDEFF, 
						CND::ERR_TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_SAGESDEFF, 
						CND::WARN_TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_SAGESDEFF, 
						idDataGroup); 
	   }
   }
   DString dstrTransType;
   getField (ifds::TradesTransType, dstrTransType, idDataGroup);
   dstrTransType.stripAll().upperCase();
   if(dstrTransType == TRADETYPE::REFUND_REDEMPTION)
   {
	   DString dstrTransID, origtradeDate;
	   TransactionDetails *_pTransDetails = new TransactionDetails( *this );
	   getField(ifds::TransId, dstrTransID, idDataGroup);
	   if( (_pTransDetails->getDetails(dstrTransID)) <= WARNING )
	   {
		   _pTransDetails->getField(ifds::TradeDate, origtradeDate, idDataGroup);
		   if (DSTCommonFunctions::CompareDates (tradeDate, origtradeDate) == DSTCommonFunctions::FIRST_EARLIER)
		   {
			   ADDCONDITIONFROMFILE(CND::ERR_TRADE_DATE_MUST_BE_EQUAL_OR_GREATER_THAN_PURCHASE_DATE);
		   }
	   }
	   if(_pTransDetails)
		   delete _pTransDetails;
   }

   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::validateDepositDate ( const DString &depositDate,
                                      const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateDepositDate"));

   MFAccount *pMFAccount = NULL;      
   
   if ( getAccount (pMFAccount, idDataGroup) <= WARNING && pMFAccount)
   {
      DString taxType;

      pMFAccount->getField (ifds::TaxType, taxType, idDataGroup, false);
      taxType.upperCase ();
// if tax type = 2 (RRIF), B (LIF), BR (Restriced LIF)  L (LRIF) or R (PRIF), check if year of deposit date < year of trade date
      if (getWorkSession ().isIntRIFPlan (taxType)) 
      {
         DString tradeDate;

         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         if (!tradeDate.strip ().empty () && !depositDate.empty ())
         {
            if (getYear (depositDate) < getYear (tradeDate))
            {
// deposit date in previous year affects min/max amount
               ADDCONDITIONFROMFILE (CND::ERR_DEPOSIT_DATE_AFFECT_MIN_MAX_AMT);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::validateCashDate ( const DString &cashDate, 
                                   const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateCashDate"));

   DString fundCode, 
      classCode;

   getField (ifds::FromFund, fundCode,  idDataGroup);
   getField (ifds::FromClass, classCode, idDataGroup);
   if (!fundCode.empty () && !classCode.empty ())
   {
      // PTS 10038661 - This was added for the case when the Trade was placed through base
      // with CashDate blank and the validation is not applicable
      // it duplicates the code from setCashDateUpdateable!! 
      FundMasterList *pFundMasterList = NULL;
      if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING && pFundMasterList)
      {
         FundMaster *pFundMaster = NULL;
         if ( pFundMasterList->getFundMaster (fundCode, idDataGroup, pFundMaster) && 
               pFundMaster &&
               isCashDateUpdatable (pFundMaster, idDataGroup))
         {
            DString nextSettleDate, tradeDate, cashDate, dstrCashDateOverriden;

            getField (ifds::EffectiveDate, tradeDate, idDataGroup);
			getField (ifds::CashDate, cashDate, idDataGroup);
			getField (ifds::CashDateOverriden, dstrCashDateOverriden, idDataGroup, false);

			DString cashDateOverride;
			getWorkSession().getOption (ifds::OrderUserOverride, cashDateOverride, BF::HOST, false); // OrdEntryUserOverride attribute in PendingTradeCashDate function control: 01-no override, 02-override backdated trades, 03-override all	

// check if transaction is backdated
            if ( cashDateOverride == I_("02") &&
				getFundField ( fundCode, 
                                classCode, 
                                ifds::NextSettleDate, 
                                nextSettleDate ) <= WARNING &&
                  !DSTCommonFunctions::IsDateBetween (tradeDate, nextSettleDate, cashDate))
            {
				// 2240 - Invalid cash date.
				getErrMsg (IFASTERR::INVALID_CASH_DATE,
						   CND::ERR_INVALID_CASH_DATE,
						   CND::WARN_INVALID_CASH_DATE,
						   idDataGroup);				
            }
		
			bool bIsCashDateOverriden = (!isNew() && (dstrCashDateOverriden.strip().upperCase() == Y)) ? true : false;
			
			if (!bIsCashDateOverriden && DSTCommonFunctions::CompareDates (cashDate, tradeDate) == DSTCommonFunctions::FIRST_EARLIER)
			{				
					// 2241 - Overridden cash date should be greater than or equal to trade date.
					getErrMsg (IFASTERR::CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE,
							   CND::ERR_CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE,
							   CND::WARN_CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE,
							   idDataGroup);				
         }
      }
   }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************************************    
SEVERITY Trade::validateDealDate ( const DString &dealDate, 
                                   const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateDealDate"));

   DString dealDateTime;
   
   getWorkSession ().getOption ( ifds::DealDateTime, 
                                 dealDateTime, 
                                 BF::HOST, 
                                 false);

   if (dealDateTime == Y)
   {
//deal date cannot future dated      
      if (DSTCommonFunctions::CompareDates (_todayDate, dealDate) == DSTCommonFunctions::FIRST_EARLIER)
      {
         ADDCONDITIONFROMFILE (CND::ERR_FUTURE_DEAL_DATE);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************

SEVERITY Trade::validateSettleInDate ( const DString &dstrSettleInDate, 
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSettleInDate"));

   DString dstrSettleDate, dstrTradeInDate;

   getField( ifds::SettleDate, dstrSettleDate, idDataGroup, false );
   getField (ifds::TradeInDate, dstrTradeInDate, idDataGroup, false);

   if ( isXferInDateActive(idDataGroup) && DSTCommonFunctions:: CompareDates (dstrSettleInDate, dstrTradeInDate) == DSTCommonFunctions::FIRST_EARLIER)
   {
	   ADDCONDITIONFROMFILE (CND::ERR_SETTLEDATE_EARLIER_THAN_TRADEDATE);
   }
   else if (DSTCommonFunctions::CompareDates (dstrSettleInDate, dstrSettleDate) == DSTCommonFunctions::FIRST_EARLIER)
   {
	   ADDCONDITIONFROMFILE (CND::ERR_INVALID_SETTLEINDATE);
   }
   else
   {
      validateDate ( DATE_VALIDATION::INPUT_SETTLE_DATE, 
                     ifds::SettleInDate, dstrSettleInDate, idDataGroup);
   }

   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
SEVERITY Trade::validateDealTime ( const DString &dealTime,
                                   const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateDealTime"));

   DString dealDateTime;
   
   getWorkSession ().getOption ( ifds::DealDateTime, 
                                 dealDateTime, 
                                 BF::HOST, 
                                 false);
   if (dealDateTime == Y)
   {
      if (dealTime.empty())
      {
         ADDCONDITIONFROMFILE (CND::ERR_INVALID_TIME);
      }
      else
      {
         DString strTime (dealTime),
            strHour,
            strMin;
         DString::size_type iPos = strTime.find (I_(":"));
         int ihour,imin;

         if (iPos != std::string::npos)
         {
            strHour = strTime.substr (0,iPos);
            strMin =  strTime.substr (iPos+1, 2);
         }
         else
         {
            strHour = strTime.substr (0,2);
            strMin =  strTime.substr (2,2);
         }
         ihour = strHour.asInteger ();
         imin = strMin.asInteger ();
         if (ihour < 0 || ihour > 23 || imin < 0 || imin > 59)
         {
            ADDCONDITIONFROMFILE (CND::ERR_INVALID_TIME);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
inline SEVERITY Trade::validateValueDate ( const DString &valueDate, 
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateValueDate"));
//logic in redemption
   return  GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateAcctableTradeDate (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAcctableTradeDate"));

   DString accountable,
      tradeDate;

   getField (ifds::Accountable, accountable, idDataGroup);   
   getField (ifds::EffectiveDate, tradeDate, idDataGroup);   

   DilutionAllocList *pDilutionAllocList = NULL;
   
   if ( getDilutionAllocList ( pDilutionAllocList, 
                               idDataGroup, 
                               true ) <= WARNING &&
      pDilutionAllocList)
   {
      BFObjIter iter ( *pDilutionAllocList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      int numItems = iter.getNumberOfItemsInList ();
      
      if (iter.getNumberOfItemsInList() == 1 )
      {
         DString accountableMandatory, 
                 splitAcCode, 
                 backDatedReason,
                 fundSERVClient;

         getWorkSession ().getOption ( ifds::AccountableMandatory, 
                                       accountableMandatory, 
                                       BF::HOST,
                                       false);
         getWorkSession ().getOption ( ifds::SplitAcCode, 
                                       splitAcCode, 
                                       BF::HOST, 
                                       false);
         getWorkSession ().getOption ( ifds::FundSERVClient, 
                                       fundSERVClient, 
                                       BF::HOST, 
                                       false);
         getField (ifds::BackDatedReason, backDatedReason, idDataGroup, false);
         if (accountableMandatory == Y)
         {
            if (accountable.empty())
            {
               ADDCONDITIONFROMFILE (CND::ERR_ACCOUNTABILITY_FOR_BACKDATE_TRADE);
            }
            if ((splitAcCode == Y || (splitAcCode == N && fundSERVClient == Y)) && backDatedReason.empty())
            {
               ADDCONDITIONFROMFILE (CND::ERR_BACKDATEDREASON_FOR_BACKDATE_TRADE);
            }
         }
      }
      else if (!accountable.empty()) // must be blank if not backdated trade
      {
         ADDCONDITIONFROMFILE (CND::ERR_ACCOUNTABILITY_ONLY_FOR_BACKDATE_TRADE);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
void Trade::setCashDateUpdatable (const BFDataGroupId &idDataGroup)
{
	DString emptyDate, tradeDate, lastValDate, fundCode, classCode, cashDateOverride;
   bool blReadOnly = true;

	getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
	getWorkSession().getOption (ifds::OrderUserOverride, cashDateOverride, BF::HOST, false); // OrdEntryUserOverride attribute in PendingTradeCashDate function control: 01-no override, 02-override backdated trades, 03-override all	

   getField (ifds::FromFund, fundCode,  idDataGroup);
   getField (ifds::FromClass, classCode, idDataGroup);
   if (!fundCode.strip ().empty () && !classCode.strip ().empty ())
   {
      getField (ifds::EffectiveDate, tradeDate, idDataGroup);
         FundMasterList *pFundMasterList = NULL;
		if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&	pFundMasterList)
         {
            FundMaster *pFundMaster = NULL;
			if ( pFundMasterList->getFundMaster (fundCode, idDataGroup, pFundMaster) &&	 pFundMaster)
            {
				// Check if transaction is backdated, 02 - user can override Cash Date for backdated trades 
				if ( (cashDateOverride == I_("02")) && 
					  getFundField (fundCode, 
								    classCode, 
								    ifds::LastValDate, 
								    lastValDate) <= WARNING &&
								    DSTCommonFunctions::CompareDates (tradeDate, lastValDate) == DSTCommonFunctions::FIRST_EARLIER )
				{
				blReadOnly = !isCashDateUpdatable (pFundMaster, idDataGroup);
				if (blReadOnly)
				{
					blReadOnly = setCashDateUpdatable(tradeDate, idDataGroup);
						setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false,  true, true); 
				}
			}
				else if (cashDateOverride == I_("03") ) // 03 - user can override Cash Date for all trades
				{
					if (isOneSideTrade(idDataGroup))
					{
						blReadOnly = !isCashDateUpdatable (pFundMaster, idDataGroup);
		 }
					else
					{
						blReadOnly = (!isCashDateUpdatable (pFundMaster, idDataGroup) && setCashDateUpdatable(tradeDate, idDataGroup)) ? true : false;
	  }

					if ( getFundField (fundCode, 
									   classCode, 
									   ifds::LastValDate, 
									   lastValDate) <= WARNING &&
									   (DSTCommonFunctions::CompareDates (tradeDate, lastValDate) == DSTCommonFunctions::FIRST_EARLIER ||
										DSTCommonFunctions::CompareDates (tradeDate, lastValDate) == DSTCommonFunctions::EQUAL) )
					{
						DString dstrCashDateOverriden;
						getField(ifds::CashDateOverriden, dstrCashDateOverriden, idDataGroup, false);
						bool bIsCashDateOverriden = dstrCashDateOverriden.strip().upperCase() == Y;
						if(!bIsCashDateOverriden)
							setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false,  true, true); 
   }
				}
			}
		}
	}

	setFieldReadOnly (ifds::CashDate, idDataGroup, blReadOnly);

}
//******************************************************************************
bool Trade::setCashDateUpdatable( DString &tradeDate, const BFDataGroupId &idDataGroup )
{
	   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setCashDateUpdatable"));
   return true;
}

//******************************************************************************
bool Trade::isCashDateUpdatable ( FundMaster *pFundMaster,
                                  const BFDataGroupId &idDataGroup)
{
// Purchase will have additional validation, this is for any other trans type
   bool blUpdateable = false;
   DString fundType;

   pFundMaster->getField (ifds::FundType, fundType, BF::HOST, false); 
   fundType.strip().upperCase();
   if (fundType == FUND_TYPE::MONEY_MARKET) //money market fund
   {
      DString dividendType, 
         intFromDateType, 
         intToDateType;

      pFundMaster->getField (ifds::DividentType,    dividendType,    BF::HOST);
      pFundMaster->getField (ifds::IntFromDateType, intFromDateType, BF::HOST);
      pFundMaster->getField (ifds::IntToDateType,   intToDateType,   BF::HOST);

      dividendType.strip().upperCase();
      intFromDateType.strip().upperCase();
      intToDateType.strip().upperCase();
      blUpdateable = I_("S") == dividendType && 
                     I_("C") == intFromDateType || 
                     I_("C") == intToDateType;
   }  

   return blUpdateable;
}

//*****************************************************************************************
SEVERITY Trade::validateSettleSource ( const DString &settleSource, 
                                       const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSettleSource"));

// should be triggered in Redemption and Purchase

   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************************
SEVERITY Trade::commonValidateSettleSource( const DString &settleSource, 
                                            const BFDataGroupId &idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                            CLASSNAME, 
                            I_("commonValidateSettleSource"));

   MFAccount *pMFAccount = NULL;   
   if ( getAccount (pMFAccount, idDataGroup) <= WARNING  &&
        pMFAccount) 
   {
      DString acctDesignation,
              interCode;

      pMFAccount->getField (ifds::AcctDesignation, acctDesignation, idDataGroup, false);
      pMFAccount->getField (ifds::InterCode, interCode, idDataGroup, false);

// rule 1: Only AcctDesignation-4 = 3 is valid for Intermediary  
      if ( acctDesignation != I_("3") && 
           settleSource == I_( "I")) //intermedialry 
      {
         getErrMsg ( IFASTERR::INVALID_SETTLEMENT_SOURCE_FOR_ACCOUNT_DESIGNATION, 
                     CND::ERR_SETTLEMENT_SOURCE_NOT_FOR_ACCT_DESIGNATION, 
                     CND::ERR_WARN_SETTLEMENT_SOURCE_NOT_FOR_ACCT_DESIGNATION, 
                     idDataGroup); 
      }

// rule 4:only AcctDesignation-4 = 1,2,3 is valid for dstrSettleSrc = "D"
      bool bDealerAcct = DSTCommonFunctions::codeInList (acctDesignation, I_("1,2,3"));

      if ( !bDealerAcct && 
           settleSource == I_("D")) //dealer
      {
         getErrMsg ( IFASTERR::INVALID_SETTLEMENT_SOURCE_FOR_ACCOUNT_DESIGNATION, 
                     CND::ERR_SETTLEMENT_SOURCE_NOT_FOR_ACCT_DESIGNATION, 
                     CND::ERR_WARN_SETTLEMENT_SOURCE_NOT_FOR_ACCT_DESIGNATION, 
                     idDataGroup); 
      }

//rule 5: settleSource = D, AcctDesignation-4 = 3 and OrdSource-115 = "I", then issue error
      DString orderSource;      
      getField (ifds::OrderSource, orderSource, idDataGroup, false);
      if ( settleSource == I_("D") && //dealer
           orderSource == I_("I") && 
           acctDesignation == I_("3"))
      {
         getErrMsg ( IFASTERR::DEALER_CANNOT_SETTLE_ORDERS_PLACED_BY_INTERMEDIARY, 
                     CND::ERR_INVALID_DEALER_FOR_ORDER_SETTLEMENT_BY_INTERMEDIARY, 
                     CND::ERR_WARN_INVALID_DEALER_FOR_ORDER_SETTLEMENT_BY_INTERMEDIARY, 
                     idDataGroup); 
      }

      DString orderType;
      getField (ifds::OrderType, orderType, idDataGroup, false);

      DString fundCode, settlePurDays;
      getFundField (ifds::FundCode, fundCode, idDataGroup);
      FundMasterList *pFundMasterList;
     FundMaster *pFundMaster = NULL;
     if ( !fundCode.empty() &&
          getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING && 
          pFundMasterList) 
      {
         if ( pFundMasterList->getFundMaster (fundCode, idDataGroup, pFundMaster) &&
              pFundMaster)
         {
            pFundMaster->getField (ifds::SettlePurDays, settlePurDays, idDataGroup, false);
         }
      }
      
      IntermediaryList *pIntermediaryList = NULL;
      if ( getMgmtCo ().getIntermediaryList (pIntermediaryList) <= WARNING &&
           pIntermediaryList)
      {
         Intermediary* pIntermediary = NULL;
         
         if ( pIntermediaryList->getIntermediary ( idDataGroup, 
                                                   interCode, 
                                                   pIntermediary)  &&
              pIntermediary)
         {
            DString allowWire,
                    mmWire;

            pIntermediary->getField (ifds::AllowWire, allowWire, idDataGroup, false);
            pIntermediary->getField (ifds::MMWire, mmWire, idDataGroup, false);
            
//rule 2: dstrSettleSrc = I, allowWire = No,OrderType = Yes ,then issue error
            if ( allowWire == N && 
                 settleSource == I_("I") &&  //intermediary
                 orderType == Y) //wire
            {
               getErrMsg ( IFASTERR::INTERMEDIARY_IS_NOT_PERMITTED_TO_ENTER_WIRE_ORDERS,
                           CND::ERR_INVALID_INTERMEDIARY_FOR_WIRE_ORDERS, 
                           CND::ERR_WARN_INVALID_INTERMEDIARY_FOR_WIRE_ORDERS, 
                           idDataGroup); 
            }    

//rule 3: SettlePurDays = 1,    dstrSettleSrc = I, MMWire-86 = No (IntermediaryList) issue error               
            if ( settleSource == I_("I") && //intermediary
                 settlePurDays == I_("1") && 
                 mmWire == N &&
                 allowWire == Y &&
                 orderType == Y) //wire
            {
               getErrMsg ( IFASTERR::NOT_PERMITTED_TO_ENTER_MONEY_MARKET_WIRE_ORDERS, 
                           CND::ERR_INVALID_INTERMEDIARY_FOR_MONEY_MARKET_WIRE_ORDERS, 
                           CND::ERR_WARN_INVALID_INTERMEDIARY_FOR_MONEY_MARKET_WIRE_ORDERS, 
                           idDataGroup);
            }

//rule 6: dstrSettleSrc = D, SettlePurDays = 1, MMWire-86 = No (IntermediaryList), OrdType = Yes               
    /* Replaced with Broker validation below
         if ( settleSource == I_("D") &&  //dealer
                 orderType == Y &&     //wire
                 settlePurDays == I_("1") && 
                 mmWire == N
               )
            {
            getErrMsg ( IFASTERR::NOT_PERMITTED_TO_ENTER_MONEY_MARKET_WIRE_ORDERS, 
                            CND::ERR_INVALID_INTERMEDIARY_FOR_MONEY_MARKET_WIRE_ORDERS, 
                            CND::ERR_WARN_INVALID_INTERMEDIARY_FOR_MONEY_MARKET_WIRE_ORDERS, 
                            idDataGroup
                          );
            }
          */
         }
      }

      if ( settleSource == I_("D") /*dealer*/ )
      {
         DString dstrBrokerMMWire;
         bool blBrokerFound = false;
         Broker *pBroker (NULL);

         if ( getBroker ( pBroker, 
                          idDataGroup) <= WARNING &&
              pBroker)
         {
            pBroker->getField (ifds::MMWire, dstrBrokerMMWire, BF::HOST);
            blBrokerFound = true;
         }
         if (!blBrokerFound)
         {        
            getErrMsg ( IFASTERR::NO_DEALER_INFORMATION_AVAILABLE_FOR_BROKER_CODE, 
                        CND::ERR_DEALER_INFO_MISSING_FOR_BROKER, 
                        CND::WARN_DEALER_INFO_MISSING_FOR_BROKER, 
                        idDataGroup);
         }
         else if ( settlePurDays == I_("1") && 
                   dstrBrokerMMWire == I_( "N" ) && 
                   orderType == Y /*wire */ )
         {
               getErrMsg ( IFASTERR::NOT_PERMITTED_TO_ENTER_MONEY_MARKET_WIRE_ORDERS, 
                        CND::ERR_INVALID_BROKER_FOR_MONEY_MARKET_WIRE_ORDERS, 
                        CND::WARN_INVALID_BROKER_FOR_MONEY_MARKET_WIRE_ORDERS, 
                        idDataGroup);
         }
      }

	   TransactionList *pAdjustTransactionList = NULL;
	   if (getAdjustTransactionList(pAdjustTransactionList, idDataGroup )<=WARNING &&
		   pAdjustTransactionList != NULL)
	   {
		   DString adjSettleSource;
		   BFObjIter iter(*pAdjustTransactionList, idDataGroup, BFObjIter::NON_DELETED);
         if(TransactionDetails *pTransDetails = dynamic_cast<TransactionDetails*>(iter.getObject()))
         {
            DString transId;
            pTransDetails->getField(ifds::TransId, transId, idDataGroup);
            pTransDetails->getDetails(transId);
		      pTransDetails->getField(ifds::SettleSource, adjSettleSource, idDataGroup);
         }
		   if(adjSettleSource == settleSource)
		   {
			   if(settleSource == I_("D"))
			   {
				   DString adjBroker, dstrBroker;
				   iter.getObject()->getField(ifds::BrokerCode, adjBroker, idDataGroup);
				   getField(ifds::Broker, dstrBroker, idDataGroup);

				   if(adjBroker != dstrBroker)
				   {
					   getErrMsg ( IFASTERR::DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
						   CND::ERR_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							CND::WARN_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							idDataGroup);
				   }
			   }
			   else if(settleSource == I_("I"))
			   {
					DString adjInterCode;
               DString adjAccount;
               MFAccount *pAdjAccount = NULL;
				   iter.getObject()->getField(ifds::AccountNum, adjAccount, idDataGroup);
               if(getWorkSession().getMFAccount(idDataGroup, adjAccount, pAdjAccount)<=WARNING &&
                  pAdjAccount)
               {
                  pAdjAccount->getField(ifds::InterCode, adjInterCode, idDataGroup);
               }

					if(interCode != adjInterCode)
					{
						getErrMsg ( IFASTERR::DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							CND::ERR_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							CND::WARN_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							idDataGroup);
					}
			   }
		   }
		   else
		   {
			    getErrMsg ( IFASTERR::DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							CND::ERR_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							CND::WARN_DIFFERNT_SETTLESOURCE_THAN_CANCELLATION, 
							idDataGroup);
		   }
	   }
	}

  
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************        
SEVERITY Trade::validateCertRequired ( const DString &certRequired,
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("valideateCertRequired"));

   DString fundCode,
      classCode;
   
//based on the type of trade object at runtime the correct 
//'fund/class' code will be picked-up
   if ( getFundField (ifds::FundCode, fundCode, idDataGroup) <= WARNING &&
        getFundField (ifds::ClassCode, classCode, idDataGroup) <= WARNING)
   {
      validateCertRequired (fundCode, classCode, certRequired, idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************************
SEVERITY Trade::validateCertRequired ( const DString &fundCode,
                                        const DString &classCode,
                                        const DString &certRequired,
                                        const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateCertRequired"));

   if ( !fundCode.empty() &&
        !classCode.empty() &&
        certRequired == Y)
   {
// if issue certifcate at fund level = no, user cannot set certRequired to Yes
      FundMasterList *pFundMasterList;

      if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING && 
           pFundMasterList != NULL)
      {
         FundMaster *pFundMaster = NULL;

         if ( pFundMasterList->getFundMaster (fundCode, idDataGroup, pFundMaster) &&
              !pFundMaster
            )
         {
            DString issueCerts;

            pFundMaster->getField (ifds::IssueCerts, issueCerts, idDataGroup, false);
            if (issueCerts == I_("0"))
            {
               ADDCONDITIONFROMFILE (CND::ERR_CERT_NOT_FOR_FUND_CLASS);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************************
SEVERITY Trade::validateSettleType ( const DString &settleType,
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSettleType"));

//implementation should only be applicable to purchase and redemption
//since, management fee or admin fee does not pay to the broker or intermediary, 
//this logic applies to neither one

   DString settleSource;

   getField (ifds::SettleSource, settleSource, idDataGroup, false);

// rule 1: SettleSource = I, SettleType = B, VolSettleType-86 = Ind, issue error
// rule 2: SettleSource = D, SettleType = B, VolSettleType-90 = Ind, issue error

   if (!( (settleType == I_("B") && settleSource != I_("I") && settleSource != I_("D")) ||
           settleType != I_("B")))
   {
      MFAccount *pMFAccount = NULL;   
      DString accountNum;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      if ( getWorkSession().getMFAccount ( idDataGroup, 
                                           accountNum, 
                                           pMFAccount) <= WARNING  &&
           pMFAccount) 
      {
         DString acctDesignation,
            volSettleTyle;

         pMFAccount->getField (ifds::AcctDesignation, acctDesignation, idDataGroup, false);
         if (acctDesignation == I_("3")) // this rule only applies to intermediary account
         {
            DString interCode;

            pMFAccount->getField (ifds::InterCode, interCode, idDataGroup, false);
            IntermediaryList *pIntermediaryList = NULL;

            if ( getMgmtCo ().getIntermediaryList (pIntermediaryList) <= WARNING &&
                 pIntermediaryList)
            {
               Intermediary* pIntermediary = NULL;
      
               if ( pIntermediaryList->getIntermediary ( idDataGroup, 
                                                         interCode, 
                                                         pIntermediary)  &&
                    pIntermediary)
               {
                  pIntermediary->getField (ifds::VolSettleType, volSettleTyle, idDataGroup, false);
               }
            }
         }
         else // check broker
         {               
            Broker *pBroker;

            if ( getBroker ( pBroker, 
                             idDataGroup) <= WARNING &&
                 pBroker)
            {
               pBroker->getField (ifds::VolSettleType, volSettleTyle, idDataGroup);
            }
         }

         if (volSettleTyle.strip ().upperCase () == I_("IND"))
         {
            getErrMsg ( IFASTERR::INVALID_SETTLEMENT_TYPE_FOR_DEALER_INTERMEDIARY, 
                        CND::ERR_INVALID_SETTLEMENT_TYPE_FOR_DEALER_OR_INTERMEDIARY, 
                        CND::ERR_WARN_INVALID_SETTLEMENT_TYPE_FOR_DEALER_OR_INTERMEDIARY, 
                        idDataGroup); 
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}
//settle location
//******************************************************************************
SEVERITY Trade::validateClearingMethod ( const DString &dstrClearingMethod,
                                         MFAccount *pMFAccount,
                                         const BFDataGroupId& idDataGroup,
                                         bool blFrom
                                       )
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "validateClearingMethod" ) );   

   assert (pMFAccount);
   if ( pMFAccount && pMFAccount->isClearingAcount (idDataGroup))
   {
      DString dstrClearingId,
              transType;

      pMFAccount->getField( ifds::ClearingID, dstrClearingId, idDataGroup );
      dstrClearingId.stripAll();
      getField (ifds::TradesTransType, transType, idDataGroup, false);

      // DAP, DVP, PAD available for Purchase and Redemption in a 'Clearing' Account
      // DVP also available for purchase and redemption in a 'PUEV' Account
      if ( CLEARING_METHOD::DELIVERYvsPAYMENT    == dstrClearingMethod ||
           CLEARING_METHOD::DELIVERYafterPAYMENT == dstrClearingMethod ||
           CLEARING_METHOD::PAYMENTafterDELIVERY == dstrClearingMethod)
      {
          //TODO move this to purchase/redemption
          if ( DSTCommonFunctions::codeInList (transType, TRADETYPE::PURCHASE_LIKE) ||
               DSTCommonFunctions::codeInList (transType, TRADETYPE::REDEMPTION_LIKE))  
          {
             if ( I_("C") != dstrClearingId && 
               !( CLEARING_METHOD::DELIVERYvsPAYMENT == dstrClearingMethod && I_("P") == dstrClearingId ))
             {
               ADDCONDITIONFROMFILE (CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_CLEARING_ACCOUNT);
             }
          }
          else // if not purchase nor redemption, these clearing method are not applicable
          {
             ADDCONDITIONFROMFILE (CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_TRANSACTION_TYPE);
          }

      }
      // FOP available for PW, ED, TR, AFTR, EX in a Clearing Account or a PUEV account
      else if ( CLEARING_METHOD::FREEofPAYMENT     == dstrClearingMethod 
         && I_ ("C") != dstrClearingId && I_ ("P") != dstrClearingId  )

      {         
         ADDCONDITIONFROMFILE( CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_CLEARING_ACCOUNT );      
      }
      // RLG available for Transfers in a 'Clearing' Acount
      else if ( CLEARING_METHOD::REALIGNMENT == dstrClearingMethod)
      {
         //TODO move this to Transfer
         if ( I_( "TR" ) == transType || I_( "AFTR" ) == transType )
         {
            if (  I_( "C" ) != dstrClearingId  ) 
            {
               ADDCONDITIONFROMFILE( CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_CLEARING_ACCOUNT );
            }
            else if ( transType != I_( "TR" ) &&  transType != I_( "AFTR") )  
            {
               ADDCONDITIONFROMFILE( CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_TRANSACTION_TYPE );
            }
         }

         //TODO move this to Transfer
         if ( ( I_( "TR" ) == transType || I_( "AFTR" ) == transType ) && 
                I_( "C" )  == dstrClearingId ) 
         {
            // Check if both accounts are "Clearing"
            BFFieldId fieldIdAccount;
            if ( blFrom )
            {
               fieldIdAccount = ifds::AccountTo;
            }
            else
            {
               fieldIdAccount = ifds::AccountNum;
            }

            DString dstrAccount;

            getField( fieldIdAccount, dstrAccount, idDataGroup );
            MFAccount *pMFAccount = NULL;
            if (  getWorkSession().getMFAccount ( idDataGroup, dstrAccount, pMFAccount ) <= WARNING &&
                  NULL != pMFAccount )
            {
               DString dstrAcctClearingId;
               pMFAccount->getField( ifds::ClearingID, dstrAcctClearingId, idDataGroup );
               if ( I_( "C" ) != dstrAcctClearingId.stripAll() )
               {
                  // Realignment Method is applicable when both From and To Account are Clearing Accounts
                  ADDCONDITIONFROMFILE( CND::ERR_CLEARING_METHOD_REALIGNMENT_APPLICABLE_TO_FROM_AND_TO_CLEARING_ACCOUNTS );   
               }
            }

            DString dstrFromFund, dstrFromClass, dstrToFund, dstrToClass;

            getField( ifds::FromFund,  dstrFromFund,  idDataGroup );
            getField( ifds::FromClass, dstrFromClass, idDataGroup );
            getField( ifds::ToFund,    dstrToFund,    idDataGroup );
            getField( ifds::ToClass,   dstrToClass,   idDataGroup );

            if ( dstrFromFund.stripAll() != dstrToFund.stripAll() )
            {
               if ( blFrom )
               {
                  // Realignment Method for From side of Settlement Instruction allowed only for same From and To Fund.
                  ADDCONDITIONFROMFILE( CND::ERR_FROM_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_FUND );
               }
               else
               {
                  // Realignment Method for To side of Settlement Instruction allowed only for same From and To Fund.
                  ADDCONDITIONFROMFILE( CND::ERR_TO_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_FUND );
               }
            }

            if ( dstrFromClass.stripAll() != dstrToClass.stripAll() )
            {
               if ( blFrom )
               {
                  // Realignment Method for From side of Settlement Instruction allowed only for same From and To Class.
                  ADDCONDITIONFROMFILE( CND::ERR_FROM_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_CLASS );
               }
               else
               {
                  // Realignment Method for To side of Settlement Instruction allowed only for same From and To Class.
                  ADDCONDITIONFROMFILE( CND::ERR_TO_CLEARING_METHOD_REALIGNMENT_ONLY_FOR_SAME_FROM_TO_CLASS );
               }
            }
         }
      }

      //FDS available for PW, ED, TR, AFTR, EX in a Fund Settle Account
      else if ( CLEARING_METHOD::FUNDSETTLE == dstrClearingMethod && I_ ("F") != dstrClearingId )
      {
         ADDCONDITIONFROMFILE( CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_FUNDSETTLE_ACCOUNT );
      }
      // VST available for PW, ED, TR, AFTR, EX in a Vestima Account
      else if ( CLEARING_METHOD::VESTIMA == dstrClearingMethod && I_ ("V") != dstrClearingId )
      {
         ADDCONDITIONFROMFILE( CND::ERR_CLEARING_METHOD_NOT_ALLOWED_FOR_NON_VESTIMA_ACCOUNT );      
      }
      else if ( dstrClearingMethod == I_("CCY") )
      {

         DString dstrFundCode, dstrClassCode, dstrSettleCurrency, dstrFundCurrency;

         if (blFrom)
         {
            getField( ifds::FromFund,  dstrFundCode,  idDataGroup );
            getField( ifds::FromClass, dstrClassCode, idDataGroup );
         }
         else
         {
            getField( ifds::ToFund,  dstrFundCode,  idDataGroup );
            getField( ifds::ToClass, dstrClassCode, idDataGroup );
         }
         getField( ifds::SettleCurrency, dstrSettleCurrency, idDataGroup );

         FundDetail *pFundDetail = NULL;

         if ( getWorkSession ().getFundDetail ( dstrFundCode, 
                                                dstrClassCode, 
                                                idDataGroup, 
                                                pFundDetail )
            && pFundDetail)
         {
            pFundDetail->getField (ifds::Currency, dstrFundCurrency, idDataGroup, false);
         }

         if (dstrSettleCurrency != dstrFundCurrency)
         {
            if (blFrom)
            {
               ADDCONDITIONFROMFILE( CND::ERR_FROM_CLEARING_METHOD_CCY_ONLY_FOR_SAME_SETTLE_CURR_FUND_CURR );
            }
            else
            {
               ADDCONDITIONFROMFILE( CND::ERR_TO_CLEARING_METHOD_CCY_ONLY_FOR_SAME_SETTLE_CURR_FUND_CURR );
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setSettlementLocationSubstList ( const BFFieldId &idFieldCode,
                                                 const DString &accountNum,
                                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_( "setSettlementLocationSubstList"));
   
   bool blSuccess = true;
   DString dstrSettlementLocations;

   MFAccount *pMFAccount = NULL;
   if ( getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount ) <= WARNING &&
        NULL != pMFAccount )
   {
      FundMgmtSettlementInstrList *pSettlementLocationAcctList = NULL;
      if ( pMFAccount->getFundMgmtSettlementInstrList( pSettlementLocationAcctList, 
                                                       idDataGroup, 
                                                       true ) <= WARNING &&
           NULL != pSettlementLocationAcctList )
      {
         pSettlementLocationAcctList->getSettlementLocationSubstList (dstrSettlementLocations, idDataGroup);
      }
   }
   if ( blSuccess )
   {
      setFieldAllSubstituteValues( idFieldCode, idDataGroup, dstrSettlementLocations );
   }
   else
   {
      ADDCONDITIONFROMFILE( CND::ERR_TRADING_SETTLEMENT_LOCATION_INVALID_CODE_FOR_CLEARING_ACCOUNT );
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setSettlementCodeSubstList ( const BFFieldId& idFieldCode,
                                             const DString &accountNum,
                                             const BFDataGroupId& idDataGroup)

{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "setSettlementCodeSubstList" ));

   DString dstrSettleInstrSubstList;
   MFAccount *pMFAccount = NULL;

   //get instructions that are active at the moment trade is submitted.
   if ( getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount ) <= WARNING && 
        pMFAccount)
   {
      AcctSettlementInstrList *pAcctSettlementInstrList = NULL;
      if ( pMFAccount->getSettlementInstrList(   pAcctSettlementInstrList, 
                                                idDataGroup, 
                                                true ) <= WARNING &&
           pAcctSettlementInstrList )
      {
         pAcctSettlementInstrList->getSettlementCodeSubstList (dstrSettleInstrSubstList, idDataGroup);
      }
   }
   setFieldAllSubstituteValues( idFieldCode, idDataGroup, dstrSettleInstrSubstList );
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setDefaultSettlementLocation ( const BFFieldId& idFieldCode,
                                               const DString &accountNum,
                                               const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "setDefaultSettlementLocation" ));

   bool blHasDefault = false;

   MFAccount *pMFAccount = NULL;
   if (  getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount ) <= WARNING &&
        NULL != pMFAccount )
   {
      FundMgmtSettlementInstrList *pSettlementLocationAcctList = NULL;
      if ( pMFAccount->getFundMgmtSettlementInstrList( pSettlementLocationAcctList, 
                                                       idDataGroup, 
                                                       true ) <= WARNING &&
           NULL != pSettlementLocationAcctList )
      {
         BFObjIter settlementLocationAcctListIter( *pSettlementLocationAcctList, 
                                                   idDataGroup, 
                                                   true, 
                                                   BFObjIter::ITERTYPE::NON_DELETED );
         
         settlementLocationAcctListIter.begin();
         while( !settlementLocationAcctListIter.end() )
         {
            FundMgmtSettlementInstr *pFundMgmtSettlementInstr = 
               dynamic_cast<FundMgmtSettlementInstr*>( settlementLocationAcctListIter.getObject() );
            if ( NULL != pFundMgmtSettlementInstr )
            {
               DString dstrDefault;
               pFundMgmtSettlementInstr->getField( ifds::Default, dstrDefault, idDataGroup ) ;
               if ( I_( "Y" ) == dstrDefault )
               {
                  DString dstrSettleLocationCode;
                  pFundMgmtSettlementInstr->getField( ifds::SettleLocationCode, dstrSettleLocationCode, idDataGroup );
                  // Current method is called only for New Trade, so we'll set 
                  // lFormatted = true, lSideEffect = true, bCheckCurrentValue = false
                  setFieldNoValidate (idFieldCode, dstrSettleLocationCode, idDataGroup, true, true, true);   
                  blHasDefault = true;
                  break;
               }
            }
            ++settlementLocationAcctListIter;
         }
      }
   }

   if ( false == blHasDefault )
      ADDCONDITIONFROMFILE( CND::WARN_TRADE_SETTLEMENT_INSTRUCTIONS_MISSING_ACCT_LEVEL_DEFAULT );

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setDefaultAcctSettlementInstr ( const DString &accountNum,
                                                const BFDataGroupId& idDataGroup,
                                                bool bFrom /*=true*/)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "setDefaultAcctSettlementLocation" ) );
   
   bool   blHasDefault = false;
   MFAccount *pMFAccount = NULL;

   if (  getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount ) <= WARNING && 
         pMFAccount )
   {
      AcctSettlementInstrList *pAcctSettlementInstrList = NULL;
      if ( pMFAccount->getSettlementInstrList(   pAcctSettlementInstrList, 
                                                idDataGroup, 
                                                true ) <= WARNING &&
           NULL != pAcctSettlementInstrList )
      {
         BFObjIter acctSettlementInstrListIter( *pAcctSettlementInstrList, 
                                                 idDataGroup, 
                                                 true, 
                                                 BFObjIter::ITERTYPE::NON_DELETED );
         
         acctSettlementInstrListIter.begin();  
         
         while( !acctSettlementInstrListIter.end() )
         {
            DString   dstrDefaultSettleInstrCode;
            DString   dstrEffectiveDate;
            DString   dstrStopDate;

            acctSettlementInstrListIter.getObject()->getField( ifds::DefaultSettlementInstr, 
                                                               dstrDefaultSettleInstrCode, 
                                                               idDataGroup);


            if ( I_( "Y" ) == dstrDefaultSettleInstrCode)
            {
                 DString dstrSettleInstrCode;

               acctSettlementInstrListIter.getObject()->getField (ifds::SettlementInstrCode, dstrSettleInstrCode, idDataGroup);
               acctSettlementInstrListIter.getObject()->getField (ifds::EffectiveDate, dstrEffectiveDate, idDataGroup);
               acctSettlementInstrListIter.getObject()->getField (ifds::StopDate, dstrStopDate, idDataGroup);

               bool bDateOk = DSTCommonFunctions::IsDateBetween (dstrEffectiveDate, dstrStopDate, _currentBusinessDate);

               if (!bDateOk)
               {
                  ++acctSettlementInstrListIter;
                  continue;
               }

               DString dstrClearingMethod;
               acctSettlementInstrListIter.getObject()->getField (ifds::AcctClearingMethod,dstrClearingMethod,idDataGroup);
               DString dstrDeliveryTo;
               acctSettlementInstrListIter.getObject()->getField (ifds::DeliveryTo, dstrDeliveryTo,idDataGroup);

               if ( bFrom )
               {
                  setFieldNoValidate (ifds::FrSettlInstrCode, dstrSettleInstrCode, idDataGroup, true, true, true);
                  if ( !dstrClearingMethod.empty () )
                  {
                     setFieldNoValidate(ifds::FrClearingMethod,dstrClearingMethod,idDataGroup,true,true,true);
                  }

                  if (!dstrDeliveryTo.empty()) 
                  {
                     setFieldNoValidate(ifds::FrDeliveryTo, dstrDeliveryTo, idDataGroup, true, true, true);
                  }
               }
               else
               {
                  setFieldNoValidate (ifds::ToSettlInstrCode, dstrSettleInstrCode, idDataGroup, true, true, true);
                  if ( !dstrClearingMethod.empty () )
                  {
                     setFieldNoValidate(ifds::ToClearingMethod,dstrClearingMethod,idDataGroup,true,true,true);
                  }

				  if (!dstrDeliveryTo.empty()) 
                  {
                     setFieldNoValidate(ifds::ToDeliveryTo, dstrDeliveryTo, idDataGroup, true, true, true);
                  }
               }
               
               blHasDefault = true;
               break;
            }
            ++acctSettlementInstrListIter;
         }
      }
   } 

   if (false == blHasDefault)
   {
         // If we are here, it it means the MgmtCompany level instr exist for Account
         // However, the client side instr are mandatory only if error 429 is set to error
         // so if this the case, we should have a default, if not, raise error
         // otherwise, set Settlement Instr Code to N/A
      ErrMsgRulesList *pErrMsgRulesList = NULL;
      if ( getWorkSession().getMgmtCo().getErrMsgRulesList( pErrMsgRulesList ) <= WARNING &&
           NULL != pErrMsgRulesList )
      {
         DString dstrErrValue;
            
         pErrMsgRulesList->getEWIValue (IFASTERR::FUND_MGMT_CLIENT_SETTLEMENT_INSTR_REQUIRED, idDataGroup, dstrErrValue);
         dstrErrValue.strip().upperCase();
            
         if (I_("E") == dstrErrValue)
         {
            ADDCONDITIONFROMFILE (CND::WARN_TRADE_SETTLEMENT_INSTRUCTIONS_MISSING_ACCT_LEVEL_DEFAULT);
         }
         else
         {
            if (bFrom)
            {
               setFieldNoValidate (ifds::FrSettlInstrCode, I_("N/A"), idDataGroup, true, true, true);                       
            }
            else
            {
               setFieldNoValidate (ifds::ToSettlInstrCode, I_("N/A"), idDataGroup, true, true, true);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setAcctSettlementInstr ( const DString &settlementInstrCode,
                                         const DString &accountNum,
                                         const BFDataGroupId& idDataGroup,
                                         bool bFrom /*=true*/)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "setDefaultAcctSettlementLocation" ));
   
   MFAccount *pMFAccount = NULL;

   if (  getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount ) <= WARNING && 
         pMFAccount )
   {
      AcctSettlementInstrList *pAcctSettlementInstrList = NULL;
      if ( pMFAccount->getSettlementInstrList(   pAcctSettlementInstrList, 
                                                idDataGroup, 
                                                true ) <= WARNING &&
           NULL != pAcctSettlementInstrList )
      {
         BFObjIter acctSettlementInstrListIter( *pAcctSettlementInstrList, 
                                                 idDataGroup, 
                                                 true, 
                                                 BFObjIter::ITERTYPE::NON_DELETED );
         
         acctSettlementInstrListIter.begin();           
         while( !acctSettlementInstrListIter.end() )
         {
              DString settlementInstrCode_;

            acctSettlementInstrListIter.getObject()->getField( ifds::SettlementInstrCode, 
                                                               settlementInstrCode_, 
                                                               idDataGroup);


            if ( settlementInstrCode_ == settlementInstrCode)
            {
               DString dstrDeliveryTo, 
                       dstrInFavourOf, 
                       dstrForAccount,dstrCSDLocation,dstrCSDAccountNum;

               acctSettlementInstrListIter.getObject()->getField (ifds::DeliveryTo, dstrDeliveryTo, idDataGroup);
               acctSettlementInstrListIter.getObject()->getField (ifds::InFavourOf, dstrInFavourOf, idDataGroup);
               acctSettlementInstrListIter.getObject()->getField (ifds::ForAccount, dstrForAccount, idDataGroup);
			   acctSettlementInstrListIter.getObject()->getField (ifds::CSDLocation, dstrCSDLocation, idDataGroup);
			   acctSettlementInstrListIter.getObject()->getField (ifds::CSDAcctNum, dstrCSDAccountNum, idDataGroup);
               if ( bFrom )
               {
                  setFieldNoValidate (ifds::FrDeliveryTo, dstrDeliveryTo, idDataGroup, false, false, true);
                  setFieldNoValidate (ifds::FrInFavourOf, dstrInFavourOf, idDataGroup, false, false, true);
                  setFieldNoValidate (ifds::FrForAccount, dstrForAccount, idDataGroup, false, false, true);
				  setFieldNoValidate (ifds::FrCSDLocation, dstrCSDLocation, idDataGroup, false, false, true);
				  setFieldNoValidate (ifds::FrCSDAcctNum, dstrCSDAccountNum, idDataGroup, false, false, true);
                  for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrFrMapping;	i++)
                  {
                    DString dstrValue;
                    acctSettlementInstrListIter.getObject()->getField (SETL_LOC_FIELDS::SttlInstrFrMapping[i].MappedFieldId, dstrValue, 
                                                                       idDataGroup);                  
                     setFieldNoValidate (SETL_LOC_FIELDS::SttlInstrFrMapping[i].OrgFieldId, dstrValue, idDataGroup, false, false, true);
                  }
               }
               else
               {
                  setFieldNoValidate (ifds::ToDeliveryTo, dstrDeliveryTo, idDataGroup, false, false, true);
                  setFieldNoValidate (ifds::ToInFavourOf, dstrInFavourOf, idDataGroup, false, false, true);
                  setFieldNoValidate (ifds::ToForAccount, dstrForAccount, idDataGroup, false, false, true);
				  setFieldNoValidate (ifds::ToCSDLocation, dstrCSDLocation, idDataGroup, false, false, true);
				  setFieldNoValidate (ifds::ToCSDAcctNum, dstrCSDAccountNum, idDataGroup, false, false, true);
                  for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrToMapping;	i++)
                  {
                    DString dstrValue;
                    acctSettlementInstrListIter.getObject()->getField (SETL_LOC_FIELDS::SttlInstrToMapping[i].MappedFieldId, dstrValue, 
                                                                       idDataGroup);                  
                     setFieldNoValidate (SETL_LOC_FIELDS::SttlInstrToMapping[i].OrgFieldId, dstrValue, idDataGroup, false, false, true);
                  } 
               }
               setAccountNumbersFromSystemLevel( bFrom, idDataGroup);
               break; //found
            }                  
            ++acctSettlementInstrListIter;
         }
      }
   } 
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setSettleLocationDescription ( const BFFieldId &idFieldCode, 
                                               const BFFieldId &idFieldDescription, 
                                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "setSettleLocationDescription" ));

   if (!_bInitPending)
   {
      bool blSettleLocDescExists = false;

      DString dstrSettleLocCode;

      getField (idFieldCode, dstrSettleLocCode, idDataGroup);
      if (!dstrSettleLocCode.empty())
      {
         SysLvlSettlementInstrList *pSysLvlSettlementInstrList = NULL;
         if ( getWorkSession().getSettlementLocationSysLvlList( pSysLvlSettlementInstrList, 
                                                                idDataGroup, 
                                                                true ) <= WARNING &&
            NULL != pSysLvlSettlementInstrList )
         {
            SysLvlSettlementInstr *pSysLvlSettlementInstr = NULL;
            if ( pSysLvlSettlementInstrList->
                  getSysLvlSettlementInstr( dstrSettleLocCode, 
                                          pSysLvlSettlementInstr, 
                                          idDataGroup ) <= WARNING &&
               pSysLvlSettlementInstr)
            {
               DString dstrSettleLocDescription;
               pSysLvlSettlementInstr->getField( ifds::SettleLocationDesc, dstrSettleLocDescription, idDataGroup );

               setField( idFieldDescription, dstrSettleLocDescription, idDataGroup );
               blSettleLocDescExists = true;
            }
         }
         if (false == blSettleLocDescExists)
         {
            ADDCONDITIONFROMFILE (CND::ERR_SETTLEMENT_LOCATION_CODE_FOR_ACCOUNT_DOES_NOT_EXIST_AT_SYSTEM_LEVEL);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::resetSettleLoc ( const BFDataGroupId &idDataGroup, 
                                 bool bFrom /*=true*/)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "resetSettleLoc" ));
//this occurs only if the trade is new
   if (isNew())
   {
//reset all the settle location fields, 
      DString   dstrSettleLocCode, 
            dstrDeliveryTo, 
            dstrSettleLocDescription, 
            dstrInFavourOf, 
            dstrForAccount, 
            dstrClearingMethod,
            dstrSettleInstrCode,
            accountNum,
            clearingMethodDefault,
			dstrCsdLocation,
			dstrCsdAccount;

      getTradeDefault ( ifds::TradeClearMethodDefault, 
                        clearingMethodDefault,
                        idDataGroup);
   //from side
      if (bFrom)
      {
         getField (ifds::AccountNum, accountNum, idDataGroup, false);
         getFieldBeforeImage (ifds::FrSettlLocCode,        dstrSettleLocCode);
         getFieldBeforeImage (ifds::FrDeliveryTo,          dstrDeliveryTo);
         getFieldBeforeImage (ifds::FrSettlLocDescription, dstrSettleLocDescription);
         getFieldBeforeImage (ifds::FrInFavourOf,          dstrInFavourOf);
         getFieldBeforeImage (ifds::FrForAccount,          dstrForAccount);
         getFieldBeforeImage (ifds::FrClearingMethod,      dstrClearingMethod);
         getFieldBeforeImage (ifds::FrSettlInstrCode,      dstrSettleInstrCode);
		 getFieldBeforeImage (ifds::FrCSDLocation,         dstrCsdLocation);
		 getFieldBeforeImage (ifds::FrCSDAcctNum,          dstrCsdAccount);

         setFieldNoValidate (ifds::FrSettlLocCode,        dstrSettleLocCode,        idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrDeliveryTo,          dstrDeliveryTo,           idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrSettlLocDescription, dstrSettleLocDescription, idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrInFavourOf,          dstrInFavourOf,           idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrForAccount,          dstrForAccount,           idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrClearingMethod,      dstrClearingMethod,       idDataGroup, false, false, true);
         setFieldNoValidate (ifds::FrSettlInstrCode,      dstrSettleInstrCode,      idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::FrCSDLocation,         dstrCsdLocation,           idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::FrCSDAcctNum,          dstrCsdAccount,           idDataGroup, false, false, true);

         for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrFrMapping;	i++)
         {
            DString dstrValue;
            getFieldBeforeImage ( SETL_LOC_FIELDS::SttlInstrFrMapping[i].MappedFieldId, dstrValue );                  
            setFieldNoValidate  (SETL_LOC_FIELDS::SttlInstrFrMapping[i].OrgFieldId, dstrValue, idDataGroup, false, false, true);
         }
         //restore the defaults, 
         setDefaultSettlementLocation (ifds::FrSettlLocCode, accountNum, idDataGroup);
         setFieldNoValidate ( ifds::FrClearingMethod, clearingMethodDefault, idDataGroup, false,
                              false, //invalid
                              true);   //notify
      }
      else //to side
      {
         getField (ifds::AccountTo, accountNum, idDataGroup, false);
         getFieldBeforeImage (ifds::ToSettlLocCode,        dstrSettleLocCode);
         getFieldBeforeImage (ifds::ToDeliveryTo,          dstrDeliveryTo);
         getFieldBeforeImage (ifds::ToSettlLocDescription, dstrSettleLocDescription);
         getFieldBeforeImage (ifds::ToInFavourOf,          dstrInFavourOf);
         getFieldBeforeImage (ifds::ToForAccount,          dstrForAccount);
         getFieldBeforeImage (ifds::ToClearingMethod,      dstrClearingMethod);
         getFieldBeforeImage (ifds::ToSettlInstrCode,      dstrSettleInstrCode);
		 getFieldBeforeImage (ifds::ToCSDLocation,         dstrCsdLocation);
		 getFieldBeforeImage (ifds::ToCSDAcctNum,          dstrCsdAccount);

         setFieldNoValidate (ifds::ToSettlLocCode,        dstrSettleLocCode,        idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToDeliveryTo,          dstrDeliveryTo,           idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToSettlLocDescription, dstrSettleLocDescription, idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToInFavourOf,          dstrInFavourOf,           idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToForAccount,          dstrForAccount,           idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToClearingMethod,      dstrClearingMethod,       idDataGroup, false, false, true);
         setFieldNoValidate (ifds::ToSettlInstrCode,      dstrSettleInstrCode,      idDataGroup, false, false, true);
		 setFieldNoValidate (ifds::ToCSDLocation,         dstrCsdLocation,           idDataGroup, false, false, true);
	     setFieldNoValidate (ifds::ToCSDAcctNum,          dstrCsdAccount,           idDataGroup, false, false, true);
          
         for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrToMapping;	i++)
         {
            DString dstrValue;
            getFieldBeforeImage ( SETL_LOC_FIELDS::SttlInstrToMapping[i].MappedFieldId, dstrValue );                  
            setFieldNoValidate  (SETL_LOC_FIELDS::SttlInstrToMapping[i].OrgFieldId, dstrValue, idDataGroup, false, false, true);
         } 
         //restore the defaults, 
         setDefaultSettlementLocation (ifds::ToSettlLocCode, accountNum, idDataGroup);
         setFieldNoValidate ( ifds::ToClearingMethod, clearingMethodDefault, idDataGroup, false,
                              false, //invalid
                              true);   //notify
      }
      setAccountNumbersFromSystemLevel( bFrom, idDataGroup);
      setDefaultAcctSettlementInstr (accountNum, idDataGroup, bFrom);
      for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
      {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::clearingRelatedChanges ( const BFDataGroupId &idDataGroup, 
                                         bool bFrom /*=true*/)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "clearingRelatedChanges" ));
//take of the clearing fields
   MFAccount *pMFAccount = NULL;
   DString accountNum;

   if (bFrom)
   {
      getField (ifds::AccountNum, accountNum, idDataGroup, false);
   }
   else //to side
   {
      getField (ifds::AccountTo, accountNum, idDataGroup, false);
   }
   if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING && 
        pMFAccount)
   {
      DString payType;

      getField (ifds::TradesPayType, payType, idDataGroup, false);

      bool isClearing = (payType == PAYTYPE::CLEARING || payType.empty()) && 
                         pMFAccount->isClearingAcount (idDataGroup);

      if (bFrom) //from side
      {
         setFieldRequired (ifds::FrSettlLocCode, idDataGroup, isClearing);
         setFieldValid (ifds::FrSettlLocCode, idDataGroup, !isClearing); //invalidate the field...
         setFieldRequired (ifds::FrDeliveryTo, idDataGroup, isClearing);
         setFieldValid (ifds::FrDeliveryTo, idDataGroup, !isClearing);
         setFieldRequired (ifds::FrClearingMethod, idDataGroup, isClearing);
         setFieldValid (ifds::FrClearingMethod, idDataGroup, !isClearing);
         setFieldRequired (ifds::FrSettlInstrCode, idDataGroup, isClearing);
         setFieldValid (ifds::FrSettlInstrCode, idDataGroup, !isClearing);
         setFieldRequired (ifds::FrDeliveryTo, idDataGroup, isClearing);
         setFieldValid (ifds::FrDeliveryTo, idDataGroup, !isClearing);
      }
      else
      {
         setFieldRequired (ifds::ToSettlLocCode, idDataGroup, isClearing);
         setFieldValid (ifds::ToSettlLocCode, idDataGroup, !isClearing); //invalidate the field...
         setFieldRequired (ifds::ToDeliveryTo, idDataGroup, isClearing);
         setFieldValid (ifds::ToDeliveryTo, idDataGroup, !isClearing);
         setFieldRequired (ifds::ToClearingMethod, idDataGroup, isClearing);
         setFieldValid (ifds::ToClearingMethod, idDataGroup, !isClearing);
         setFieldRequired (ifds::ToSettlInstrCode, idDataGroup, isClearing);
         setFieldValid (ifds::ToSettlInstrCode, idDataGroup, !isClearing);
         setFieldRequired (ifds::ToDeliveryTo, idDataGroup, isClearing);
         setFieldValid (ifds::ToDeliveryTo, idDataGroup, !isClearing);
      }
      for(int i= 0; i < SETL_LOC_FIELDS::numSttlInstrReadOnlyAlways;	i++)
      {
        setFieldReadOnly( SETL_LOC_FIELDS::SttlInstrReadOnlyAlways[i], BF::HOST, true );
      }
      if (isClearing)
      {
//find the defaults, from side
         DString clearingMethodDefault;

         getTradeDefault ( ifds::TradeClearMethodDefault, 
                           clearingMethodDefault,
                           idDataGroup
                        );
         if (bFrom)
         {
            if (!_bInitPending)
            {
               setFieldNoValidate ( ifds::FrClearingMethod, clearingMethodDefault, idDataGroup, false,
                                    false, //invalid
                                    true   //notify
                                 );
            }
            setSettlementLocationSubstList (ifds::FrSettlLocCode, accountNum, idDataGroup);
            setSettlementCodeSubstList (ifds::FrSettlInstrCode, accountNum, idDataGroup);
            if (!_bInitPending)
            {
               setDefaultSettlementLocation (ifds::FrSettlLocCode, accountNum, idDataGroup);            
            }
         }
         else //to side
         {
            if (!_bInitPending)
            {
               setFieldNoValidate ( ifds::ToClearingMethod, clearingMethodDefault, idDataGroup, false,
                                    false, //invalid
                                    true   //notify
                                 );
            }
            setSettlementLocationSubstList (ifds::ToSettlLocCode, accountNum, idDataGroup);
            setSettlementCodeSubstList (ifds::ToSettlInstrCode, accountNum, idDataGroup);
            if (!_bInitPending)
            {
               setDefaultSettlementLocation (ifds::ToSettlLocCode, accountNum, idDataGroup);
            }
         }
         if (!_bInitPending)
         {
            setDefaultAcctSettlementInstr (accountNum, idDataGroup, bFrom);
         }
      }
      else //clear the settle location fields
      {
         BFFieldId settleLocFieldsFrom [] = //settle location from side fields array
         {
            ifds::FrSettlLocCode,
            ifds::FrDeliveryTo,
            ifds::FrSettlLocDescription,
            ifds::FrInFavourOf,
            ifds::FrForAccount,
            ifds::FrSettlInstrCode,
            ifds::FrClearingMethod,
            ifds::FrCashMsgType,
            ifds::FrBeneficiary,
            ifds::FrIntermediaryBank,
            ifds::FrReceivingBank,
            ifds::FrSpecialInstructions,
            ifds::FrSettlementAccount,
            ifds::FrInternalSettlementAccount,
            ifds::NullFieldId,
			ifds::FrCSDLocation,
			ifds::FrCSDAcctNum,
         };    

         BFFieldId settleLocFieldsTo [] = //settle location to side fields array
         {
            ifds::ToSettlLocCode,
            ifds::ToDeliveryTo,
            ifds::ToSettlLocDescription,
            ifds::ToInFavourOf,
            ifds::ToForAccount,
            ifds::ToSettlInstrCode,
            ifds::ToClearingMethod,
            ifds::ToCashMsgType,
            ifds::ToBeneficiary,
            ifds::ToIntermediaryBank,
            ifds::ToReceivingBank,
            ifds::ToSpecialInstructions,
            ifds::ToSettlementAccount,
            ifds::ToInternalSettlementAccount,
            ifds::NullFieldId,
			ifds::ToCSDLocation,
			ifds::ToCSDAcctNum,
         };    

         int i = 0;

         for ( BFFieldId idField = bFrom ? settleLocFieldsFrom [i] : settleLocFieldsTo [i]; 
               idField != ifds::NullFieldId;
               idField = bFrom ? settleLocFieldsFrom [i++] : settleLocFieldsTo [i++])
         {
            setFieldNoValidate ( idField, NULL_STRING, idDataGroup, false, 
                                 false, //invalid
                                 true);   //notify
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//redemption code, deposit type, deposit id 
//******************************************************************************
SEVERITY Trade::validateDepositType ( const DString &depositType,
                                      const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateDepositType"));
//Rule 2:
   if (depositType == I_("23"))
   {
      ADDCONDITIONFROMFILE (CND::ERR_DEPOSIT_TYPE_23_NOT_SUPPORT);
   }
   else if (depositType == I_("24"))
   {
      DString transDescr,
         idiStr;

      getField (ifds::TradesTransType, transDescr, idDataGroup, true);
      addIDITagValue (idiStr, I_("TransTypeDescr"), transDescr);
      ADDCONDITIONFROMFILEIDI (CND::ERR_DEPOSIT_TYPE_24_NOT_SUPPORTED, idiStr);   
   }
   else if( DSTCommonFunctions::codeInList (depositType, I_("77,78,79,80,81,94")) )
   {
      if(!getWorkSession().isQESIClient())
      {
         ADDCONDITIONFROMFILE( CND::ERR_NOT_APPLICABLE_DEPTYPE_REDCODE );         
      }
   }
   else if (depositType == I_("40")) 
   {
       getErrMsg ( IFASTERR::DEPOSIT_TYPE_40_CANNOT_BE_PLACED,
                     CND::ERR_DEPOSIT_TYPE_40_CANNOT_BE_PLACED,
                     CND::WARN_DEPOSIT_TYPE_40_CANNOT_BE_PLACED,
                     idDataGroup );
   }
   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
SEVERITY Trade::validateRedCode ( const DString &redCode, 
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateRedCode"));
   if (DSTCommonFunctions::codeInList (redCode, I_("23,51,52"))) //rrif transfer code list
   {
      getErrMsg ( IFASTERR::SPOUSAL_CONSENT_IS_REQUIRED, //130
                  CND::ERR_SPOUSAL_CONSENT_REQUIRED, 
                  CND::ERR_WARN_SPOUSAL_CONSENT_REQUIRED, 
                  idDataGroup); 
   }
   else if (DSTCommonFunctions::codeInList (redCode, I_("32,33,53"))) //rrif death transfer list
   {
      getErrMsg ( IFASTERR::SPOUSAL_CONSENT_WAIVER_REQUIRED, //131
                  CND::ERR_SPOUSAL_CONSENT_WAIVER_REQUIRED, 
                  CND::ERR_WARN_SPOUSAL_CONSENT_WAIVER_REQUIRED, 
                  idDataGroup); 
   }
   else if (DSTCommonFunctions::codeInList (redCode, I_("29,30"))) //marriage break down list
   {
      DString accountNum;
      MFAccount *pMFAccount = NULL;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING && 
           pMFAccount)
      {
         DString acctType, 
            taxType;
         
         pMFAccount->getField (ifds::AcctType, acctType, idDataGroup);
         pMFAccount->getField (ifds::TaxType, taxType, idDataGroup);
         if (DSTCommonFunctions::codeInList (taxType, I_("1,2,R"))) //RRSP,RRIF,PRIF
         {
            bool bValidSINExists (false);
            
            if (acctType == I_("1"))//spousal account type
            {
               if (pMFAccount->checkSpouseValidSINExists (bValidSINExists, idDataGroup) <= WARNING)
               {
                  if (!bValidSINExists)
                  {
                     ADDCONDITIONFROMFILE (CND::ERR_SIN_MISSING_FOR_SPOUSE);
                  }
               }
            }
            else
            {
               if (pMFAccount->checkSpouseTransfereeValidSINExists (bValidSINExists, idDataGroup) <= WARNING)
               {
                  if (!bValidSINExists)
                  {
                     ADDCONDITIONFROMFILE (CND::ERR_SIN_MISSING_SPOUSAL_TRANSFEREE);
                  }
               }
            }
         }
      }
   }
   else if (DSTCommonFunctions::codeInList (redCode, I_("64,65"))) //resp transfer out and close acct
   {
// validation from PET0165541 QESI Transaction. Section A, 3
      ADDCONDITIONFROMFILE (CND::WARN_INELIG_RESP_TRANSFER_TRIGGER_GRANT_REPAYMENT);
   }
   else if (DSTCommonFunctions::codeInList (redCode, I_("Q1,Q2,Q3"))) //resp transfer out and close acct
   {
      if(!getWorkSession().isQESIClient() )   
         ADDCONDITIONFROMFILE( CND::ERR_NOT_APPLICABLE_DEPTYPE_REDCODE );   
   }
   else if (redCode == I_("40")) 
   {
      getErrMsg ( IFASTERR::RED_CODE_40_CANNOT_BE_PLACED,
                  CND::ERR_RED_CODE_40_CANNOT_BE_PLACED,
                  CND::WARN_RED_CODE_40_CANNOT_BE_PLACED,
                  idDataGroup );
   }
   else if (redCode == I_("EP")) 
   {
	   supportsAllocations (idDataGroup);
   }
   validateRESPTradeResidency (redCode, idDataGroup);
               
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
inline SEVERITY Trade::getAtCostTIKStatus ( const BFDataGroupId& idDataGroup, 
                                            const DString& dstrFundCodeIn, 
                                            const DString& dstrClassCodeIn,
                                            bool  blInAllocation,
                                            bool &blIsAtCostTIK )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAtCostTIKStatus"));
//implementations only in Exchange/Transfer/empty in AllTransfer
//method is called by allocations 
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
inline SEVERITY Trade::validateFundCodeRedCodeAmount (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundCodeRedCodeAmount"));

//implementation in Transfer/Redemption
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::loadDepRedCodeSubstList ( const DString &account, 
                                          const DString &codeType, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("loadDepRedCodeSubstList"));

   bool bLoadedSubstList = false;
   MFAccount *pMFAccount = NULL;
   BFFieldId idField = ifds::NullFieldId;
   if ( getWorkSession().getMFAccount (idDataGroup, account, pMFAccount) <= WARNING && 
        pMFAccount)
   {
     
      DString codesList, 
              redCodesByTaxTypeList;

      TaxTypeRule *pTaxTypeRule = NULL;
      if ( pMFAccount->getTaxTypeRule( pTaxTypeRule, idDataGroup ) <= WARNING && pTaxTypeRule )
      {
         if (codeType == I_("D")) //deposit code type
         {
            idField = ifds::DepositType;
            pTaxTypeRule->getField (ifds::DepositTypeList, codesList, idDataGroup);
         }
         else if (codeType == I_("R")) //redemption code type
         {
            idField = ifds::RedCode;
            pTaxTypeRule->getField (ifds::RedCodeList, redCodesByTaxTypeList, idDataGroup);

            DString redCodeSubList;

            TranslationTable* pTranslationTable = NULL;

            if ( getMgmtCo().getTranslationTable ( I_("RD"), 
                                                  pTranslationTable) <= WARNING &&
                 pTranslationTable)
            { 
               if (isAdminFee (idDataGroup))
               {
                  pTranslationTable->getAdminFeeRedCodeSubList ( redCodesByTaxTypeList, 
                                                                 redCodeSubList);
               }
               else
               {
                  pTranslationTable->getRedCodeSubList ( redCodesByTaxTypeList, 
                                                         redCodeSubList);
               }
            }

            DString dstrShrNum;
            Shareholder* pShareholder;
            pMFAccount->getField( ifds::ShrNum, dstrShrNum, idDataGroup );

            assert(!dstrShrNum.empty());

            if( getWorkSession().getShareholder( idDataGroup, dstrShrNum, pShareholder ) <= WARNING )
            {
               DString dstrTaxJuris;
               pShareholder->getField(ifds::TaxJurisCode, dstrTaxJuris, idDataGroup, false);

               DString dstrResidency1, dstrResidency2, dstrResidency3;
               getWorkSession().getOption (ifds::Residency1, dstrResidency1, idDataGroup, false);
               getWorkSession().getOption (ifds::Residency2, dstrResidency2, idDataGroup, false);
               getWorkSession().getOption (ifds::Residency3, dstrResidency3, idDataGroup, false);

               if(!( DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency1) ||
                     DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency2) ||
                     DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency3) ) ||
                  dstrTaxJuris == UNASSIGNED_TAX_JURIS)
               {

                  size_t start = redCodeSubList.find( I_("15"));
                  if(start != DString::npos)
                  {
                     size_t end = redCodeSubList.find( I_(","), start);

                     DString str1 = redCodeSubList.substr(0, start);
                     DString str2 = redCodeSubList.substr(end+1);

                     redCodeSubList = str1+str2;
                  }

               }
            }

            codesList = redCodeSubList;
         }

         bool bLoadedSubstList = !codesList.empty () &&
               idField != ifds::NullFieldId;         
         assert (idField != ifds::NullFieldId);
         
         if (bLoadedSubstList)
         {
            bLoadedSubstList = loadSubstitutionList ( idField,
                                                      idDataGroup, 
                                                      codesList, 
                                                      codeType == I_("D"), 
                                                      true);
         }
         if (!bLoadedSubstList)
         {
            setFieldAllSubstituteValues (idField, idDataGroup, NULL_STRING);
            setFieldNoValidate (idField, NULL_STRING, idDataGroup, false);
            setFieldReadOnly (idField, idDataGroup, true);
         }
      } //if (taxTypeRule != NULL ...
   } //if (pMFAccount != NULL ...
   DString dstrTranstype;
   getField (ifds::TradesTransType, dstrTranstype, idDataGroup, false);
   dstrTranstype = dstrTranstype.stripAll();
   if(!dstrTranstype.empty()&& !isExchange(idDataGroup) && !isInterClassSwitch(idDataGroup))
   {   
	   DString dstrCode =  (  I_("D") == codeType ) ? DEPOSIT_CODE_UC  : REDEMPTION_CODE_UC ;
	   if(idField != ifds::NullFieldId)
	   {
	    DString substList;
		BFProperties *pProperties = getFieldProperties (idField, idDataGroup); 
		if(pProperties)
		{
			pProperties->getAllSubstituteValues(substList);
			substList = removeItemFromSubtList (substList, dstrCode);
			setFieldAllSubstituteValues (idField, idDataGroup, substList);
		}
	   }
   }

   if (!dstrTranstype.empty() && isRedemption(idDataGroup) && isRDSPTradeAccount(idDataGroup, DString(account)))
   {   	  
	   if (ifds::RedCode != ifds::NullFieldId)
	   {
		   DString substList;
		   BFProperties *pProperties = getFieldProperties (idField, idDataGroup); 
		   if (pProperties)
		   {
			   pProperties->getAllSubstituteValues(substList);
			   substList = removeItemFromSubtList (substList, I_("01"));
			   setFieldAllSubstituteValues (idField, idDataGroup, substList);
		   }
	   }
   }

   return  GETCURRENTHIGHESTSEVERITY ();
}

//private memebers, helpers
//******************************************************************************
void Trade::firstLineInInit (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("firstLineInInit"));

   DString dstrAWDFieldFlag;
   getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag, idDataGroup, false);
  // if(YES == dstrAWDFieldFlag)//
   setTransTypeListFromMiscInfo(idDataGroup);
   
//get the default substitution set
   BFProperties *pBFPropertiesAllTradesTransType = 
      getFieldProperties (ifds::TradesTransType, idDataGroup);

   if (pBFPropertiesAllTradesTransType)
   {
      DString allFundTransfers,
         transTypeSubst;

      pBFPropertiesAllTradesTransType->getAllSubstituteValues (transTypeSubst);
      getWorkSession ().getOption ( ifds::AllFundsTransfers, 
                                    allFundTransfers, 
                                    BF::HOST, 
                                    false);
      allFundTransfers.strip ().upperCase ();
      if (allFundTransfers == N)
      {
         //remove the AFTR transaction type
         transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                   TRADETYPE::ALL_FUND_TRANSFER);
      }

      SupportedProductsList *pSupportedProductsList = NULL;

      if (getMgmtCo ().
            getSupportedProductsList (pSupportedProductsList) <= WARNING && 
            pSupportedProductsList)
      {
         if (!pSupportedProductsList->isLSIFProductActive ())
         {
            //remove the LR transaction type
            transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                      TRADETYPE::ROLLOVER);
         }
      }
//always remove ID - Manual Dividend
      transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                TRADETYPE::DIVIDEND);
//always remove Manual Management Fee Rebate
      transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                TRADETYPE::MANUAL_MGMT_FEE_REBATE);

/*
always remove PD59 - Manual Dividend Adjustment
              CI - Capital Gain Income Adjustment
              SI - Supplementary Income Adjustment
              FC - Foreign Cap Gain Allocation Adjustment
              MR59 - Mgmt Fee Rebate Adjustment
*/
      transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::MANUAL_DIVIDEND_ADJ);
      transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::CAPITAL_GAIN_INCOME_ADJ);
      transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::SUPPLEMENTARY_INCOME_ADJ);
      transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::FOREIGN_CAPGAIN_ALLOCATION_ADJ);
      transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::MGMT_FEE_REBATE_ADJ);

//Remove Advisor Fee if the environment is not applicable.
      DString dstrAdvisorFeeAppl;
      getWorkSession().getOption(ifds::AdvisorFeeAppl, dstrAdvisorFeeAppl, BF::HOST, false);

      if (dstrAdvisorFeeAppl.stripAll().upperCase() == YES)
      {
          //Change description from Dealer Service Fee(AFDF) to Advisor Fee.
          DString tmpSubList(transTypeSubst), newDescription;
          int nPos = transTypeSubst.find(I_("AFDF="));

          if (nPos != -1)
          {
              newDescription = I_("AFDF=") + DSTCommonFunctions::getDescription(I_("AFDF"), ifds::TradeTransTypeOverrideDescription) + I_(";");
              transTypeSubst = tmpSubList.left(nPos) + newDescription;
              tmpSubList = tmpSubList.right(tmpSubList.length() - nPos);

              int rnPos = tmpSubList.find(';');

              if (rnPos != -1)
              {
                  transTypeSubst = transTypeSubst + tmpSubList.right(tmpSubList.length() - rnPos - 1);
              }
          }
      }
      else
      {
          transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::ADVISOR_FEE);
      }

      if(!_bRefund)
          transTypeSubst = removeItemFromSubtList(transTypeSubst, TRADETYPE::REFUND_REDEMPTION);

//based on the user permission items should be removed
      DString::size_type pos = 0;
      DString transType_, 
         transTypeList;
      if (!getWorkSession ().hasCreatePermission (UAF::TRADING_PURCHASE))
      {
//remove purchase like transactions...
         transTypeList = TRADETYPE::PURCHASE_LIKE;
         do
         {

            EXTRACT_VALUE(transTypeList, transType_)
            transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                      transType_);

            CHOP_STRING (transTypeList)
         }
         while (transTypeList != NULL_STRING);
      }
      if (!getWorkSession ().hasCreatePermission (UAF::TRADING_REDEMPTION))
      {
//remove redemeption like transactions...
         transTypeList = TRADETYPE::REDEMPTION_LIKE;
         do
         {

            EXTRACT_VALUE(transTypeList, transType_)
            transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                      transType_);

            CHOP_STRING (transTypeList)
         }
         while (transTypeList != NULL_STRING);
      }
      if (!getWorkSession ().hasCreatePermission (UAF::TRADING_EXCHANGE))
      {
//remove exchange like transactions...
         transTypeList = TRADETYPE::EXCHANGE_LIKE;
         do
         {

            EXTRACT_VALUE(transTypeList, transType_)
            transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                      transType_);

            CHOP_STRING (transTypeList)
         }
         while (transTypeList != NULL_STRING);
      }

      // CUSIP - Roll Over
      DString strMarket, strCanada;

      strCanada = MARKET_IDS::CANADA;
      strMarket = DSTCommonFunctions::getMarket();
      strMarket.strip().upperCase();
      strCanada.strip().upperCase();

      if (strMarket != strCanada )
      {
         // remove CUSIP Roll Over trade type for international client
         transTypeSubst = removeItemFromSubtList ( transTypeSubst, 
                                                   TRADETYPE::CUSIP_ROLLOVER );
      }

      setFieldAllSubstituteValues ( ifds::TradesTransType, 
                                    idDataGroup, 
                                    transTypeSubst);
   }
}

//******************************************************************************
SEVERITY Trade::getTradeDefault ( const BFFieldId &genControlDefaultFieldId, 
                                  DString &defaultValue, 
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getTradeDefault"));
   DString transType,
      transTypeList,
      defaultList;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   defaultValue = NULL_STRING;
   getWorkSession().getOption ( ifds::TransTypeDefault, 
                                transTypeList, 
                                BF::HOST, 
                                false);
   getWorkSession().getOption ( genControlDefaultFieldId, 
                                defaultList, 
                                BF::HOST, 
                                false);

//start chopping the string
   do
   {
      DString::size_type pos = 0;
      DString transType_;

      EXTRACT_VALUE(transTypeList, transType_)
      if (transType_ == transType) //found the transaction type
      {
         EXTRACT_VALUE (defaultList, defaultValue)         
         break;
      }
      else //cut the string
      {
         CHOP_STRING (transTypeList)
         CHOP_STRING (defaultList)
      }
   }
   while (transTypeList != NULL_STRING);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
void Trade::setClearingAccDefaultPayType (const DString dstrAccountNum, DString &payType, const BFDataGroupId &idDataGroup)
{
   MFAccount   *pMFAccount = NULL;
   DString      transType;

    getField (ifds::TradesTransType, transType, idDataGroup, false);

    if ( getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && pMFAccount 
      && (isRedemption (idDataGroup) || isPurchase (idDataGroup)))
    {
         DString dstrClearingID;

         pMFAccount->getField (ifds::ClearingID, dstrClearingID, idDataGroup, false);

       int i = 0;
       if (dstrClearingID.empty ())
          payType = defaultPayType;
       else
          payType = I_("R");
   }
   else
      payType = defaultPayType;
}
//******************************************************************************

void Trade::setDefaultPayType (const DString dstrAccountNum, DString &payType, const BFDataGroupId &idDataGroup)
{
   payType = defaultPayType;
}

//******************************************************************************
SEVERITY Trade::getTradeDefaults ( DString &payType, 
                                   DString &amtType, 
                                   DString &clearMethod,
                                   DString &fileProcessor,
                                   const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getTradeDefaults"));
   
   DString transTypeList,
      payTypeList,
      amtTypeList,
      clearMethodList,
      fileProcessorList,
      transType;
   
   DString accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);

   getField (ifds::TradesTransType, transType, idDataGroup, false);
//initialize the output parameters
   payType = amtType = clearMethod = fileProcessor = NULL_STRING;
   getWorkSession().getOption ( ifds::TransTypeDefault, 
                                transTypeList, 
                                BF::HOST, 
                                false);
   getWorkSession().getOption ( ifds::TradePayTypeDefault, 
                                payTypeList, 
                                BF::HOST, 
                                false);
   getWorkSession().getOption ( ifds::TradeAmtTypeDefault, 
                                amtTypeList, 
                                BF::HOST, 
                                false);
   getWorkSession().getOption ( ifds::TradeClearMethodDefault, 
                                clearMethodList, 
                                BF::HOST, 
                                false);
   getWorkSession().getOption ( ifds::TradeFileProcessorDefault, 
                                fileProcessorList, 
                                BF::HOST, 
                                false);

   int pos = -1;
   pos = fileProcessorList.find_first_of (I_(","));

   bool bMultiFileProc = pos >= 0 ? true : false;

//start chopping the strings
   do
   {
      DString::size_type pos = 0;
      DString transType_;

      EXTRACT_VALUE(transTypeList, transType_)
      if (transType_ == transType) //found the transaction type
      {
         EXTRACT_VALUE (payTypeList, defaultPayType)
         EXTRACT_VALUE (amtTypeList, amtType)
         EXTRACT_VALUE (clearMethodList, clearMethod)

       if (bMultiFileProc)
       {
         EXTRACT_VALUE (fileProcessorList, fileProcessor)
       }
       else
       {
          fileProcessor = fileProcessorList;
       }

         break;
      }
      else //cut the strings
      {
         CHOP_STRING (transTypeList)
         CHOP_STRING (payTypeList)
         CHOP_STRING (amtTypeList)
         CHOP_STRING (clearMethodList)

         if (bMultiFileProc)
         {
            CHOP_STRING (fileProcessorList)
         }
      }
   }
   while (transTypeList != NULL_STRING);

   setDefaultPayType (accountNum, payType, idDataGroup);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getDefaultBankInstructions ( BFCBO *&pBase, 
                                             const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getDefaultBankInstructions"));
   BankInstructions *pBankInstructions = NULL;

   if ( getDefaultBankInstructions ( pBankInstructions, 
                                     idDataGroup) <= WARNING  &&
        pBankInstructions)
   {
      pBase = pBankInstructions;
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline SEVERITY Trade::getDefaultBankInstructions ( BankInstructions *&pBankInstructions, 
                                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getDefaultBankInstructions"));
//method implemented in Purchase/Redemption/Admin Fee
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getShareholderBankInstructions ( BankInstructions *&pBankInstructions, 
                                                 const DString &bankAcctUseCode,
                                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getShareholderBankInstructions"));
   DString accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   accountNum.stripLeading ('0').strip();
   pBankInstructions = NULL;
   if (!accountNum.empty())
   {
      MFAccount *pMFAccount = NULL;

      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
           pMFAccount)
      {
         DString shrNum;
         Shareholder *pShareholder = NULL;

         pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup, false);
         if ( getWorkSession().getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING && 
              pShareholder)
         {
            ShareholderBankInstructionsList *pShareholderBankInstructionsList = NULL;

            if ( pShareholder->getShareholderBankInstructionsList ( pShareholderBankInstructionsList, 
                                                                    idDataGroup, true, accountNum ) <= WARNING &&
                                                                    pShareholderBankInstructionsList)
            {
              DString dstrBankingConfig;
              pShareholderBankInstructionsList->getBankingConfiguration(dstrBankingConfig, idDataGroup);
              if( BANKINGLEVEL::ACCOUNT_LEVEL == dstrBankingConfig ||
                  BANKINGLEVEL::SHAREHOLDER_AND_ACCOUNT_LEVEL == dstrBankingConfig )
              {
                    getDefaultBankingInstrFromAccount(pBankInstructions, pShareholderBankInstructionsList, bankAcctUseCode, idDataGroup);
                  //if nothing got form the account level based on the hirearchy , use shareholder level
                  if(!pBankInstructions) 
                     getDefaultBankingInstrFromShareholder(pBankInstructions, pShareholderBankInstructionsList, bankAcctUseCode, idDataGroup); 
              }
              else if( BANKINGLEVEL::SHAREHOLDER_LEVEL == dstrBankingConfig ) 
              {
                     getDefaultBankingInstrFromShareholder(pBankInstructions, pShareholderBankInstructionsList, bankAcctUseCode, idDataGroup);
              }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::getDefaultBankingInstrFromAccount(BankInstructions *&pBankInstructions, ShareholderBankInstructionsList *&pBankingInstructionList, 
                                                  const DString &dstrbankAcctUseCode, const BFDataGroupId &idDataGroup)
{
  MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getDefaultBankingInstrFromAccount"));

  if(pBankingInstructionList)
  {
    BFObjIter iter ( *pBankingInstructionList, 
                     idDataGroup);

    DString dstrAccountNum, dstrCurrency, dstrTradeDate;
    getField (ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);
    getField (ifds::SettleCurrency, dstrCurrency, idDataGroup, false);
    getField (ifds::AccountNum, dstrAccountNum, idDataGroup, false);
    dstrAccountNum.stripLeading ('0').strip();
    if (!dstrCurrency.empty())
     {
        BankInstructions *pShareholderDefaultAcctUsageBankInstructions = NULL;
        while (!iter.end())
        {
            DString bankAcctCurrency,
            bankAcctUseCode,
            bankEffectiveDate,
            bankStopDate, 
            acctNum, dstrBankEntity;

            iter.getObject()->getField (ifds::BankAcctCurrency, bankAcctCurrency, idDataGroup, false);
            iter.getObject()->getField (ifds::AcctUseCode, bankAcctUseCode, idDataGroup, false);
            iter.getObject()->getField (ifds::EffectiveDate, bankEffectiveDate, idDataGroup, false);
            iter.getObject()->getField (ifds::StopDate, bankStopDate, idDataGroup, false);                    
            iter.getObject()->getField( ifds::rxAcctNum, acctNum, idDataGroup, false);
            iter.getObject()->getField( ifds::rxBankingEntity, dstrBankEntity, idDataGroup, false);
            if ( dstrAccountNum ==  acctNum && 
                 dstrCurrency == bankAcctCurrency && 
                 dstrbankAcctUseCode== bankAcctUseCode &&
                 dstrBankEntity == BANKENTITY::ACCOUNT &&
                //Incident #261420 - check if bank account is active as of trade date
                 DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, dstrTradeDate))
            {
            //pick the first one...
            pBankInstructions = 
                dynamic_cast <BankInstructions*> (iter.getObject());
            break;
            }
            else if ( dstrAccountNum ==  acctNum &&
                      dstrCurrency == bankAcctCurrency && 
                      AcctUseCode::DEFAULT == bankAcctUseCode &&
                      dstrBankEntity == BANKENTITY::ACCOUNT &&
            //Incident #1186158 - check if bank account is active as of trade date - why wasn't this fixed under IN261420, as well?
            DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, dstrTradeDate))
            {
            //hang on to the 'Default' account usage bank instructions
            //in case the correct account usage is not found
            pShareholderDefaultAcctUsageBankInstructions = 
                dynamic_cast <BankInstructions*> (iter.getObject());
            }
            ++iter;
        }
        if (!pBankInstructions) 
        {
           //if bank instructions not found try with the default account usage (it might be null - doesn't exist);                    
            pBankInstructions = pShareholderDefaultAcctUsageBankInstructions;
        }
    }
  }
  return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::getDefaultBankingInstrFromShareholder(BankInstructions *&pBankInstructions, ShareholderBankInstructionsList *&pBankingInstructionList, 
                                                      const DString &dstrbankAcctUseCode, const BFDataGroupId &idDataGroup)
{
  MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getDefaultBankingInstrFromShareholder"));
   
  if(pBankingInstructionList)
  {
    BFObjIter iter ( *pBankingInstructionList, idDataGroup);  
    DString currency, tradeDate;
    getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
    getField (ifds::SettleCurrency, currency, idDataGroup, false);
    if (!currency.empty())
    {
        BankInstructions *pShareholderDefaultAcctUsageBankInstructions = NULL;

        while (!iter.end())
        {
            DString bankAcctCurrency,
            bankAcctUseCode,
            bankEffectiveDate,
            bankStopDate, 
            dstrBankEntity;

            iter.getObject()->getField (ifds::BankAcctCurrency, bankAcctCurrency, idDataGroup, false);
            iter.getObject()->getField (ifds::AcctUseCode, bankAcctUseCode, idDataGroup, false);
            iter.getObject()->getField (ifds::EffectiveDate, bankEffectiveDate, idDataGroup, false);
            iter.getObject()->getField (ifds::StopDate, bankStopDate, idDataGroup, false);
            iter.getObject()->getField( ifds::rxBankingEntity, dstrBankEntity, idDataGroup, false);
            if ( bankAcctCurrency == currency && 
                dstrbankAcctUseCode == bankAcctUseCode &&
                dstrBankEntity == BANKENTITY::SHAREHOLDER &&
                //Incident #261420 - check if bank account is active as of trade date
                DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
            {
            //pick the first one...
            pBankInstructions = 
                dynamic_cast <BankInstructions*> (iter.getObject());
            break;
            }
            else if ( bankAcctCurrency == currency && 
                      AcctUseCode::DEFAULT == bankAcctUseCode &&
                      dstrBankEntity == BANKENTITY::SHAREHOLDER &&
            //Incident #1186158 - check if bank account is active as of trade date - why wasn't this fixed under IN261420, as well?
            DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
            {
            //hang on to the 'Default' account usage bank instructions
            //in case the correct account usage is not found
            pShareholderDefaultAcctUsageBankInstructions = 
                dynamic_cast <BankInstructions*> (iter.getObject());
            }
            ++iter;
        }
        if (!pBankInstructions) 
        {
           //if bank instructions not found try with the default account usage (it might be null - doesn't exist);                    
            pBankInstructions = pShareholderDefaultAcctUsageBankInstructions;
        }
    }
 }
  return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getLastEFTBankInstructions ( BankInstructions *&pBankInstructions, 
                                             const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getLastEFTBankInstructions"));

   pBankInstructions = NULL;
// as of release 80 this is not required anymore - Incident 948449
   return GETCURRENTHIGHESTSEVERITY();



   DString currency,
      accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   getField (ifds::SettleCurrency, currency, idDataGroup, false);
   accountNum.stripLeading ('0').strip();
   if (!currency.empty() && !accountNum.empty())
   {
      DString transType;
      
      getField (ifds::TradesTransType, transType, idDataGroup, false);

      DString strKey ( I_("LastEFTBankInstructionsList_TransType=") + transType + 
                       I_(";AccountNum=") + accountNum +
                       I_(";Currency=") + currency);

      PendingTradeBankInstructionsList 
         *pendingTradeBankInstructionsList = 
            dynamic_cast <PendingTradeBankInstructionsList*> 
                  (getObject (strKey, idDataGroup));

      if (!pendingTradeBankInstructionsList)
      {
         DString payType,
            tradeDate;
      
         getField (ifds::TradesPayType, payType, idDataGroup, false);
         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         pendingTradeBankInstructionsList = 
            new PendingTradeBankInstructionsList (*this);
         if (pendingTradeBankInstructionsList->initLastEFT ( accountNum, 
                                                             transType, 
                                                             currency, 
                                                             payType,
                                                             tradeDate,
                                                             idDataGroup) <= WARNING)
         {
            setObject ( pendingTradeBankInstructionsList,
                        strKey,
                        OBJ_ACTIVITY_NONE,
                        idDataGroup);
         }
         else
         {
            delete pendingTradeBankInstructionsList;
            pendingTradeBankInstructionsList = NULL;
         }
      }
      if (pendingTradeBankInstructionsList)
      {
         BFObjIter iter ( *pendingTradeBankInstructionsList, 
                          idDataGroup);

         if (!iter.end())
         {
            DString tradeDate,
               bankEffectiveDate,
               bankStopDate;

            getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
            iter.getObject()->getField (ifds::EffectiveDate, bankEffectiveDate, idDataGroup, false);
            iter.getObject()->getField (ifds::StopDate, bankStopDate, idDataGroup, false);
            
            if (DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
            {
               pBankInstructions = dynamic_cast<BankInstructions*> (iter.getObject());
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
void Trade::getDefaultPaymentFor (DString &paymentFor, 
                                  const BFDataGroupId &idDataGroup)
{
   paymentFor = NULL_STRING;
}

//******************************************************************************
SEVERITY Trade::getPayEntityBankInstructions ( BankInstructions *&pBankInstructions, 
                                               const DString &acctUsageCode,
                                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getPayEntityBankInstructions"));

   DString payToEntity,
      broker,
      branch,
      slsrep,
      currency,
      tradeDate;

   getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
   getField (ifds::SettleCurrency, currency, idDataGroup, false);
   if ( !currency.empty() &&
        getTradePayToEntity (payToEntity, idDataGroup) <= WARNING &&
        !payToEntity.empty ())
   {
      if (payToEntity == PAY_TO::BROKER)
      {
         getField (ifds::Broker, broker, idDataGroup);
      }
      else if (payToEntity == PAY_TO::BRANCH)
      {
         getField (ifds::Broker, broker, idDataGroup);
         getField (ifds::Branch, branch, idDataGroup);
      }
      else if (payToEntity == PAY_TO::SALESREP)
      {
         getField (ifds::Broker, broker, idDataGroup);
         getField (ifds::Branch, branch, idDataGroup);
         getField (ifds::SlsrepCode, slsrep, idDataGroup);
      }

      DistributorRepository *pDistributorRepository = NULL;

      if ( getWorkSession ().getDistributorRepository (pDistributorRepository) <= WARNING &&
           pDistributorRepository)
      {
         DistributorBankInstructionsList *pDistributorBankInstructionsList = NULL;
//call view 52 for broker/branch/slsrep banking
         if ( pDistributorRepository->
                  getDistributorBankInstructionsList ( broker, 
                                                       branch, 
                                                       slsrep,
                                                       pDistributorBankInstructionsList, 
                                                       idDataGroup) <= WARNING &&
               pDistributorBankInstructionsList)
         {
            BFObjIter iter ( *pDistributorBankInstructionsList, 
                              idDataGroup, 
                              0, 
                              BFObjIter::ITERTYPE::NON_DELETED);

            while (!iter.end())
            {
               DString bankAcctCurrency,
                  bankAcctUseCode,
                  bankEffectiveDate,
                  bankStopDate;

               iter.getObject()->getField (ifds::BankAcctCurrency, bankAcctCurrency, idDataGroup, false);
               iter.getObject()->getField (ifds::AcctUseCode, bankAcctUseCode, idDataGroup, false);
               iter.getObject()->getField (ifds::EffectiveDate, bankEffectiveDate, idDataGroup, false);
               iter.getObject()->getField (ifds::StopDate, bankStopDate, idDataGroup, false);
               if ( bankAcctCurrency == currency && 
                    bankAcctUseCode == acctUsageCode &&
                    DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
               {
                  //pick the first one...
                  pBankInstructions = dynamic_cast <BankInstructions*> (iter.getObject());
                  break;
               }
               ++iter;
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getTradePayToEntity( DString &payToEntity,
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getTradePayToEntity"));

   payToEntity = NULL_STRING;

   DString broker,
      payType;
   
   getField (ifds::Broker, broker, idDataGroup, false);
   getField (ifds::TradesPayType, payType, idDataGroup, false);
   
   if (!broker.empty())
   {
      DString strKey (I_("PayToEntity_BrokerCode=") + broker);
      PayToEntity *pPayToEntity = NULL;

      pPayToEntity = 
         dynamic_cast <PayToEntity*> ( getObject ( strKey, 
                                                   idDataGroup));
      if (!pPayToEntity)
      {
         PayToEntityList *pPayToEntityList = new PayToEntityList (*this);
         DString defaultPaymentFor;

         getDefaultPaymentFor (defaultPaymentFor, idDataGroup);
         if ( !defaultPaymentFor.empty () &&
               pPayToEntityList->init (broker, NULL_STRING, idDataGroup) <= WARNING)
         {
            //walk the list to get the active one...
            //use current business date
            BFObjIter iter ( *pPayToEntityList, 
                              idDataGroup, 
                              0, 
                              BFObjIter::ITERTYPE::NON_DELETED);
            while (!iter.end ())
            {
               PayToEntity *pPayToEntity_ = dynamic_cast <PayToEntity*> (iter.getObject());
               if (pPayToEntity_)
               {
                  DString effectiveDate,
                     stopDate,
                     paymentFor;

                  pPayToEntity_->getField (ifds::EffectiveDate, effectiveDate, idDataGroup);
                  pPayToEntity_->getField (ifds::StopDate, stopDate, idDataGroup);
                  pPayToEntity_->getField (ifds::PaymentFor, paymentFor, idDataGroup);
                  if ( defaultPaymentFor == paymentFor &&
                       DSTCommonFunctions::IsDateBetween (effectiveDate, stopDate, _currentBusinessDate))
                  {
                     pPayToEntity = pPayToEntity_;
                     setObject ( pPayToEntity, 
                                 strKey, 
                                 OBJ_ACTIVITY_NONE, 
                                 idDataGroup,
                                 OBJ_TYPE_NONE,
                     //because the pay to entity object belongs to the pay to entity list
                     //the pointer should be destroyed when its parent dies, not when trade dies
                     //trade holds a link to it just for convenience
                                 BFCBO::OBJ_DELETE::NO_DELETE_ON_DTOR);
                     //so the list will be deleted when the Trade object dies
                     setObject ( pPayToEntityList,
                                 DString (I_("PayToEntityList_BrokerCode=") + broker), 
                                 OBJ_ACTIVITY_NONE,
                                 idDataGroup);
                     break; //found the active pay to entity
                  }
               }
               ++iter;
            }
         }
      }
      //if we have found the active one for redemption get the pay to entity code
      if (pPayToEntity)
      {
         pPayToEntity->getField (ifds::PayToEntity, payToEntity, idDataGroup, false);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::setPayInstrOption (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setPayInstrOption"));

  
   TradePayInstructList *pTradePayInstructList (NULL);
   int numItems (0);

   if ( getTradePayInstructList (pTradePayInstructList, idDataGroup, false) <= WARNING &&
        pTradePayInstructList)
   {
      BFObjIter iter ( *pTradePayInstructList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      numItems = iter.getNumberOfItemsInList ();
   }
   
   DString dstrPayInstrOption;
   
   getField (ifds::PayInstrOption, dstrPayInstrOption, idDataGroup, false);
   if (dstrPayInstrOption != I_("03"))
   {
      setFieldNoValidate ( ifds::PayInstrOption, 
                           numItems > 0 ? I_("01") : //redirect to pay to entity
                                          I_("02"),  //redirect to shareholder
                           idDataGroup,  
                           false, 
                           false,  //invalid
                           true); //side effect
   }
   bankingRelatedChanges (idDataGroup); 
   setFieldValid (ifds::PayTypeBankNum, idDataGroup, false);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::setTradePayInstructField ( const BFFieldId &idFromField,
                                           const BFFieldId &idToField, 
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setTradePayInstructField"));

   DString fieldValue; 

   getField (idFromField, fieldValue, idDataGroup);

   TradePayInstructList *pTradePayInstructList = NULL;
   
   if ( getTradePayInstructList ( pTradePayInstructList, 
                                  idDataGroup, 
                                  false ) <= WARNING &&
        pTradePayInstructList)
   {
      BFObjIter iter ( *pTradePayInstructList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      int numItems = iter.getNumberOfItemsInList ();

      if (numItems == 1)
      {
         iter.getObject()->setField (idToField, fieldValue, idDataGroup);
      }
      setFieldReadOnly (idFromField, idDataGroup, numItems > 1);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::setConsolidationType ( const DString &consolidationType,
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setConsolidationType"));
   TradePayInstructList *pTradePayInstructList = NULL;

   if ( getTradePayInstructList ( pTradePayInstructList, 
                                  idDataGroup, 
                                  false ) <= WARNING &&
        pTradePayInstructList)
   {
      BFObjIter iter ( *pTradePayInstructList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      while (!iter.end())
      {
         iter.getObject()->setField (ifds::ConsolType, consolidationType, idDataGroup);
         ++iter;
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::fetchTransNum ( const BFDataGroupId &idDataGroup,
                                const DString &track /*= I_("N")*/,
                                const DString &pageName /*= NULL_STRING*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("fetchTransNum"));

//first of all get a transaction number, call the back-end for it
//if this a hypothetical trade, there is no need for a transaction number
//hypothetical trades do not need a transaction number
   if (!isHypo ()) 
   {
      BFData query127 (ifds::DSTC0127_REQ);
      BFData *response = new BFData (ifds::DSTC0127_VW);
      
      DString mgmtCoIdOut,
         payType, 
         transType;
//get parameters for the request
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::TradesPayType, payType, idDataGroup, false);
//set the request   
      query127.setElementValue (ifds::CompanyId, getMgmtCoId (mgmtCoIdOut));
      query127.setElementValue (ifds::Track, track);
      query127.setElementValue (ifds::Activity, pageName);
      query127.setElementValue (ifds::PayType, payType);
      query127.setElementValue (ifds::TransType, transType);
   //ask for a transaction number
      if (BFDataBroker::getInstance ()->
            receive ( DSTC_REQUEST::TRANS_NUM, 
                      query127, 
                      *response, 
                      DSTCRequestor (getSecurity ())) <= WARNING)
      {
         DString dealTime,
            dealDate,
            transNum,
            settleDate,
            settleInDate,
            tradeDate,
            batch,
            orderType;

//read and set the transaction number
         response->getElementValue (ifds::TransNum, transNum);
         transNum.strip ().stripLeading ('0');
         setFieldNoValidate (ifds::TransNum, transNum, idDataGroup, false);
         setFieldReadOnly (ifds::TransNum, idDataGroup, true);
//read the current business date
         response->getElementValue (ifds::CurrBusDate, _currentBusinessDate);
         _currentBusinessDate.strip ();
//read and set the dates/time
         //deal time
         response->getElementValue (ifds::DealTime, dealTime);
         dealTime.strip ();
         setFieldNoValidate (ifds::DealTime, dealTime, idDataGroup, false, 
                             false); //invalid
         //deal date
         response->getElementValue (ifds::DealDate, dealDate);
         dealDate.strip();
         _todayDate = dealDate;
         setFieldNoValidate ( ifds::DealDate, dealDate, idDataGroup, false, 
                              false); //invalid
//read the order type         
         response->getElementValue (ifds::BatchOrdType, batchOrderType);
         batchOrderType.strip ().upperCase ();

         DString dstrFieldAssignment;
         DString dstrWireOrderNum;

         getField (ifds::FieldAssignment, dstrFieldAssignment, idDataGroup, false);
         getField (ifds::WireOrdNum, dstrWireOrderNum, idDataGroup, false);
         dstrWireOrderNum.stripLeading ('0');

         bool bAWDWire = dstrFieldAssignment == I_("FromAWD") && !dstrWireOrderNum.empty () ? true : false;

         if (!bAWDWire)
         {
            setFieldNoValidate ( ifds::OrderType, batchOrderType, idDataGroup, false, false, false, false); //no related changes
         }

         //call related changes manualy, and do not validate settle date
         orderTypeRelatedChanges (idDataGroup, false);
         setFieldValid (ifds::WireOrdNum, idDataGroup, false);
//if DealDateTime is Yes, DealDate and DealTime are updatable
         DString dealDateTime;

         getWorkSession ().getOption ( ifds::DealDateTime, 
                                       dealDateTime, 
                                       BF::HOST, 
                                       false);
         bool bRequired = dealDateTime == Y;

         setFieldRequired (ifds::DealDate, idDataGroup, bRequired && !isHypo()); 
         setFieldRequired (ifds::DealTime, idDataGroup, bRequired && !isHypo()); 
         setFieldReadOnly (ifds::DealDate, idDataGroup, !bRequired);
         setFieldReadOnly (ifds::DealTime, idDataGroup, !bRequired);
         //settle date
         response->getElementValue (ifds::SettleDate, settleDate);
         settleDate.strip();
         setFieldNoValidate (ifds::SettleDate, settleDate, idDataGroup, false);
         //settle in date
         response->getElementValue (ifds::SuggestSettleInDate, settleInDate);
         settleInDate.strip();
         setFieldNoValidate (ifds::SettleInDate, settleInDate, idDataGroup, false);
         //trade date (effective date)
         response->getElementValue (ifds::TradeDate, tradeDate);
         tradeDate.strip();
         setFieldNoValidate ( ifds::EffectiveDate, tradeDate, idDataGroup, false,
                              true, 
                              true, //notify
                              false); //not related changes
		 if (!isOneSideTrade(idDataGroup) )
		 {
			 setFieldNoValidate ( ifds::TradeInDate, tradeDate, idDataGroup, false,
				 true,
				 false,
				 false);
		 }
         //deposit date
         setFieldNoValidate (ifds::DepositDate, _currentBusinessDate, idDataGroup, false);         
		 DString emptyDate;
		 getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);
		 setFieldNoValidate (ifds::CashDate, emptyDate, idDataGroup, false);
//read the batch name                          
         response->getElementValue (ifds::rxBatchName, batch);
         batch.strip();
         setFieldNoValidate (ifds::BatchName, batch, idDataGroup, false);

         DString autoBatching;

         getWorkSession ().getOption (ifds::AutoBatch, autoBatching, idDataGroup, false);

         bool bReadOnly = autoBatching.asInteger () == AUTO_BATCHING ? false : true;

         setFieldReadOnly (ifds::BatchName, idDataGroup, bReadOnly);
         _nextCycleDate = _currentBusinessDate;
      }
      else
      {
         setFieldNoValidate ( ifds::OrderType, N, idDataGroup, false, 
                              false, false, 
                              false); //no related changes
         setFieldNoValidate (ifds::DepositDate, _currentBusinessDate, idDataGroup, false);
         setFieldNoValidate ( ifds::EffectiveDate, _currentBusinessDate, idDataGroup, false,
                              true, 
                              true, //notify
                              false);  //no related changes
		 if (!isOneSideTrade(idDataGroup))
		 {
			 setFieldNoValidate ( ifds::TradeInDate, _currentBusinessDate, idDataGroup, false,
				 true, 
				 false, //notify
				 false);  //no related changes
		 }
         setFieldNoValidate (ifds::SettleDate, _currentBusinessDate, idDataGroup, false);
         setFieldNoValidate (ifds::CashDate, _currentBusinessDate, idDataGroup, false);
         setFieldNoValidate (ifds::BatchName, NULL_STRING, idDataGroup, false);

      }
      if (response)
      {
         delete response;
         response = NULL;
      }
   } // is hypothetical Trade
   return GETCURRENTHIGHESTSEVERITY();
}

//**********************************************************
void Trade::setExchRate (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setExchRate"));
   bool bNoExchangeRate = true;

   if (_multiCurrency == Y)
   {
      DString fromCurrency, 
              toCurrency;

      if (isPurchaseLike (idDataGroup))
      {
         getField (ifds::SettleCurrency, fromCurrency, idDataGroup);
         getField (ifds::FromCurrency, toCurrency, idDataGroup);
      }
      else
      {
         getField (ifds::SettleCurrency, toCurrency, idDataGroup);
         getField (ifds::FromCurrency, fromCurrency, idDataGroup);
      }

   //if fund currency and settlement currency are the same, then set to 1
   // Magic 23778 sync up version 1.663.1.10
      
      if ( !fromCurrency.empty () && 
           !toCurrency.empty () && 
           fromCurrency == toCurrency )
      {
         if (!_bInitPending)
         {
            setFieldNoValidate ( ifds::ExchRate, I_( "1.00"), idDataGroup, 
                                 true, 
                                 true, 
                                 true); //notify
         }
         setFieldReadOnly  (ifds::ExchRate, idDataGroup, true);
         bNoExchangeRate = false;
      }
      else if ( !fromCurrency.empty () && 
                !toCurrency.empty () && 
                fromCurrency != toCurrency)
      {
         setFieldReadOnly  (ifds::ExchRate, idDataGroup, false);
         if (!_bInitPending)
         {
            setFieldNoValidate ( ifds::ExchRate, I_( "0.00"), idDataGroup, 
                                 true, 
                                 true, 
                                 true); //notify
         }
      }


//*********************************************************
      /* Enhancement SSII_Exchange Rate Upload
       * If DefaultExchRate_344 is "No" and
       * if Settlement Currency is different from the Fund Currency, 
       * the logic which get exchange rate from view 134 and set it into ExchRate field should be skiped.  
       */

      DString dstrDefaultExchRate;
      getWorkSession ().getOption ( ifds::DefaultExchRate, 
                                    dstrDefaultExchRate, 
                                    BF::HOST, 
                                    false);

      if (dstrDefaultExchRate == Y)
      {

         if ( !fromCurrency.empty () && 
              !toCurrency.empty () && 
              fromCurrency != toCurrency) 
         {
            DString exchRate;

            getField (ifds::ExchRate, exchRate, idDataGroup);
            double dec_exchRate = DSTCommonFunctions::convertToDouble (exchRate);

   // get the exchange rate if user change change fund, trade date or settle currency
            DString tradeDate, asOfDate (NULL_STRING);

			if (isXferInDateActive(idDataGroup) && isExchangeLike(idDataGroup))
			{
				getField (ifds::TradeInDate, tradeDate, idDataGroup);
			}
			else
			{
				getField (ifds::EffectiveDate, tradeDate, idDataGroup);
			}
            asOfDate = tradeDate;
            if (getExchRate ( fromCurrency, 
                              toCurrency, 
                              asOfDate, 
                              dec_exchRate, 
                              idDataGroup) <= WARNING)
            {
   // if the most recent exchange rate is not from the trade date, then zero out the exchrate
               if (asOfDate != tradeDate)
               {
                  dec_exchRate = 0;
               }
               exchRate = DSTCommonFunctions::doubleToDString (ifds::ExchRate, dec_exchRate);
               if (!_bInitPending)
               {
                  setFieldNoValidate ( ifds::ExchRate, exchRate, idDataGroup, 
                                       true, 
                                       true, 
                                       true); //notify
               }
               setFieldReadOnly  (ifds::ExchRate, idDataGroup, false);
   //we found an exchange rate
               bNoExchangeRate = false;
            } 
         } 
      } // if ( dstrDefaultExchRate == Y )
      else
      {
         //User should be allowed to update the Exchange Rate
         bNoExchangeRate = false;
      }
   // make ExchRate read only if both currencies are Euro 
      CurrencyList *pCurrencyList = NULL;

      if ( getMgmtCo ().getCurrencyList (pCurrencyList) <= WARNING && 
            pCurrencyList)
      {
         Currency *pFromCurrency = NULL;
         Currency *pToCurrency = NULL;

         pCurrencyList->getCurrency (fromCurrency, pFromCurrency, idDataGroup);
         pCurrencyList->getCurrency (toCurrency, pToCurrency, idDataGroup);

         if (pFromCurrency && pToCurrency)
         {
            if ( pFromCurrency->isEuroCurrency (idDataGroup) && 
                  pToCurrency->isEuroCurrency (idDataGroup))
            {
               setFieldReadOnly (ifds::ExchRate, idDataGroup, true);
            }
         }
      }
   } // if multi-currency
   if (bNoExchangeRate)
   {
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::ExchRate, 
                              _multiCurrency == Y ? I_("0.00") : I_("1.00"), 
                              idDataGroup, 
                              true, 
                              true, 
                              true); //notify
      }
//if same currency do not allow the exchange rate to be modified            
      setFieldReadOnly (ifds::ExchRate, idDataGroup, true);
   }
}

//******************************************************************************
SEVERITY Trade::getExchRate ( const DString &fromCurrency, 
                              const DString &toCurrency, 
                              DString &asOfDate,
                              double &dExchRate,
                              const BFDataGroupId &idDataGroup,
                              const DString &exactDate /*=I_("Y")*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getExchRate"));

   DString strKey = I_("ExchRateList_FromCurrency=") + fromCurrency +
                    I_("ToCurrency=") + toCurrency +
                    I_("AsOfDate=") + asOfDate +
                    I_("ExactDate=") + exactDate;
   ExchRateList *pExchRateList = NULL;

   pExchRateList = dynamic_cast<ExchRateList *> (getObject (strKey, 
                                                            idDataGroup));
   if (!pExchRateList)
   {
      pExchRateList = new ExchRateList (*this);
      if (pExchRateList->init () <= WARNING)
      {
         setObject ( pExchRateList, 
                     strKey, 
                     OBJ_ACTIVITY_NONE, 
                     idDataGroup);  
      }
      else
      {
         delete pExchRateList;
         pExchRateList = NULL;
      }
   }
   if (pExchRateList)
   {
      dExchRate = pExchRateList->getExchRate ( fromCurrency, 
                                               toCurrency, 
                                               asOfDate, 
                                               idDataGroup,
                                               N,
                                               NULL_STRING,
                                               exactDate);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getExchRate ( double &dExchRate,
                              const BFDataGroupId &idDataGroup,
                              const DString &exactDate /*=I_("N")*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("getExchRate"));

   if (_multiCurrency == Y)
   {
      DString fromCurrency; 
      DString toCurrency;

      if (isPurchaseLike (idDataGroup))
      {
         getField (ifds::SettleCurrency, fromCurrency, idDataGroup);
         getField (ifds::FromCurrency, toCurrency, idDataGroup);
      }
      else
      {
         getField (ifds::SettleCurrency, toCurrency, idDataGroup);
         getField (ifds::FromCurrency, fromCurrency, idDataGroup);
      }

      DString asOfDate;

      getField (ifds::EffectiveDate, asOfDate, idDataGroup); 
      getExchRate (fromCurrency, toCurrency, asOfDate, dExchRate, idDataGroup, exactDate);
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateExchRate ( const DString &exchRate,
                                   const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateExchRate"));

   if (!isDecimal (exchRate))
   {
      ADDCONDITIONFROMFILE (CND::ERR_EXCH_RATE_MUST_BE_NUMERIC);
   }
   else
   {
      double dec_exch_rate = DSTCommonFunctions::convertToDouble (exchRate);

      if (dec_exch_rate < 0)
      {
         ADDCONDITIONFROMFILE (CND::ERR_NEGATIVE_EXCH_RATE_NOT_ALLOW);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//public methods, usually called by process or allocation objects
//******************************************************************************
SEVERITY Trade::refreshBatch ( const BFDataGroupId &idDataGroup,
                               const DString &track,
                               const DString &pageName)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("refreshBatch"));
   DString mgmtCoIdOut,
      batchName;

   BFData query124 (ifds::DSTC0124_REQ);
   BFData *response = new BFData (ifds::DSTC0124_VW);

   query124.setElementValue (ifds::Track, track);
   query124.setElementValue (ifds::Activity, pageName);
   query124.setElementValue (ifds::CompanyId, getMgmtCoId (mgmtCoIdOut));  

   if (BFDataBroker::getInstance ()->receive ( DSTC_REQUEST::ACTIVE_BATCH, 
                                               query124, 
                                               *response, 
                                               DSTCRequestor (getSecurity ())) <= WARNING)
   {
      response->getElementValue (ifds::rxBatchName, batchName);
      batchName.strip();
   }
   setField ( ifds::BatchName, batchName, idDataGroup, 
              false, //not-formatted
              true);   //notify the observers
   if (response)
   {
      delete response;
      response = NULL;
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//children of trade should go in here

//******************************************************************************
SEVERITY Trade::getSplitCommissionList ( SplitCommissionList *&pSplitCommissionList,
                                         const BFDataGroupId &idDataGroup,
                                         bool bCreate  /* =true*/,
                                         bool bRefresh /* =false*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getSplitCommissionList"));

   pSplitCommissionList = NULL;

      DString accountNum,
         fundCode,
         classCode,
         broker,
         branch,
         agent,
         effectiveDate;

      getField (ifds::Broker, broker, idDataGroup, false);
      getField (ifds::Branch, branch, idDataGroup, false);
      getField (ifds::SlsrepCode, agent, idDataGroup, false);
      getField (ifds::EffectiveDate, effectiveDate, idDataGroup, false);
      if ( getAccountField (ifds::AccountNum, accountNum, idDataGroup) <= WARNING &&
           !accountNum.empty() &&
           getFundField (ifds::FundCode, fundCode, idDataGroup) <= WARNING &&
           getFundField (ifds::ClassCode, classCode, idDataGroup) <= WARNING &&
           !fundCode.empty() &&
           !classCode.empty() &&
           !broker.empty() &&
           !branch.empty() &&
           !agent.empty() &&
           !effectiveDate.empty())
      {
         TradeFundAllocList *pFundAllocationList = NULL;

         if ( getFundAllocationList ( pFundAllocationList, 
                                      idDataGroup) <= WARNING &&
              pFundAllocationList)
         {
            BFObjIter iter ( *pFundAllocationList, 
                             idDataGroup, 
                             true);
               BFData matchCriteria;

               matchCriteria.setElementValue (ifds::AccountNum, accountNum, true);
               matchCriteria.setElementValue (ifds::FundCode, fundCode, true);
               matchCriteria.setElementValue (ifds::ClassCode, classCode, true);
               iter.positionOnNextMatch (matchCriteria, idDataGroup);
               if (!iter.end ())
               {
                  TradeFundAlloc *pTradeFundAlloc = 
                        dynamic_cast<TradeFundAlloc*> (iter.getObject ());

                  if (pTradeFundAlloc)
                  {
					if (isSplitCommissionAllowed (idDataGroup))
					{
                     pTradeFundAlloc->getSplitCommissionList ( pSplitCommissionList, 
                                                               idDataGroup,
                                                               bCreate,
                                                               bRefresh);
                  }
					else 
            {
						pTradeFundAlloc->setField (ifds::SplitComm, N, idDataGroup, false);
						BFObjIter iter1 (*pTradeFundAlloc, idDataGroup);

						iter1.positionByKey (I_("SplitCommissionList"));
						if (!iter1.end())
                  {
							if (isNew())
							{
								iter1.removeObjectFromMap (true);
                  }
							else
							{
								iter1.deleteObject ();
               }
            }
         }
      }
   }
		}
	}
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getFundAllocationList ( TradeFundAllocList *&pFundAllocationList, 
                                        const BFDataGroupId& idDataGroup, 
                                        bool create /*=true*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundAllocationList"));
   pFundAllocationList = NULL;
   TradeAcctAllocList *pAccountAllocationList = NULL;

   if ( getAccountAllocationList ( pAccountAllocationList, 
                                   idDataGroup, 
                                   create) <= WARNING &&
        pAccountAllocationList)
   {
      TradeAcctAlloc * pAccountAllocation = NULL;
      DString accountNum;

      if ( getAccountField (ifds::AccountNum, accountNum, idDataGroup) <= WARNING &&
           !accountNum.empty())
      {
         if ( pAccountAllocationList->getAccountAllocation ( accountNum, 
                                                             pAccountAllocation, 
                                                             idDataGroup) <= WARNING &&
              pAccountAllocation)
         {
            pAccountAllocation->getFundAllocationList (pFundAllocationList, idDataGroup);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getAccountAllocationList ( TradeAcctAllocList *&pAccountAllocationList, 
                                            const BFDataGroupId &idDataGroup, 
                                            bool bCreate) /*= true*/
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccountAllocationList"));
   DString strKey = I_("AccountAllocationList");

   pAccountAllocationList = 
         dynamic_cast <TradeAcctAllocList *> ( getObject ( strKey, 
                                                           idDataGroup));
   if (!pAccountAllocationList && bCreate)
   {
//this means, that allocations will be always created for transactions 
//that support them (i.e. Transfers/Purchase/Exchange/Redemption)
      if (supportsAllocations (idDataGroup))
      {
         DString accountNum;
         SEVERITY severity = NO_CONDITION;

         if ( getAccountField (ifds::AccountNum, accountNum, idDataGroup) <= WARNING &&
              !accountNum.empty())
         {
            pAccountAllocationList = new TradeAcctAllocList (*this);
            if (isNew())
            {
               severity = pAccountAllocationList->initNew (idDataGroup);
            }
            else
            {
               severity = pAccountAllocationList->initExisting ();
            }
            if (severity <= WARNING)
            {
   //if we either have default allocations, which were picked up for new trades
   //or already existing allocations for pending trades, do not add the 100% one
               BFObjIter iter ( *pAccountAllocationList, 
                                idDataGroup, 
                                false, 
                                BFObjIter::ITERTYPE::NON_DELETED);

               if (!iter.getNumberOfItemsInList ())
               {
                  //this adds the 100 % allocation
                  severity = pAccountAllocationList->addNewAllocation ( accountNum, 
                                                                        idDataGroup);
               }
            }
            if (severity <= WARNING)
            {
               setObject ( pAccountAllocationList, 
                           strKey, 
                           OBJ_ACTIVITY_NONE, 
                           idDataGroup); 
   //should assign the trans type on the alloc list
               DString transType;

               getField (ifds::TradesTransType, transType, idDataGroup, false);
               pAccountAllocationList->setField (ifds::TransType, transType, idDataGroup, false);
   //should assign the 'settle currency' for a non-multi currency environment
               TradeAcctAlloc * pAccountAllocation = NULL;

               if ( pAccountAllocationList->getAccountAllocation ( accountNum, 
                                                                   pAccountAllocation, 
                                                                   idDataGroup) <= WARNING &&
                    pAccountAllocation)
               {
                  TradeFundAllocList* pTradeFundAllocList;

                  if ( pAccountAllocation->getFundAllocationList ( pTradeFundAllocList, 
                                                                   idDataGroup) <= WARNING &&
                       pTradeFundAllocList)
                  {
                     if (_multiCurrency != Y)
                     {
                        DString currency;

                        pTradeFundAllocList->getAllocCurrency (currency, idDataGroup);
                        if (!currency.empty())
                        {
                           if (!_bInitPending)
                           {
                              setFieldNoValidate ( ifds::SettleCurrency, currency, idDataGroup, false, 
                                                   false, 
                                                   false,
                                                   false); //no do apply related
                           }
                        }
                     }
                  }
               }
            }
            else
            {
               delete pAccountAllocationList;
               pAccountAllocationList = NULL;
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getEstateAllocationList ( EstateAllocationList *&pEstateAllocationList, 
                                            const BFDataGroupId &idDataGroup, 
                                            bool bCreate) /*= true*/
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("getEstateAllocationList"));

   DString dstrAccountNum;
   DString dstrTransId; 
   DString dstrAmount;
   DString dstrAmountType;
   DString dstrFund;
   DString dstrClass;
   DString dstrTradeDate;

   getField (ifds::AccountNum,    dstrAccountNum, idDataGroup, false);
   getField (ifds::TransId,       dstrTransId,    idDataGroup, false);
   getField (ifds::Amount,        dstrAmount,     idDataGroup, false);
   getField (ifds::AmtType,       dstrAmountType, idDataGroup, false);
   getField (ifds::FromFund,      dstrFund,       idDataGroup, false);
   getField (ifds::FromClass,     dstrClass,      idDataGroup, false);
   getField (ifds::EffectiveDate, dstrTradeDate,  idDataGroup, false);


   DString strKey = I_ ("EstateAlloc;AcctNum=") + dstrAccountNum;
   strKey += I_("TransId=") + dstrTransId;
//   strKey += I_("Amount=")  + dstrAmount;
   strKey += I_("AmtType=") + dstrAmountType;
   strKey += I_("Fund=")    + dstrFund;
   strKey += I_("Class=")   + dstrClass;
   strKey += I_("Date=")    + dstrTradeDate;

   pEstateAllocationList = dynamic_cast<EstateAllocationList*>( getObject ( strKey, idDataGroup));
   if (!pEstateAllocationList && bCreate)
   {
      SEVERITY severity = NO_CONDITION;

      pEstateAllocationList = new EstateAllocationList(*this);

      severity = pEstateAllocationList->init(dstrAccountNum, dstrTransId, dstrAmount, dstrAmountType,
                  dstrFund, dstrClass, dstrTradeDate, idDataGroup);

      if (severity <= WARNING)
      {
         setObject ( pEstateAllocationList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
      }
      else
      {
         delete pEstateAllocationList;
         pEstateAllocationList = NULL;
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getFromFundAllocationList ( TradeFromFundAllocList *&pTradeFromFundAllocList, 
                                            const BFDataGroupId &idDataGroup, 
                                            bool bCreate) /*= true*/
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFromFundAllocationList"));

   pTradeFromFundAllocList = NULL;

   if (supportsFromAllocations (idDataGroup)) //if the transaction type can have from allocations
   {
      DString strKey = I_ ("FromFundAllocationList");
      //if multi transfer is allowed then create this list
      DString commissionType, 
         allowMultiFundTransfer; //hardcode, for now 

      getWorkSession ().getOption ( ifds::CommissionType, 
                                    commissionType, 
                                    BF::HOST, 
                                    false);
      getWorkSession ().getOption ( ifds::AllowMultiFundTransfer, 
                                    allowMultiFundTransfer, 
                                    BF::HOST, 
                                    false);
      if ( commissionType == I_ ("0") && 
           allowMultiFundTransfer == I_ ("Y"))
      {
         pTradeFromFundAllocList = 
               dynamic_cast<TradeFromFundAllocList*> 
                  ( getObject ( strKey, idDataGroup));
         if (!pTradeFromFundAllocList && bCreate)
         {
            SEVERITY severity = NO_CONDITION;

            pTradeFromFundAllocList = new TradeFromFundAllocList (*this);
            if (isNew ())
            {
               severity = pTradeFromFundAllocList->initNew (idDataGroup);
            }
            else
            {
               severity = pTradeFromFundAllocList->initExisting ();
            }
            if (severity <= WARNING)
            {
               setObject ( pTradeFromFundAllocList, 
                           strKey, 
                           OBJ_ACTIVITY_NONE, 
                           idDataGroup);

               DString amount, 
                  amtType;

               getField (ifds::Amount, amount, idDataGroup, false);
               getField (ifds::AmtType, amtType, idDataGroup, false);
               pTradeFromFundAllocList->setField ( ifds::Amount, 
                                                   amount, 
                                                   idDataGroup, 
                                                   false);
               pTradeFromFundAllocList->setField ( ifds::AllocAmtType, 
                                                   amtType, 
                                                   idDataGroup, 
                                                   false);
               if (!isNew ()) // for modified trades
               {
                  //set the from fund and class on the account allocation object,
                  TradeAcctAllocList *pAccountAllocationList = NULL;

                  if ( getAccountAllocationList ( pAccountAllocationList, 
                                                  idDataGroup) <= WARNING && 
                       pAccountAllocationList
                     )
                  {
                     BFObjIter iter ( *pTradeFromFundAllocList, 
                                       idDataGroup, 
                                       false, 
                                       BFObjIter::ITERTYPE::NON_DELETED);

                     if (!iter.end ())
                     {
                        DString fromFund, 
                           fromClass;

                        iter.getObject ()->getField (ifds::FundCode, fromFund, idDataGroup, false);
                        iter.getObject ()->getField (ifds::ClassCode, fromClass, idDataGroup, false);

                        if ( !fromFund.empty() && 
                              fromClass.empty())
                        {
                           pAccountAllocationList->setField ( ifds::FromFund, 
                                                              fromFund, 
                                                              idDataGroup, 
                                                              false);
                           pAccountAllocationList->setField ( ifds::FromClass, 
                                                              fromClass, 
                                                              idDataGroup, 
                                                              false);
                        }
                     }
                  }
               }
               if (isNew ()) //new trade
               {
                  pTradeFromFundAllocList->addNewAllocation ( NULL_STRING, 
                                                              idDataGroup, 
                                                              false, 
                                                              true, 
                                                              false);
               }
            }
            else
            {
               delete pTradeFromFundAllocList;
               pTradeFromFundAllocList = NULL;
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getBankInstructionsList ( TradeBankInstructionsList *&pTradeBankInstructionsList, 
                                          const BFDataGroupId &idDataGroup, 
                                          bool bCreate /*= false*/,
                                          BFAbstractCBO* pObjToCheck /*= NULL*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getBankInstructionsList"));

   pTradeBankInstructionsList = NULL;
   if (bCreate || isBankingNeeded (idDataGroup, pObjToCheck))
   {
      DString strKey (I_("Trade_BankInstructionsList"));

      if (bCreate) //force the creation 
      {
         removeTradeBankInstructionsList (idDataGroup);
      }
      else //look for it
      {
         pTradeBankInstructionsList = 
            dynamic_cast <TradeBankInstructionsList*> 
                     ( getObject ( strKey,
                                   idDataGroup));
      }
      if (!pTradeBankInstructionsList)
      {
         pTradeBankInstructionsList = new TradeBankInstructionsList (*this);
         if (pTradeBankInstructionsList)
         {
            DString accountNum;

            getField (ifds::AccountNum, accountNum, idDataGroup, false);
            accountNum.stripLeading ('0').strip();
            isNew() ? pTradeBankInstructionsList->initNew (accountNum, idDataGroup) :
                      pTradeBankInstructionsList->init (accountNum,_bRebook, idDataGroup);

//if no error raised and trade is in pending mode and there is no banking info returned by the view,
//(most likely user switched pay types), try and get the default bank, as for a new trade
            if (GETCURRENTHIGHESTSEVERITY() <= WARNING && !isNew())
            {
               BFObjIter iter (*pTradeBankInstructionsList, idDataGroup);

               if (iter.end()) //the bank list has no items
               {
                  pTradeBankInstructionsList->initNew (accountNum, idDataGroup);
               }
               else if (iter.getNumberOfItemsInList () == 1)
               {
//see whether currencies are different
                  BFObjIter bfIter (*pTradeBankInstructionsList, 
                                    idDataGroup, 
                                    false, 
                                    BFObjIter::ITERTYPE::NON_DELETED);
         
                  bfIter.begin();
                  bool bDeleteBanking = false;
                  if (!bfIter.end())
                  {            
                     DString bankAcctCurrency,
                             settleCurrency,
							 bankPayMethod,
							 payMethod;

                     getField (ifds::SettleCurrency, settleCurrency, idDataGroup, false);
                     getField (ifds::PayMethod, payMethod, idDataGroup, false);
                     bfIter.getObject () -> getField (ifds::BankAcctCurrency, bankAcctCurrency, idDataGroup, false);
					 bfIter.getObject () -> getField (ifds::PayMethod, bankPayMethod, idDataGroup, false);
                     if (settleCurrency != bankAcctCurrency || payMethod != bankPayMethod)
                     {
                        bfIter.removeObjectFromMap (true, true);
                        clearBankFields (idDataGroup);
                        bDeleteBanking = true;
                     }
                  }
                  if (bDeleteBanking) //treat this like a new bank instructions...
                  {
                     pTradeBankInstructionsList->initNew (accountNum, idDataGroup);
                  }
               }
            }
            if (GETCURRENTHIGHESTSEVERITY() <= WARNING)
            {
				setObject ( pTradeBankInstructionsList,
                           strKey,
                           OBJ_ACTIVITY_NONE,
                           idDataGroup);
            }
            else
            {
               delete pTradeBankInstructionsList;
               pTradeBankInstructionsList = NULL;
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getFeeModelCode ( const DString &accountNum,
                                  DString &feeModelCode,
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFeeModelCode"));

   MFAccount *pMFAccount = NULL;

   if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
        pMFAccount)
   {
      pMFAccount->getField (ifds::FeeModelCode, feeModelCode, idDataGroup);
      if (feeModelCode.empty())
      {
   //get the fee model code from shareholder
         DString shrNum;
         Shareholder *pShareholder = NULL;

         pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup);
         //get the shareholder
         if ( getWorkSession ().getShareholder ( idDataGroup, 
                                                 shrNum, 
                                                 pShareholder) <= WARNING && 
              pShareholder
            )
         {
            pShareholder->getField (ifds::FeeModelCode, feeModelCode, idDataGroup);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateFundSponsorFeeModelCode ( const DString &fundCode,
                                                  const DString &accountNum,
                                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundSponsorFeeModelCode"));
//PET1117.FN6.R3.7. 0
//should validate that if fee model exist at shareholder/account level
//and fund has a fund sponsor, there should be a fund sponsor fee model set-up
   FundSponsorFeeModelList *pFundSponsorFeeModelList = NULL;

//just make a view call to get the list...
//this can return ERR_FNDSPONSOR_FEEMODEL_DOES_NOT_EXIST, which is what we want
   getFundSponsorFeeModelList (accountNum, fundCode, pFundSponsorFeeModelList, idDataGroup);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getFundSponsorFeeModelList ( const DString &accountNum,
                                             const DString &fundCode,
                                             FundSponsorFeeModelList *&pFundSponsorFeeModelList,
                                             const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundSponsorFeeModelList"));

   DString feeModelCode;

   if ( getFeeModelCode (accountNum, feeModelCode, idDataGroup) <= WARNING &&
        !feeModelCode.empty()) 
   {//get the fund master object to find out to fund group
      FundMasterList *pFundMasterList = NULL;

      if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
           pFundMasterList)
      {
         FundMaster *pFundMaster = NULL;
   
         if ( pFundMasterList->getFundMaster ( fundCode, 
                                               idDataGroup, 
                                               pFundMaster) &&
              pFundMaster)
         {
            DString fundGroup;

            pFundMaster->getField (ifds::FundGroup, fundGroup, idDataGroup);
            //call view 307, to see if there is a fee model set-up
            if (!fundGroup.empty()) //do not bother to call if fund sponsor is empty
            {
               DString strKey = I_("AccountNum=") + accountNum +
                                I_("FundCode=") + fundCode +
                                I_("FeeModelCode=") + feeModelCode +
                                I_("FundGroup=") + fundGroup;

               pFundSponsorFeeModelList = 
                  dynamic_cast <FundSponsorFeeModelList *> (getObject (strKey, idDataGroup));

               if (!pFundSponsorFeeModelList) //make view call
               {
                  pFundSponsorFeeModelList = new FundSponsorFeeModelList (*this);
                  if (pFundSponsorFeeModelList->init ( idDataGroup, 
                                                       I_("N"), 
                                                       NULL_STRING,
                                                       feeModelCode, 
                                                       fundGroup) <= WARNING)
                  {
                     setObject ( pFundSponsorFeeModelList,
                                 strKey,
                                 OBJ_ACTIVITY_NONE,
                                 idDataGroup);
                  }            
                  else 
                  {
                     delete pFundSponsorFeeModelList;
                     pFundSponsorFeeModelList = NULL;
                  }
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getTransFeeList ( TransFeeList *&pTransFeeList, 
                                  const BFDataGroupId &idDataGroup,
                                  bool bCreate /*=false*/)
{

#define REGISTER_OBSERVER(id) \
   registerObserver ( id, \
                      idDataGroup, \
                      pTransFeeList, \
                      FIELD_NOTIFICATIONS, \
                      E_EVENT_ALL \
                    );

#define DEREGISTER_OBSERVER(id) \
   deleteObserver ( id, \
                    idDataGroup, \
                    pTransFeeList, \
                    FIELD_NOTIFICATIONS, \
                    E_EVENT_ALL \
                  );
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getTransFeeList")
                         );
   DString strKey = I_("TransFeeList");

   pTransFeeList = 
         dynamic_cast <TransFeeList *> (getObject (strKey, idDataGroup));
   
   if (bCreate && pTransFeeList)
   {
//blow the list,
      BFObjIter iter (*this, idDataGroup);

      iter.positionByKey (strKey);
      if (!iter.end ())
      {
         iter.removeObjectFromMap (true);
      }
      DEREGISTER_OBSERVER (ifds::AccountNum);
      DEREGISTER_OBSERVER (ifds::AccountTo);
      DEREGISTER_OBSERVER (ifds::FromFund);
      DEREGISTER_OBSERVER (ifds::FromClass);
      DEREGISTER_OBSERVER (ifds::ToFund);
      DEREGISTER_OBSERVER (ifds::ToClass);
      DEREGISTER_OBSERVER (ifds::RedCode);
      DEREGISTER_OBSERVER (ifds::DepositType);
      DEREGISTER_OBSERVER (ifds::Broker);
      DEREGISTER_OBSERVER (ifds::Branch);
      DEREGISTER_OBSERVER (ifds::SlsrepCode);
      DEREGISTER_OBSERVER (ifds::EffectiveDate);
      DEREGISTER_OBSERVER (ifds::Amount);
      DEREGISTER_OBSERVER (ifds::AmtType);
      DEREGISTER_OBSERVER (ifds::SettleCurrency);
      DEREGISTER_OBSERVER (ifds::LSIFCode);
      DEREGISTER_OBSERVER (ifds::AcqFeeOption);
      if (isROATransType (idDataGroup))
      {
         DEREGISTER_OBSERVER (ifds::ROAAmount);
      }
      pTransFeeList = NULL;
   }
   if (!pTransFeeList)
   {
      pTransFeeList = new TransFeeList (*this);
      REGISTER_OBSERVER (ifds::AccountNum);
      REGISTER_OBSERVER (ifds::AccountTo);
      REGISTER_OBSERVER (ifds::FromFund);
      REGISTER_OBSERVER (ifds::FromClass);
      REGISTER_OBSERVER (ifds::ToFund);
      REGISTER_OBSERVER (ifds::ToClass);
      REGISTER_OBSERVER (ifds::RedCode);
      REGISTER_OBSERVER (ifds::DepositType);
      REGISTER_OBSERVER (ifds::Broker);
      REGISTER_OBSERVER (ifds::Branch);
      REGISTER_OBSERVER (ifds::SlsrepCode);
      REGISTER_OBSERVER (ifds::EffectiveDate);
      REGISTER_OBSERVER (ifds::Amount);
      REGISTER_OBSERVER (ifds::AmtType);
      REGISTER_OBSERVER (ifds::SettleCurrency);
      REGISTER_OBSERVER (ifds::LSIFCode);
      REGISTER_OBSERVER (ifds::AcqFeeOption);
      if (isROATransType (idDataGroup))
      {
         REGISTER_OBSERVER (ifds::ROAAmount);
      }

      DString transNum,
         accountNum;

      getField (ifds::TransNum, transNum, idDataGroup);
      getField (ifds::AccountNum, accountNum, idDataGroup);
      accountNum.stripLeading ('0').strip();
      if (!accountNum.empty())
      {
   //here is the place to set the context
         if (getTransFeeContext (_pTransFeeContext, idDataGroup) <= WARNING)
         {
            pTransFeeList->setContext (*_pTransFeeContext);
            bool bSetObject = false;

            if (isNew())
            {
               bSetObject = pTransFeeList->initNew (transNum, accountNum, idDataGroup) <= WARNING;
            }
            else
            {
               bSetObject = pTransFeeList->init (transNum, accountNum, idDataGroup) <= WARNING;
               if (bSetObject)
               {
                  DString modPerm;

                  getField (ifds::TransModPerm, modPerm, idDataGroup);
                  BFObjIter iter (*pTransFeeList, idDataGroup);

                  while (!iter.end())
                  {
                     TransFee *pFee = 
                           dynamic_cast <TransFee*> (iter.getObject());

                     if (pFee)
                     {
                        pFee->applyModPerm (modPerm, idDataGroup);
                     }
                     ++iter;
                  }
               }
            }
            if (bSetObject)
            {
               setObject ( pTransFeeList, 
                           strKey, 
                           OBJ_ACTIVITY_NONE, 
                           idDataGroup);
            }
            else
            {
               delete pTransFeeList;
               pTransFeeList = NULL;
            }
         }
      }
   }
   else
   {
//SP - 399924
      if (!isNew())
      {
         pTransFeeList->setDataGroupForRefresh (idDataGroup);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getTransFeeContext ( TransFeeContext *&pTransFeeContext, 
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getTransFeeContext"));
   if (_pTransFeeContext) //this is a very volatile object, no need to hold on to it
   {
      delete _pTransFeeContext;
      _pTransFeeContext = NULL;
   }
   if (!_pTransFeeContext)
   {
      _pTransFeeContext = new TransFeeContext (*this);
      if (_pTransFeeContext->initTradeContext (this, idDataGroup) <= WARNING)
      {
         pTransFeeContext = _pTransFeeContext;
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getAccShrNumCheck ( const DString &accountNum,
                                    AccShrNumCheck *&pAccShrNumCheck,
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccShrNumCheck"));

   pAccShrNumCheck = NULL;
//for each account have a different object check object...
   DString strKey (I_("AccShrNumCheck=") + accountNum);
//look for the object
   pAccShrNumCheck = dynamic_cast <AccShrNumCheck*> (getObject ( strKey, 
                                                                 idDataGroup));
   if (!pAccShrNumCheck) //make view call
   {
      pAccShrNumCheck = new AccShrNumCheck (*this);
      if (pAccShrNumCheck->initAccNum (accountNum) <= WARNING)
      {
         setObject ( pAccShrNumCheck,
                     strKey,
                     OBJ_ACTIVITY_NONE,
                     idDataGroup);
      }            
      else 
      {
         delete pAccShrNumCheck;
         pAccShrNumCheck = NULL;
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getBroker ( Broker *&pBroker,
                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getBroker"));
   pBroker = NULL;

   DString brokerCode, dstrTransType;

   getField (ifds::TradesTransType, dstrTransType, idDataGroup, false);
   if (isManualDividend(idDataGroup) || isManualMFRAdjustment(idDataGroup))
   {
      MFAccount *pMFAccount = NULL;   
      if (getAccount (pMFAccount, idDataGroup) <= WARNING && pMFAccount) 
      {
         pMFAccount->getField (ifds::BrokerCode, brokerCode, idDataGroup, false);
      }
   }
   else
   {
      getField (ifds::Broker, brokerCode, idDataGroup, false);
   }
   if (!brokerCode.empty())
   {
      DString strKey (I_("Broker=") + brokerCode);
//look for the list
      BrokerList *pBrokerList = 
            dynamic_cast <BrokerList*> (getObject ( strKey, 
                                                    idDataGroup));
      if (!pBrokerList) //make view call
      {
         pBrokerList = new BrokerList (*this);
         if (pBrokerList->init2 ( brokerCode, 
                                  NULL_STRING, 
                                  I_("L"),  //exact match
                                  NULL_STRING, 
                                  NULL_STRING) <= WARNING)
         {
            setObject ( pBrokerList,
                        strKey,
                        OBJ_ACTIVITY_NONE,
                        idDataGroup);
         }            
         else 
         {
            delete pBrokerList;
            pBrokerList = NULL;
         }
      }
//get the broker
      if (pBrokerList)
      {
         BFObjIter bfIter (*pBrokerList, idDataGroup);

         if (!bfIter.end())
         {
            pBroker = dynamic_cast <Broker*> (bfIter.getObject());
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::getBranch ( Branch *&pBranch,
                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getBranch"));
   pBranch = NULL;

   DString brokerCode, 
      branchCode;

   getField (ifds::Broker, brokerCode, idDataGroup, false);
   getField (ifds::Branch, branchCode, idDataGroup, false);
   if ( !brokerCode.empty() && 
        !branchCode.empty())
   {
      DString strKey 
            (I_("Broker=") + brokerCode + I_(";Branch=") + branchCode);

      BranchList* pBranchList = 
            dynamic_cast <BranchList*> (getObject (strKey, idDataGroup));
      if (!pBranchList) //make view call
      {
         pBranchList = new BranchList (*this);
         if (pBranchList->init ( brokerCode, //exact match
                                 branchCode) <= WARNING)
         {
            setObject ( pBranchList, 
                        strKey,
                        OBJ_ACTIVITY_NONE,
                        idDataGroup);
         }
         else 
         {
            delete pBranchList;
            pBranchList = NULL;
         }
      }
//get the branch
      if (pBranchList)
      {
         BFObjIter bfIter (*pBranchList, idDataGroup);

         bfIter.begin();
         if (!bfIter.end())
         {
            pBranch = dynamic_cast <Branch*> (bfIter.getObject());
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getAgent ( Agent *&pAgent,
                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAgent"));
   pAgent = NULL;

   DString brokerCode, 
      branchCode,
      slsrepCode,
      createRep;

   getField (ifds::CreateRep, createRep, idDataGroup, false);
   getField (ifds::Broker, brokerCode, idDataGroup, false);
   getField (ifds::Branch, branchCode, idDataGroup, false);
   getField (ifds::SlsrepCode, slsrepCode, idDataGroup, false);
   if ( createRep == N &&
        !brokerCode.empty() && 
        !branchCode.empty() &&
        !slsrepCode.empty())
   {
      DString strKey ( I_("Broker=") + brokerCode + 
                       I_(";Branch=") + branchCode + 
                       I_(";Agent=") + slsrepCode);
      AgentList *pAgentList = dynamic_cast <AgentList*> 
                                      ( getObject ( strKey, 
                                                    idDataGroup));

      if (!pAgentList) //make view call
      {         
         pAgentList = new AgentList (*this);

         if (pAgentList->init ( brokerCode, //exact match
                                branchCode, 
                                slsrepCode) <= WARNING)
         {
            setObject ( pAgentList, 
                        strKey,
                        OBJ_ACTIVITY_NONE,
                        idDataGroup);
         }
         else
         {
            delete pAgentList;
            pAgentList = NULL;
         }
      }
      //get the agent
      if (pAgentList)
      {
         BFObjIter bfIter (*pAgentList, idDataGroup);

         bfIter.begin();
         if (!bfIter.end())
         {
            pAgent = dynamic_cast <Agent*> (bfIter.getObject());
         }
      }
      else // agent is not found 
      {
         int count = CONDITIONCOUNT();
         Condition   *c = NULL;
         for( int i = 0; i < count; i++ )
         {
            c = GETCONDITION( i );
            int condCode = c->getCode();
            if ( condCode == CND::ERR_NO_BRANCH_FOUND )
            {
               CLEARCONDITION( i );
               break;
            }
         }

         DString idiStr;
         addIDITagValue( idiStr, I_("AGENT"), slsrepCode.upperCase() );
         addIDITagValue( idiStr, I_("BROKER"), brokerCode.upperCase() );
         addIDITagValue( idiStr, I_("BRANCH"), branchCode.upperCase() );
         ADDCONDITIONFROMFILEIDI( CND::ERR_AGENT_NOT_FOUND_FOR_BROKER_BRANCH, idiStr.c_str() ); 
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getAccountHoldings ( MFAccountHoldingList *&pMFAccountHoldings,
                                     const BFDataGroupId &idDataGroup,
                                     const DString &fundCode /*= NULL_STRING*/,
                                     const DString &classCode /*= NULL_STRING*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccountHoldings"));
   DString accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup);
   accountNum.stripLeading ('0').strip();
   return getHoldings ( accountNum, 
                        pMFAccountHoldings, 
                        idDataGroup,
                        fundCode,
                        classCode);
}

//******************************************************************************
SEVERITY Trade::getAccountHoldingsCurrency (  DString &currency, 
                                              const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccountHoldingsCurrency"));
//reset the currency...
   currency = NULL_STRING;
//this method will return the account holdings currency if all the 
//holdings have the same currency, blank otherwise...
   MFAccountHoldingList *pMFAccountHoldings = NULL;
   
   if ( getAccountHoldings (pMFAccountHoldings, idDataGroup) <= WARNING &&
        pMFAccountHoldings)
   {
      BFObjIter bfIter (*pMFAccountHoldings, idDataGroup);

      while (!bfIter.end())
      {
         DString fundCode,
                 fundClass,
                 fundCurrency;

         if (bfIter.getObject())
         {
            bfIter.getObject()->getField (ifds::rxFundCode, fundCode, idDataGroup);
            bfIter.getObject()->getField (ifds::rxClassCode, fundClass, idDataGroup);
            getFundField (fundCode, fundClass, ifds::Currency, fundCurrency);
            if (currency.empty()) //first time...
            {
               currency = fundCurrency;
            }
            else if (currency != fundCurrency)
            {
               currency = NULL_STRING;
               break;
            }
         }
         ++bfIter;
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::setAccountHoldingsCurrency (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setAccountHoldingsCurrency"));

   if (_multiCurrency == N && (isFullRedemption (idDataGroup) || canCloseAccount (idDataGroup)))
   {
      MFAccountHoldingList *pMFAccountHoldings = NULL;
      
      if ( getAccountHoldings (pMFAccountHoldings, idDataGroup) <= WARNING &&
           pMFAccountHoldings)
      {
         BFObjIter bfIter (*pMFAccountHoldings, idDataGroup);

         if (!bfIter.end()) //do we have holdings?
         {
            DString accountHoldingsCurrency;

            if (getAccountHoldingsCurrency (accountHoldingsCurrency, idDataGroup) <= WARNING)
            {
               if (!_bInitPending)
               {
//even if the currency is empty, the assignment should take place...
//currency is empty if account holdings are not in the same currency 
                  setFieldNoValidate ( ifds::SettleCurrency, accountHoldingsCurrency, idDataGroup, false, 
                                       false, //not valid
                                       true);  //side effect
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getFundHoldingsForAccount ( const DString &accountNum,
                                            const DString &fundCode,
                                            const DString &classCode,
                                            MFAccountHoldingList *&pMFAccountHoldings,
                                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundHoldingsForAccount"));
   return getHoldings ( accountNum, 
                        pMFAccountHoldings, 
                        idDataGroup,
                        fundCode,
                        classCode);
   return GETCURRENTHIGHESTSEVERITY ();
}

//****************************************************************************** 
SEVERITY Trade::getMFAccountHoldingList(const DString &accountNum,
                                        const DString &dstrFund,
                                        const DString &dstrClass,
                                        const DString &asOfDate,
                                        const DString &accBalMode,
                                        MFAccountHoldingList *&pMFAccountHoldingList,
                                        const BFDataGroupId &idDataGroup)
{
    MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("getMFAccountHoldingList"));

    DString key = I_("Holdings_Account=") + accountNum + 
                        I_(";FundCode=") + dstrFund +
                        I_(";ClassCode=") + dstrClass +
                        I_(";EffectiveDate=") + asOfDate + 
                        I_(";AccBalMode=") + accBalMode;

     pMFAccountHoldingList = dynamic_cast<MFAccountHoldingList*>(getObject(key, idDataGroup));

   if (!pMFAccountHoldingList)
   {
      pMFAccountHoldingList = new MFAccountHoldingList(*this);

      if (pMFAccountHoldingList->init (accountNum, asOfDate, dstrFund, dstrClass, I_("N"), I_("N"), NULL_STRING, accBalMode) <= WARNING)
      {
         setObject (pMFAccountHoldingList, key,OBJ_ACTIVITY_NONE, idDataGroup);
      }
      else
      {
         delete pMFAccountHoldingList;
         pMFAccountHoldingList = NULL;
      }
   }


    return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getAccountToHoldings ( MFAccountHoldingList *&pMFAccountToHoldings,
                                       const BFDataGroupId &idDataGroup,
                                       const DString &fundCode /*= NULL_STRING*/,
                                       const DString &classCode /*= NULL_STRING*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccountToHoldings"));
   DString accountTo;

   getField (ifds::AccountTo, accountTo, idDataGroup, false);
   return getHoldings ( accountTo, 
                        pMFAccountToHoldings, 
                        idDataGroup,
                        fundCode,
                        classCode);
}

//******************************************************************************
double Trade::getUnitPrice ( const DString &fundCode, 
                             const DString &classCode, 
                             const DString &fromDate, 
                             const DString &toDate, 
                             const BFDataGroupId &idDataGroup,
                             const DString tradeTransType, /* = I_(""), */
                             const DString &prevDatePressed /*=I_ ("Y")*/, 
                             const DString &nextDatePressed) /*=I_ ("N")*/
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_ ("getUnitPrice"));

   DString strKey = NULL_STRING;

   if ( tradeTransType.empty() )
   {
      strKey = 
         I_("FundList_FundCode=") + fundCode        +
         I_(";ClassCode=")        + classCode       +
         I_(";FromDate=")         + fromDate        +
         I_(";ToDate=")           + toDate          +
         I_(";PrevDatePressed=")  + prevDatePressed +
         I_(";NextDatePressed=")  + nextDatePressed;
   }
   else
   {
      strKey = 
         I_("FundList_FundCode=") + fundCode        +
         I_(";ClassCode=")        + classCode       +
         I_(";TransType=")        + tradeTransType  +
         I_(";FromDate=")         + fromDate        +
         I_(";ToDate=")           + toDate          +
         I_(";PrevDatePressed=")  + prevDatePressed +
         I_(";NextDatePressed=")  + nextDatePressed;
   }

   FundList *pFundList;
   pFundList = dynamic_cast <FundList*> (getObject (strKey, idDataGroup));

   if (!pFundList)
   {
      pFundList = new FundList (*this);
      if (pFundList->init ( const_cast <DString&> (fundCode), 
                            const_cast <DString&> (classCode), 
                            const_cast <DString&> (fromDate),
                            const_cast <DString&> (toDate), 
                            const_cast <DString&> (prevDatePressed), 
                            const_cast <DString&> (nextDatePressed)) <= WARNING)
      {
         setObject (pFundList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
      }
      else
      {
         delete pFundList;
         pFundList = NULL;
      }
   }
   
   DString unitValue;
   DString tmpTransType = tradeTransType.empty () ? I_("AV") : tradeTransType;

   if (pFundList)
   {
      DString transType;

      BFObjIter bfIter (*pFundList, idDataGroup);

      for (bfIter.begin (); !bfIter.end (); ++bfIter)
      {
         bfIter.getObject ()->getField (ifds::TransType, transType, idDataGroup);
         if (transType.strip ().upperCase () == tmpTransType)
         {
            bfIter.getObject ()->getField (ifds::UnitValue, unitValue, idDataGroup);
            break;
         }
      }
   }
   return DSTCommonFunctions::convertToDouble (unitValue);
}


//******************************************************************************
void Trade::getUnitPriceDetl (BigDecimal &dUnitValue,           
                              BigDecimal &dGAV,   
                              BigDecimal &dMultiPriceUsageID,
                              DString &dstrUnitId,
                              const DString &fundCode,
                              const DString &classCode, 
                              const DString &fromDate, 
                              const DString &toDate,
                              const BFDataGroupId &idDataGroup,
                              const DString &tradeTransType,  //= I_(""), 
                              const DString &prevDatePressed, //= I_("Y")
                              const DString &nextDatePressed, //= I_("N")
                              const DString &getTransType,
                              const DString &getNextAvailRate) //= I_("")
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getUnitPriceDetl"));

   dUnitValue = dGAV = dMultiPriceUsageID = 0;
   dstrUnitId = NULL_STRING;

   DString strKey = NULL_STRING;

   if ( tradeTransType.empty() )
   {
      strKey = 
         I_("FundList_FundCode=") + fundCode        +
         I_(";ClassCode=")        + classCode       +
         I_(";FromDate=")         + fromDate        +
         I_(";ToDate=")           + toDate          +
         I_(";PrevDatePressed=")  + prevDatePressed +
         I_(";NextDatePressed=")  + nextDatePressed +
         I_(";GetTransType=")     + getTransType    +
         I_(";GetNextAvailRate=") + getNextAvailRate;
   }
   else
   {
      strKey = 
         I_("FundList_FundCode=") + fundCode        +
         I_(";ClassCode=")        + classCode       +
         I_(";TransType=")        + tradeTransType  +
         I_(";FromDate=")         + fromDate        +
         I_(";ToDate=")           + toDate          +
         I_(";PrevDatePressed=")  + prevDatePressed +
         I_(";NextDatePressed=")  + nextDatePressed +
         I_(";GetTransType=")     + getTransType    +
         I_(";GetNextAvailRate=") + getNextAvailRate;
   }

   FundList *pFundList;
   pFundList = dynamic_cast <FundList*> (getObject (strKey, idDataGroup));

   if (!pFundList)
   {
      pFundList = new FundList (*this);
      if (pFundList->init ( const_cast <DString&> (fundCode), 
                            const_cast <DString&> (classCode), 
                            const_cast <DString&> (fromDate),
                            const_cast <DString&> (toDate), 
                            const_cast <DString&> (prevDatePressed), 
                            const_cast <DString&> (nextDatePressed),
                            NO,
                            I_(""),
                            NO,
                            getTransType,
                            getNextAvailRate) <= WARNING)
      {
         setObject (pFundList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
      }
      else
      {
         delete pFundList;
         pFundList = NULL;
      }
   }
   
   DString dstrUnitValue, dstrGAV, dstrMultiPriceUsageID;
   DString tmpTransType = tradeTransType.empty () ? I_("AV") : tradeTransType;

   if (pFundList)
   {
      DString transType;

      BFObjIter bfIter (*pFundList, idDataGroup);

      for (bfIter.begin (); !bfIter.end (); ++bfIter)
      {
         bfIter.getObject ()->getField (ifds::TransType, transType, idDataGroup);
         if (transType.strip ().upperCase () == tmpTransType)
         {
             bfIter.getObject()->getField(ifds::UnitValue, dstrUnitValue, idDataGroup);
             bfIter.getObject()->getField(ifds::GAV, dstrGAV, idDataGroup);
             bfIter.getObject()->getField(ifds::MultiPriceUsageID, dstrMultiPriceUsageID, idDataGroup);

             dUnitValue = DSTCommonFunctions::convertToBigDecimal(dstrUnitValue);
             dGAV = DSTCommonFunctions::convertToBigDecimal(dstrGAV);
             dMultiPriceUsageID = DSTCommonFunctions::convertToBigDecimal(dstrMultiPriceUsageID);
             bfIter.getObject()->getField(ifds::UnitId, dstrUnitId, idDataGroup);

             break;
         }
      }
   }
}

//******************************************************************************
SEVERITY Trade::getHoldings ( const DString &accountNum,
                              MFAccountHoldingList *&pHoldings,
                              const BFDataGroupId &idDataGroup,
                              const DString &fundCode /*= NULL_STRING*/,
                              const DString &classCode /*= NULL_STRING*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getHoldings"));
   pHoldings = NULL;

   DString tradeDate,
      _accountNum (accountNum),
      _fundCode (fundCode),
      _classCode (classCode);

   getField (ifds::EffectiveDate, tradeDate, idDataGroup);
   _accountNum.stripLeading ('0');
   _fundCode.strip();
   _classCode.strip();
   if (!accountNum.empty()) 
   {
      MFAccount *pMFAccount = NULL;

      if ( getWorkSession ().getMFAccount ( idDataGroup, 
                                            accountNum, 
                                            pMFAccount) <= WARNING && 
           pMFAccount)
      {
         pMFAccount->getAccountHoldingsAsOfDate ( tradeDate, 
                                                  pHoldings, 
                                                  idDataGroup, 
                                                  _fundCode, 
                                                  _classCode);
      }
   }  
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
double Trade::getFundBalance ( const DString &accountNum,
                               const DString &fundCode,
                               const DString &classCode,
                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundBalance"));
   MFAccountHoldingList *pHoldings = NULL;
   DString settledValue,
      unsettledValue;

   if ( getFundHoldingsForAccount (accountNum, fundCode, classCode, pHoldings, idDataGroup) <= WARNING &&
        pHoldings)
   {
      BFObjIter iter ( *pHoldings, 
                        idDataGroup, 
                        true, 
                        BFObjIter::ITERTYPE::NON_DELETED);

//walk the list, match the fund and class, 
//and retrive the settled value/units

      BFData matchCriteria;

      matchCriteria.setElementValue (ifds::rxFundCode, fundCode, true);
      matchCriteria.setElementValue (ifds::rxClassCode, classCode, true);
      iter.positionOnNextMatch (matchCriteria, idDataGroup);
      if (!iter.end())
      {
         DString amtType;

         getField (ifds::AmtType, amtType, idDataGroup, false);
         amtType.upperCase();
         if (amtType == I_("U")) //units
         {
           iter.getObject()->getField (ifds::SettledUnits, settledValue, idDataGroup, false);
           iter.getObject()->getField (ifds::UnsettledUnits, unsettledValue, idDataGroup, false);
         }
         else //anything else
         {
           iter.getObject()->getField (ifds::SettledValue, settledValue, idDataGroup, false);
           iter.getObject()->getField (ifds::UnsettledValue, unsettledValue, idDataGroup, false);
         }
      }
   }
   return DSTCommonFunctions::convertToDouble (settledValue);
}

//******************************************************************************
double Trade::getFundNAV ( const DString &accountNum,
                           const DString &fundCode,
                           const DString &classCode,
                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundNAV"));

   MFAccountHoldingList *pHoldings = NULL;
   DString fundNAV;         

   if ( getFundHoldingsForAccount (accountNum, fundCode, classCode, pHoldings, idDataGroup) <= WARNING &&
        pHoldings)
   {
      BFObjIter iter ( *pHoldings, 
                        idDataGroup, 
                        true, 
                        BFObjIter::ITERTYPE::NON_DELETED);

//walk the list, match the fund and class, 
//and retrive the fund nav
      BFData matchCriteria;

      matchCriteria.setElementValue (ifds::rxFundCode, fundCode, true);
      matchCriteria.setElementValue (ifds::rxClassCode, classCode, true);
      iter.positionOnNextMatch (matchCriteria, idDataGroup);
      if (!iter.end())
      {
         iter.getObject()->getField (ifds::FundNAV, fundNAV, idDataGroup, false);
      }
      else 
      {
         DString tradeDate;
         double dFundNAV;

         getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
         dFundNAV = getUnitPrice (fundCode, classCode, tradeDate, tradeDate, idDataGroup); 

         return dFundNAV;
      }
   }
   return DSTCommonFunctions::convertToDouble (fundNAV);
}

//******************************************************************************
SEVERITY Trade::getAMSMstrInfo ( AmsMstrInfo *&pAMSMstrInfo,
                                 DString &amsCode,
                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAMSMstrInfo"));
   MFAccount *pMFAccount = NULL;
   pAMSMstrInfo = NULL;
   
   if ( getAccount (pMFAccount, idDataGroup) <= WARNING &&
        pMFAccount && 
        pMFAccount->isAMSAccount (idDataGroup))
   {
      DString tradeDate;
      AMSMstrList* pAMSMstrList = NULL;

      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      if ( pMFAccount->getAMSMstrList ( pAMSMstrList, 
                                       idDataGroup, 
                                       tradeDate) <= WARNING &&
           pAMSMstrList)
      {
         pMFAccount->getField (ifds::AMSCode, amsCode, idDataGroup, false);
         pAMSMstrList->getAMSMstrInfo ( I_("RB"),
                                        amsCode, 
                                        tradeDate, 
                                        pAMSMstrInfo, 
                                        idDataGroup);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isAMSLimitationCheckRequired ( const DString &accountNum, 
                                           const BFDataGroupId &idDataGroup)
{
   std::set < DString > setAMSFundList;

   MFAccount *pMFAccount = NULL;

   if ( supportsAllocations (idDataGroup) && //makes sense only if trans type supports allocations
        getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
        pMFAccount &&
        pMFAccount->isAMSAccount (idDataGroup)
      )
   {
      AmsFundAllocList *pAMSFundAllocList = NULL;
      
      DString effectiveDate,
         fundCode, 
         classCode, 
         amount, 
         strKey;
      
      getField (ifds::EffectiveDate, effectiveDate, idDataGroup);
      if ( pMFAccount->getAMSFundAllocList ( I_("RB"), 
                                             effectiveDate, 
                                             pAMSFundAllocList, 
                                             idDataGroup) <= WARNING &&
           pAMSFundAllocList)
      {
         BFObjIter iter ( *pAMSFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);

         AmsFundAlloc* pAMSFundAlloc = NULL;
         while (!iter.end ()) 
         {
            pAMSFundAlloc = dynamic_cast <AmsFundAlloc*> (iter.getObject ());
            
            pAMSFundAlloc->getField (ifds::FundCode, fundCode, idDataGroup);
            pAMSFundAlloc->getField (ifds::ClassCode, classCode, idDataGroup);
            pAMSFundAlloc->getField (ifds::AllocPercentage, amount, idDataGroup);
            strKey = fundCode.strip () + classCode.strip () + amount.strip ();
            setAMSFundList.insert (strKey);
            ++iter;
         }
      }
      TradeFundAllocList *pTradeFundAllocList;

      if ( getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING &&
           pTradeFundAllocList
         )
      {
         TradeFundAlloc *pTradeFundAlloc;

         BFObjIter iter ( *pTradeFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);
         std::set < DString >::iterator iterFund;
         
         while (!iter.end ()) 
         {
            pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());

            pTradeFundAlloc->getField (ifds::FundCode, fundCode, idDataGroup);
            pTradeFundAlloc->getField (ifds::ClassCode, classCode, idDataGroup);
            pTradeFundAlloc->getField (ifds::AllocPercentage, amount, idDataGroup);
            strKey = fundCode.strip () + classCode.strip () + amount.strip ();
            iterFund = setAMSFundList.find (strKey);
            if (iterFund == setAMSFundList.end ())
            {
               return false;
            }
            ++iter;
         }
         // If the above iteration is complete, the allocation between AMS and Trade
         // are identical so AMS Limitation check is required.
         return true;
      }
   }
   return false;
}
//******************************************************************************
bool Trade::isAMSTradeViaParentFundClass (const BFDataGroupId &idDataGroup)
{
	/* for AMS account Trade via parent fund/class, the allocation will not be populated */
	DString dstrAccountNum;
	MFAccount *pMFAccount = NULL;

	if (isPurchase(idDataGroup) || isRedemption(idDataGroup))
		getField(ifds::AccountNum, dstrAccountNum, idDataGroup, false);
	else if (isTransfer(idDataGroup) || isExchange(idDataGroup) || isInterClassSwitch(idDataGroup))
		getField(ifds::AccountTo, dstrAccountNum, idDataGroup, false);
	else
		return false;

	if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && 
		pMFAccount )
	{ 
		if ( (pMFAccount->isAMSAccount (idDataGroup)) && pMFAccount->isAccountAttachedAMSC(idDataGroup) )
			return true;
	}

	return false;
}
//*****************************************************************************
SEVERITY Trade::loadNetworkIDValues (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("loadNetworkIDValues"));

   DString validNetworkType; //comma separated list of valid network types for the environment

   getWorkSession().getOption ( ifds::ValidNetworkType,
                                validNetworkType,
                                BF::HOST,
                                false);
   if (!validNetworkType.empty())
   {
      if (validNetworkType.find (I_("AWD")) == DString::npos)
      {
         validNetworkType.stripTrailing ( ',' );
         validNetworkType += I_(",AWD"); 
      }

      loadSubstitutionList (ifds::NetworkID, idDataGroup, validNetworkType);
//set the 'other confirm type subst set'
      BFProperties *pBFPropNetworkID = 
         getFieldProperties (ifds::NetworkID, idDataGroup);

      assert (pBFPropNetworkID);
      if (pBFPropNetworkID)
      {
         DString networkIDSubstList;

         pBFPropNetworkID->getAllSubstituteValues (networkIDSubstList);
         {
            networkIDSubstList = I_("= ;") + networkIDSubstList;
            setFieldAllSubstituteValues (ifds::NetworkID, idDataGroup, networkIDSubstList);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::otherConfirmTypeRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("otherConfirmTypeRelatedChanges"));
   DString otherConfirmType,
      networkID;

   getField (ifds::OtherConfirmType, otherConfirmType, idDataGroup);
   getField (ifds::NetworkID, networkID, idDataGroup);
   otherConfirmType.strip();
   if (!_bInitPending)
   {
      setFieldNoValidate ( ifds::ConfirmRequired, otherConfirmType.empty() ? Y : N, idDataGroup, false, 
                           true, true);
   }

   DString canSuppressConfirm;

   getWorkSession ().getOption ( ifds::CanSuppressConfirm, 
                                 canSuppressConfirm, 
                                 BF::HOST,
                                 false);
    setFieldReadOnly ( ifds::ConfirmRequired, 
                      idDataGroup, 
                      canSuppressConfirm != Y ||
                      networkID == I_("SWFT") || 
                      networkID == I_("PWLD") ||
                      networkID == I_("IMSF") ||
                      networkID == I_("UDUK"));
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::extTransNumRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("extTransNumRelatedChanges"));

   DString networkID, 
      extTransNum;

   getField (ifds::NetworkID, networkID, idDataGroup);
   getField (ifds::ExtTransNum, extTransNum, idDataGroup);  
   if ( (networkID == I_("PWLD") || networkID == I_("RBCD")) && 
        !extTransNum.empty()) //trade is an electronic one!!!
   {
      setOtherConfirmTypeDefaultValues (idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::networkIDRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("networkIDRelatedChanges"));

   DString networkID;

   getField (ifds::NetworkID, networkID, idDataGroup);
   setFieldValid (ifds::SendRefNum, idDataGroup, false);
   setFieldValid (ifds::AmtType, idDataGroup, false);
   setFieldValid (ifds::SettleCurrency, idDataGroup, false);
   
   if (networkID.empty())
   {
      setFieldNoValidate ( ifds::SendRefNum, NULL_STRING, idDataGroup, false, 
                           true, false);
	  //Get Default from the configuration table and set the source and channel only for new trades.
	  if( isNew())
	  {
		setFieldWithDefaultValue(ifds::SourceOfTrade, idDataGroup);
		setFieldWithDefaultValue(ifds::ChannelOfTrade, idDataGroup);
	  }
   }
   setFieldReadOnly ( ifds::SendRefNum, 
                      idDataGroup, 
                      networkID.empty()); 
   deliveryNetworkRelatedChanges(idDataGroup);
   //setOtherConfirmTypeDefaultValues (idDataGroup); moved this over to deliveryNetworkRelatedChanges as 
   //with the new implementation the Delivery network drives the Confrim type values.
   setAccountabilityReasonCodeDefaultValues (idDataGroup);

   setRespRequiredSubstList(idDataGroup);
   if ( !_bInitPending )
   {
      DString respRequired = ( networkID == I_("IMSF") || networkID == I_("UDUK") ) ? I_("1"):I_("0");
      setFieldNoValidate( ifds::NetworkRespRequired, respRequired, idDataGroup, false, 
         true, true);
   }
   bool bEnableNetRespReq = ( I_("IMSF") == networkID || 
   							  I_("UDUK") == networkID ||
							  I_("SWFT") == networkID || 
							  I_("OCRI") == networkID ||
                              I_("SWFX") == networkID);
   setFieldReadOnly( ifds::NetworkRespRequired,idDataGroup,!bEnableNetRespReq); 
   DString dstrAWDFieldFlag;
   getWorkSession ().getOption (ifds::AWDFieldFlag, dstrAWDFieldFlag,BF::HOST,false);
   if(networkID != I_("AWD") && dstrAWDFieldFlag == I_("Y"))
      setFieldNoValidate(ifds::ExtTransNum,I_(""),idDataGroup,false);
   if( dstrAWDFieldFlag == I_("Y"))	
   {
      setFieldReadOnly(ifds::ExtTransNum, idDataGroup, networkID != I_("AWD"));
      setFieldRequired(ifds::ExtTransNum, idDataGroup, networkID == I_("AWD"));
   }
   bool bSrc_Channel_ReadOnly =	false ;
   if( !networkID.empty()&& 
	   !( I_("AWD") == networkID  && YES == dstrAWDFieldFlag ) )  //AWD integration flag Yes use default,no change
   { 
	  //If a Network ID selected the source and NetworkID should have the same value
	  setFieldNoValidate(ifds::SourceOfTrade, networkID, idDataGroup, false, true, true, !_bInitPending );
	  setFieldNoValidate(ifds::ChannelOfTrade, NULL_STRING, idDataGroup, false, true, true, !_bInitPending );	  
	  //setFieldValid( const BFFieldId& idField, const BFDataGroupId& idDataGroup, bool bValid );
	  bSrc_Channel_ReadOnly  = true;  
   }
   setFieldReadOnly(ifds::SourceOfTrade,  idDataGroup, bSrc_Channel_ReadOnly );
   setFieldReadOnly(ifds::ChannelOfTrade, idDataGroup, bSrc_Channel_ReadOnly );

   return GETCURRENTHIGHESTSEVERITY ();
}

//***************************************************************************** 
SEVERITY Trade::setAccountabilityReasonCodeDefaultValues (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setAccountabilityReasonCodeDefaultValues"));
   DString networkID, backDatedReason, accountable;

   getWorkSession().getOption(ifds::BackDatedReason, backDatedReason, idDataGroup, false);
   getWorkSession().getOption(ifds::Accountable, accountable, idDataGroup, false);

   getField (ifds::NetworkID, networkID, idDataGroup);
   if (networkID == I_("PWLD") && isBackdatedTrade (idDataGroup))
   {
      if (!_bInitPending)
      {
         setFieldNoValidate ( ifds::BackDatedReason, backDatedReason, idDataGroup, false, //Missed Trade - Client/Fund Timestamp
                              false, //invalid
                              true);//notify
         setFieldNoValidate ( ifds::Accountable, accountable, idDataGroup, false, //Client
                              false, //invalid
                              true);//notify
      }      
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::setOtherConfirmTypeDefaultValues (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setOtherConfirmTypeDefaultValue"));
   DString dstrDeliveryNetwork,
      otherConfirmType, 
      extTransNum;

   getField (ifds::DeliveryNetwork, dstrDeliveryNetwork, idDataGroup);
   getField (ifds::ExtTransNum, extTransNum, idDataGroup);

 bool bOtherConfirmTypeReadOnly =   
                      dstrDeliveryNetwork.empty()       || 
                      I_("SWFT") == dstrDeliveryNetwork || 
                      I_("IMSF") == dstrDeliveryNetwork ||
                      I_("UDUK") == dstrDeliveryNetwork ||
                      I_("PWLD") == dstrDeliveryNetwork ||
                      I_("RBCD") == dstrDeliveryNetwork || 
                      I_("SWFX") == dstrDeliveryNetwork ||
                      I_("OCRI") == dstrDeliveryNetwork ;
   if ( I_("SWFT") == dstrDeliveryNetwork || 
        I_("IMSF") == dstrDeliveryNetwork || 
        I_("UDUK") == dstrDeliveryNetwork /* ||
        I_("SWFX") == dstrDeliveryNetwork */ ) //swift/IMSF/UDUK/SWFX	
   {
      otherConfirmType = I_("2");
   }
   else if( I_("SWFX") == dstrDeliveryNetwork )
   {
       otherConfirmType = I_("8");
   }
   else if ( I_("PWLD") == dstrDeliveryNetwork ) //partner world
   {
      otherConfirmType = I_("3");
   }
   else if (I_("IVST") == dstrDeliveryNetwork) //investro
   {
//check if account and fund are PUEV capable
      if (areAccountAndFundPUEVCapable (idDataGroup))
      {
         otherConfirmType = I_("1"); //set the default value for OtherConfirmType tp '1' - Create PUEV Note
         bOtherConfirmTypeReadOnly = true;
      }
   }
   else if (I_("RBCD") == dstrDeliveryNetwork || 
            I_("GFS")  == dstrDeliveryNetwork || 
            I_("FRON") == dstrDeliveryNetwork || 
            I_("MLBR") == dstrDeliveryNetwork || 
            I_("BEAR") == dstrDeliveryNetwork ||
			I_("AFLR") == dstrDeliveryNetwork )
   {
      otherConfirmType = I_("5"); //RBC Dexia
   }
   if (!_bInitPending)
   {
      setFieldNoValidate ( ifds::OtherConfirmType, otherConfirmType, idDataGroup, false, 
                           false, //invalid
                           true);//notify
   }
   setFieldReadOnly ( ifds::OtherConfirmType, 
                      idDataGroup, 
                      bOtherConfirmTypeReadOnly); 
   return GETCURRENTHIGHESTSEVERITY ();
}
//*****************************************************************************
bool Trade::accountHasCategory( const DString &dstrCategory, 
                                const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSenderRefNum"));
   
   bool bHasCategory = false;

    DString dstrAccountNum; 
   getField (ifds::AccountNum, dstrAccountNum, idDataGroup);
    MFAccount *pMFAccount = NULL;

    if ( getWorkSession ().getMFAccount ( idDataGroup, 
                                          dstrAccountNum, 
                                          pMFAccount ) <= WARNING && 
         NULL != pMFAccount)
   {
      DString dstrAcctCategoryExist;   
      pMFAccount->getField( ifds::AcctCategoryExist, dstrAcctCategoryExist, idDataGroup );
      if ( I_( "Y" ) == dstrAcctCategoryExist.strip().upperCase() )
      {
         AcctCategoryList *pAcctCategoryList = NULL;
         if ( pMFAccount->getAcctCategoryList( pAcctCategoryList, 
                                              idDataGroup ) <= WARNING &&
             NULL != pAcctCategoryList )
         {
            bHasCategory = pAcctCategoryList->isCategoryExist( idDataGroup, dstrCategory );         
         }
      }
   }

   return bHasCategory;
}

//*****************************************************************************
SEVERITY Trade::validateSenderRefNum ( const DString &senderRefNum,
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSenderRefNum"));

   DString networkID;

   getField (ifds::NetworkID, networkID, idDataGroup);
   if (!networkID.empty() && senderRefNum.empty())
   {
      getErrMsg ( IFASTERR::SENDER_REF_NUM_REQUIRED,
                  CND::ERR_SENDER_REF_NUM_REQUIRED, 
                  CND::WARN_SENDER_REF_NUM_REQUIRED, 
                  idDataGroup);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::validateOtherConfirmType ( const DString &otherConfirmType,
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateOtherConfirmType"));
   DString dstrDeliveryNetworkID;

   //getField (ifds::NetworkID, networkID, idDataGroup); Other Confirm type is driven by Delivery network with new 
   //chnages and no longer with Network ID
   getField (ifds::DeliveryNetwork, dstrDeliveryNetworkID, idDataGroup);
   
 if ( ( I_("SWFT") != dstrDeliveryNetworkID && I_("PWLD") != dstrDeliveryNetworkID && 
	    I_("IMSF") != dstrDeliveryNetworkID && I_("UDUK") != dstrDeliveryNetworkID &&
        I_("SWFX") != dstrDeliveryNetworkID ) && 
		I_("2") == otherConfirmType ) //swift like confirm 
   {
      ADDCONDITIONFROMFILE (CND::ERR_CONFIRM_TYPE_ONLY_VALID_FOR_SWIFT);
   }
   else if (otherConfirmType == I_("1"))
   {
   //account and fund should pe PUEV capable
   //check if account is PUEV capbale and fund are PUEV capable
      DString accountNum,
         fundCode;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      getField (ifds::FromFund, fundCode, idDataGroup);
      bool bRaiseError = !accountNum.empty() && !fundCode.empty();
      if ( bRaiseError && 
           accountHasCategory( I_("09"), idDataGroup))
      {
         //check if fund is PUEV capable
         FundMasterList *pFundMasterList = NULL;
         if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
              pFundMasterList)
         {
            bRaiseError = !pFundMasterList->isPUEVCapableFund (fundCode);
         }
      }

      if (GETCURRENTHIGHESTSEVERITY () <= WARNING && bRaiseError)
      {
         ADDCONDITIONFROMFILE (CND::ERR_ACCOUNT_FUND_NOT_PUEV_CAPABLE);
      }
   }
   else if (otherConfirmType == I_("5")) //RBC Dexia
   {
      if ( I_("RBCD") != dstrDeliveryNetworkID && 
           I_("GFS")  != dstrDeliveryNetworkID && 
           I_("FRON") != dstrDeliveryNetworkID && 
           I_("MLBR") != dstrDeliveryNetworkID && 
           I_("BEAR") != dstrDeliveryNetworkID &&
		   I_("AFLR") != dstrDeliveryNetworkID)
      {
         ADDCONDITIONFROMFILE (CND::ERR_INVALID_CONFIRM_TYPE_FOR_NETWORKID);
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::validateNetworkID ( const DString &networkID,
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateNetworkID"));
   DString extTransNum;

   getField (ifds::ExtTransNum, extTransNum, idDataGroup);
   extTransNum.strip();
   if (extTransNum == NULL_STRING && networkID == I_("RBCD")) //manual trade
   {
      ADDCONDITIONFROMFILE (CND::ERR_NETWORKID_NOT_VALID_FOR_MANUAL_TRADES);
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//SSB Germany 
//PET1117.FN66 SWIFT R2.16, R2.17, R2.18
//PET1117.FN68 Partnerworld R4.2
//*****************************************************************************
SEVERITY Trade::validateAPIFundCurrency ( const DString &apiFundCurrency,
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAPIFundCurrency"));
   if (!apiFundCurrency.empty())
   {
//should validate the entered fund currency against the from fund currency
      DString fundCode,
         classCode;

      getField (ifds::FromFund, fundCode, idDataGroup, false);
      getField (ifds::FromClass, classCode, idDataGroup, false);
      if ( !fundCode.empty() &&
           !classCode.empty())
      {
   //from currency, set-up
         DString fundCurrency_;

         getFundField (ifds::Currency, fundCurrency_, idDataGroup);
         if (!fundCurrency_.empty())
         {
            if (apiFundCurrency != fundCurrency_)
            {
               DString idiStr;

               addIDITagValue (idiStr, I_("fund_cur"), apiFundCurrency);
               addIDITagValue (idiStr, I_("fund_level_cur"), fundCurrency_);

               ADDCONDITIONFROMFILEIDI (CND::ERR_FUND_CURRENCIES_NOT_MATCHING, idiStr)
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::getFundBrokerRoutingType ( const DString &accountNum,
                                           const DString &fundCode,
                                           DString &routingType,
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundBrokerRoutingType"));

   DString fundBrokerApplicable;

   getWorkSession().getOption ( ifds::FundBrokerApplicable, 
                                fundBrokerApplicable,
                                BF::HOST,
                                false);

   if (fundBrokerApplicable == Y)
   {
      DString defaultBrokerCode,dstrFdBrokerDefaultLevel;
      
      if (getDefaultFundBrokerCode (accountNum, fundCode, defaultBrokerCode,dstrFdBrokerDefaultLevel, idDataGroup) <= WARNING)
      {
         FundBroker *pFundBroker = NULL;

         if ( getFundBroker (defaultBrokerCode, pFundBroker, idDataGroup) <= WARNING && 
              pFundBroker)
         {
            pFundBroker->getField (ifds::RoutingType, routingType, idDataGroup, false);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::validateAmtTypeForNetworkIDAndFundBroker ( const DString &accountNum,
                                                           const DString &fundCode,
                                                           const BFDataGroupId &idDataGroup,
                                                           const DString &networkIDs /*= NULL_STRING*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAmtTypeForNetworkIDAndFundBroker"));

   if (!accountNum.empty() && !fundCode.empty())
   {
      DString networkID;

      getField (ifds::NetworkID, networkID, idDataGroup);
      networkID.strip();
      FundMasterList *pFundMasterList = NULL;
      if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
           pFundMasterList)
      {
         if (pFundMasterList->isDepotFund (fundCode))
         {
            if (!networkID.empty() && networkIDs.find (networkID) == DString::npos)
            {
               DString idiStr,
                  networkIDDescr;

               getField (ifds::NetworkID, networkIDDescr, idDataGroup, true);
               addIDITagValue (idiStr, I_("ntwk"), networkIDDescr);

               ADDCONDITIONFROMFILEIDI (CND::ERR_AMOUNT_TYPE_INVALID_FOR_DEPOT_FUNDS, idiStr);
            }
         }
         else if (pFundMasterList->is3rdPartyFund (fundCode))
         {
            if (networkID.empty())
            {
               //check if default fund broker is fax capable
               DString routingType;

               if (getFundBrokerRoutingType (accountNum, fundCode, routingType, idDataGroup) <= WARNING)
               {
                  bool bFaxOrSwift = (routingType == I_("01") || routingType == I_("03") || routingType == I_("05"));
                  //if (routingType != I_("01")) //not 'Fax'
                  if (!bFaxOrSwift) //not 'Fax' and 'Swift'	and 'SWFX'	  // AFT Out Bound
                  {
                     ADDCONDITIONFROMFILE (CND::ERR_AMOUNT_TYPE_INVALID_FOR_3_RD_PARTY_FUNDS_WITH_FUNDBROKER);
                  }
               }
            }
            else
            {
               DString idiStr,
                  networkIDDescr;

               getField (ifds::NetworkID, networkIDDescr, idDataGroup, true);
               addIDITagValue (idiStr, I_("ntwk"), networkIDDescr);

               ADDCONDITIONFROMFILEIDI (CND::ERR_AMOUNT_TYPE_INVALID_FOR_3_RD_PARTY_FUNDS_VIA_NETWORK, idiStr);
               
            }
         }
         else if ( pFundMasterList->isUpToCertificateSpecialFund (fundCode) ||
                   pFundMasterList->isGlobalCertificateSpecialFund (fundCode))

         {
            ADDCONDITIONFROMFILE (CND::ERR_AMOUNT_TYPE_INVALID_FOR_SPECIAL_FUNDS);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
bool Trade::areAccountAndFundPUEVCapable (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("areAccountAndFundPUEVCapable"));
   bool bAreAccountAndFundPUEVCapable = false;
//check if account and fund are PUEV capable
   //check if the account is PUEV capbale
   //get account category list for category '09'
   if ( accountHasCategory( I_("09"), idDataGroup ) )
   {
      //check if fund is PUEV capable
      FundMasterList *pFundMasterList = NULL;
      if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING &&
           pFundMasterList)
      {
          DString fundCode;
          getField (ifds::FromFund, fundCode, idDataGroup);
          if (pFundMasterList->isPUEVCapableFund (fundCode))
          {
             bAreAccountAndFundPUEVCapable = true;
         }
      }
   }

   return bAreAccountAndFundPUEVCapable;
}

//API validations per PET 1117/68
//*****************************************************************************
SEVERITY Trade::validateParticipantID ( const DString &participantID,
                                        const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateParticipantID"));

   bool bRaiseError = false;

   if (!participantID.empty())
   {
      //get the account owners vector
      DString accountNum;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      accountNum.stripLeading('0').strip();
      if (!accountNum.empty())
      {
         AccountEntityXref *pAccountEntityXref = NULL;
         if ( getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
              pAccountEntityXref)
         {
            ENTITIES_VECTOR acctOwnerEntities;

            pAccountEntityXref->getAcctOwnerEntities ( acctOwnerEntities, 
                                                       accountNum, 
                                                       idDataGroup);
            bRaiseError = true; //prepare the flag to raise error, 
            for (ENTITIES_VECTOR::size_type i = 0; i < acctOwnerEntities.size(); ++i)
            {
               //get the entity ids list for every owner...
               DString entityId = acctOwnerEntities [i];
               Entity *pEntity = NULL;

               if ( getWorkSession().getEntity ( idDataGroup, 
                                                 entityId, 
                                                 pEntity) <= WARNING &&
                     pEntity)
               {
                  EntityIdsList *pEntityIdsList = NULL;

                  if ( pEntity->getEntityIdsList (pEntityIdsList, idDataGroup) <= WARNING &&
                        pEntityIdsList)
                  {
                     BFObjIter iter (*pEntityIdsList, idDataGroup);

                     while (!iter.end())
                     {
                        DString idType;

                        iter.getObject()->getField (ifds::IdType, idType, idDataGroup);
                        if (idType == I_("10")) //BIC Code
                        {
                           DString idValue;

                           iter.getObject()->getField (ifds::IdValue, idValue, idDataGroup);
                           //retrieve the first 8 characters...
                           idValue = idValue.left (8);
                           if (idValue == participantID) //matches the participant id value
                           {
                              bRaiseError = false;
                           }
                        }
                        if (!bRaiseError) //one match found, break the loop
                        {
                           break;
                        }
                        ++iter;
                     }
                  }
               }
               if (!bRaiseError) //one match found, break the loop
               {
                  break;
               }
            } //for loop of account owners
         }//account x ref
      }//account num is empty
   }//empty participant id
   if (GETCURRENTHIGHESTSEVERITY () <= WARNING && bRaiseError)
   {
      DString strIDI;

      addIDITagValue (strIDI, I_("PID"), participantID);

        getErrMsg ( IFASTERR::MATCHING_BIC_CODE_NOT_FOUND, 
                    CND::ERR_NO_MATCHING_BIC_CODE_FOUND, 
                    CND::WARN_NO_MATCHING_BIC_CODE_FOUND, 
                    idDataGroup, strIDI);

   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::getFundField ( const BFFieldId &idField, 
                               DString &strValue,
                               const BFDataGroupId &idDataGroup)
{
//this method calls 'getFundAndClassFieldIds' implemented by each
//derived class from trade, which returns the correct 'fund/class' code
//field ids (i.e Transfers respond with 'to side', Purchases with 'from side')
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundField"));

   DString fundCode, 
      classCode;
   BFFieldId fundFieldId (ifds::NullFieldId),
      classFieldId (ifds::NullFieldId);

   strValue = NULL_STRING;
   getFundAndClassFieldIds (fundFieldId, classFieldId);
   getField (fundFieldId, fundCode, idDataGroup, false);
   getField (classFieldId, classCode, idDataGroup, false);
   if ( !fundCode.empty() &&
        !classCode.empty()) 
   {
      getFundField (fundCode, classCode, idField, strValue);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
SEVERITY Trade::getFundField ( const DString &fundCode, 
                               const DString &classCode, 
                               const BFFieldId &idField, 
                               DString &strValue)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFundField"));
//this method based on the given values of 'fund/class' code 
//returns the value for the 'idField' from the FundDetail object
   FundDetail *pFundDetail = NULL;

   if ( getWorkSession().getFundDetail (fundCode, classCode, BF::HOST, pFundDetail) &&
        pFundDetail)
   {
      pFundDetail->getField (idField, strValue, BF::HOST, false);
      strValue.strip ().upperCase ();
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getAccountField ( const BFFieldId &idField, 
                                  DString &strValue,
                                  const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccountField"));
   DString accountNum;
   
   BFFieldId accountNumFieldId (ifds::NullFieldId);

   strValue = NULL_STRING;
   getAccountFieldId (accountNumFieldId);
   getField (accountNumFieldId, accountNum, idDataGroup, false);
   if (!accountNum.empty()) 
   {
      MFAccount *pMFAccount = NULL;

      if ( getWorkSession ().getMFAccount ( idDataGroup, 
                                            accountNum, 
                                            pMFAccount) <= WARNING && 
           pMFAccount)
      {
         pMFAccount->getField (idField, strValue, idDataGroup, false);
      }
   }  
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getAccount ( MFAccount *&pMFAccount, 
                             const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getAccountField"));
   DString accountNum;
   pMFAccount = NULL;

   getAccountField (ifds::AccountNum, accountNum, idDataGroup);
   if (!accountNum.empty()) 
   {      
      getWorkSession ().getMFAccount (idDataGroup, accountNum, pMFAccount);
   }  
   return GETCURRENTHIGHESTSEVERITY ();
}

//allocation helpers

//******************************************************************************
SEVERITY Trade::refreshAllocations (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("refreshAllocations"));
   
   TradeFundAllocList *pTradeFundAllocList = NULL;

   if ( getFundAllocationList ( pTradeFundAllocList, 
                                idDataGroup) <= WARNING &&
        pTradeFundAllocList)
   {
      DString fundCode,
         classCode;

      if ( getFundField (ifds::FundCode, fundCode, idDataGroup) <= WARNING &&
           !fundCode.empty() &&
           getFundField (ifds::ClassCode, classCode, idDataGroup) <= WARNING &&
           !classCode.empty())
      {
         BFObjIter iter ( *pTradeFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);
         int iAllocNum = iter.getNumberOfItemsInList ();
//clear the allocations, since the user entered fund an class
         if (iAllocNum > 1 || (iAllocNum == 1 && !iter.getObject ()->isNew ()))
         {
            pTradeFundAllocList->clearAllocations (idDataGroup);
         }

         BFObjIter iter1 ( *pTradeFundAllocList, 
                           idDataGroup, 
                           false, 
                           BFObjIter::ITERTYPE::NON_DELETED);

         if (iter1.getNumberOfItemsInList () == 0) //have to add one allocation, if list empty
         {
            pTradeFundAllocList->addNewAllocation ( NULL_STRING, 
                                                    idDataGroup, 
                                                    false, 
                                                    true, 
                                                    false);
         }
         //only one allocation and it is new, reset fund and class
         else if (iAllocNum == 1 && iter.getObject ()->isNew ())
         {
            iter1.getObject ()->setField (ifds::FundCode, fundCode, idDataGroup, false, true);
            iter1.getObject ()->setField (ifds::ClassCode, classCode, idDataGroup, false, true);
         }
         else 
         {
            assert (0);
         }
      }
   }
//always refresh splits, when refreshing allocations
   refreshSplitCommissions (idDataGroup);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::refreshSplitCommissions (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("refreshSplitCommissions"));

   if (_bShouldRefreshSplitCommissions) //refresh splits only if the guard allows us to do it
   {
      SplitCommissionList *pSplitCommissionList = NULL;

      getSplitCommissionList ( pSplitCommissionList, 
                              idDataGroup, 
                              true,
                              true); //also, blow the list
      if (pSplitCommissionList)
      {
         //notify the trans fee list of the change
         TransFeeList *pTransFeeList = NULL;

         if ( getTransFeeList (pTransFeeList, idDataGroup, false) <= WARNING &&
              pTransFeeList)
         {
            //pTransFeeList->refresh(idDataGroup);//, true); 
			pTransFeeList->setForcingRefresh(true);
            pTransFeeList->onNotify (FIELD_NOTIFICATIONS, E_EVENT_VALUE_CHANGE, I_("ForceRefresh"));
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
void Trade::setAllocField ( const BFFieldId &idFromField, 
                            const BFFieldId &idToField, 
                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setAllocField"));
   TradeAcctAllocList *pAccountAllocationList = NULL;
   DString str;
   
   getField (idFromField, str, idDataGroup, false);
   if ( getAccountAllocationList ( pAccountAllocationList, 
                                   idDataGroup, 
                                   //don't create it here, if not already created
                                   false ) <= WARNING &&
        pAccountAllocationList)
   {
      pAccountAllocationList->setField (idToField, str, idDataGroup, false);
   }
   
   RESPBeneficiaryAllocationList *pRESPBeneficiaryAllocationList = NULL;

   if (getRESPBenefAllocationList (pRESPBeneficiaryAllocationList, idDataGroup, false) <= WARNING && 
       pRESPBeneficiaryAllocationList)
   {
      pRESPBeneficiaryAllocationList->setField (idToField, str, idDataGroup, false);
   }

   RESPTransferList *pRESPTransferList = NULL;

   if (getRESPTransferList (pRESPTransferList, idDataGroup, false) <= WARNING && 
       pRESPTransferList)
   {
      pRESPTransferList->setField (idToField, str, idDataGroup, false);
   }
}

//******************************************************************************
void Trade::setFromAllocField ( const BFFieldId &idFromField, 
                                const BFFieldId &idToField, 
                                const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setFromAllocField"));
   TradeFromFundAllocList *pTradeFromFundAllocList = NULL;
   DString str;
   
   getField (idFromField, str, idDataGroup, false);
   if ( getFromFundAllocationList ( pTradeFromFundAllocList, 
                                    idDataGroup, 
                                    false) <= WARNING && 
        pTradeFromFundAllocList)
   {
      pTradeFromFundAllocList->setField (idToField, str, idDataGroup, false);
   }
}

//******************************************************************************
bool Trade::hasFromAllocations (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("hasFromAllocation"));
   bool bHasFromAllocations = false;

   if (supportsFromAllocations (idDataGroup))
   {
//check whehter the from allocation has more then one 
//records, this should be blank, do not raise condition
      TradeFromFundAllocList *pTradeFromFundAllocList = NULL;

      if ( getFromFundAllocationList ( pTradeFromFundAllocList, 
                                       idDataGroup, 
                                       //do not create the allocations
                                       false) <= WARNING && 
           pTradeFromFundAllocList)
      {
         BFObjIter iter ( *pTradeFromFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);
         bHasFromAllocations = iter.getNumberOfItemsInList () > 0;
      }
   }
   return bHasFromAllocations;
}

//******************************************************************************
bool Trade::hasAllocations (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("hasAllocations"));
   bool bhasAllocations = false;

   if (supportsAllocations (idDataGroup))
   {
//get the fund alloc list
      TradeFundAllocList *pTradeFundAllocList = NULL;

      if ( getFundAllocationList ( pTradeFundAllocList, 
                                   idDataGroup,
                                   false ) <= WARNING && //do not create the allocations
          pTradeFundAllocList)
      {
         BFObjIter iter ( *pTradeFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);

         bhasAllocations = iter.getNumberOfItemsInList () > 1; //1 means 100% allocation
      }
   }
   return bhasAllocations;
}

//******************************************************************************
bool Trade::hasTradePayInstruct (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("hasTradePayInstruct"));
   
   bool bHasTradePayInstruct = false;

   TradePayInstructList *pTradePayInstructList (NULL);

   if ( arePayInstructAllowed (idDataGroup) && 
        getTradePayInstructList (pTradePayInstructList, idDataGroup, false) <= WARNING && 
        pTradePayInstructList)
   {
      BFObjIter iter ( *pTradePayInstructList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      bHasTradePayInstruct = iter.getNumberOfItemsInList () > 0;
   }
   return bHasTradePayInstruct;
}

//******************************************************************************
bool Trade::isRollover (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isRollover"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::ROLLOVER;
}

//******************************************************************************
bool Trade::isPurchase (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isPurchase"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::PURCHASE;
}
//******************************************************************************
bool Trade::isAllPurchase (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isAllPurchase"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return (DSTCommonFunctions::codeInList (transType, TRADETYPE::PURCHASE_LIKE_2));
}
//******************************************************************************
bool Trade::isTransfer (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isTransfer"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::TRANSFER;
}

//******************************************************************************
bool Trade::isExchange (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isExchange"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::EXCHANGE;
}

//******************************************************************************
bool Trade::isInterClassSwitch(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isInterClassSwitch"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::INTER_CLASS_SWITCH;
}

//******************************************************************************
bool Trade::isRedemption (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isRedemption"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::REDEMPTION;
}

//******************************************************************************
bool Trade::isAutoWithdraw (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isAutoWithdraw"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::AUTO_WITHDRAW;
}

//******************************************************************************
bool Trade::isManualDividend (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isManualDividend"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::DIVIDEND || DSTCommonFunctions::codeInList(transType, TRADETYPE::POST_DIVIDEND_ADJUSTMENT_LIST);
}

//******************************************************************************
bool Trade::isManualMFRAdjustment(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isManualMFRAdjustment"));
   
   DString transType;
   getField(ifds::TradesTransType, transType, idDataGroup, false);

   return transType == TRADETYPE::MGMT_FEE_REBATE_ADJ;
}

//******************************************************************************
bool Trade::isRedemptionLike (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isRedemptionLike"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return (DSTCommonFunctions::codeInList (transType, TRADETYPE::REDEMPTION_LIKE));
}

//******************************************************************************
bool Trade::isPurchaseLike (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isPurchaseLike"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return (DSTCommonFunctions::codeInList (transType, TRADETYPE::PURCHASE_LIKE));
}

//******************************************************************************
bool Trade::isExchangeLike (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isExchangeLike"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return (DSTCommonFunctions::codeInList (transType, TRADETYPE::EXCHANGE_LIKE));
}

//******************************************************************************
bool Trade::isOneSideTrade (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isOneSideTrade"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return (DSTCommonFunctions::codeInList (transType, TRADETYPE::ONE_SIDE_TRADE));
}

//******************************************************************************
bool Trade::isAllTransfer (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isAllTransfer"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::ALL_FUND_TRANSFER;
}

//******************************************************************************
bool Trade::isMgmtFee (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isMgmtFee"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::MGMT_FEE;
}


//******************************************************************************
bool Trade::isAdvisorFee(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isAdvisorFee"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::ADVISOR_FEE;
}


//******************************************************************************
bool Trade::isAdminFee (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_ ("isAdminFee"));
   DString transType;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   return transType == TRADETYPE::ADMIN_FEE;
}

//******************************************************************************
bool Trade::isFullRedemption (const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isFullRedemption"));

// main implementation is in the Redemption
   return false;
}

//******************************************************************************
void Trade::applyModPerm ( const DString &modPerm,
                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("modPermRelatedChanges"));
   bool bSetFieldsReadOnly = true;
   std::set <const BFFieldId> noReadOnly;

   setFieldNoValidate (ifds::TransModPerm, modPerm, idDataGroup, false);
   if (modPerm == I_("0")) //should disable everything
   {
      ;
   }
   else if (modPerm == I_("1"))
   {
//nothing to be done, fields should remain as they are
      bSetFieldsReadOnly = false;
   }

   else if ( modPerm == I_("2") || //'aggregated' order
             modPerm == I_("3") || //'price loaded' order
             modPerm == I_("4") )  //'price posted' order  
   {
      noReadOnly.insert (ifds::ConfirmRequired);
      noReadOnly.insert (ifds::Remarks1);
      noReadOnly.insert (ifds::Remarks2);
      noReadOnly.insert (ifds::Remarks3);
      noReadOnly.insert (ifds::SecRecFileIndicator);
      noReadOnly.insert (ifds::MCHFileIndicator);
      noReadOnly.insert (ifds::NetworkRespRequired);
      noReadOnly.insert (ifds::Accountable);
      noReadOnly.insert (ifds::BackDatedReason);

      if ( modPerm == I_("2") || 
           modPerm == I_("3") )
      {
//allowed fields are
         noReadOnly.insert (ifds::FrSettlLocCode);
         noReadOnly.insert (ifds::FrDeliveryTo);
         noReadOnly.insert (ifds::FrSettlLocDescription);
         noReadOnly.insert (ifds::FrInFavourOf);
         noReadOnly.insert (ifds::FrForAccount);
         noReadOnly.insert (ifds::FrSettlInstrCode);
         noReadOnly.insert (ifds::FrClearingMethod);
         noReadOnly.insert (ifds::FrClearingMethod);
		 noReadOnly.insert (ifds::FrCSDLocation);
		 noReadOnly.insert (ifds::FrCSDAcctNum);
         for(int i= 0; i< SETL_LOC_FIELDS::numSttlInstrFrReadOnlyFields; i++ )
         {
           noReadOnly.insert (SETL_LOC_FIELDS::SttlInstrFrReadOnlyFields[i]);
         }
         if (modPerm == I_("3")) 
         {
            noReadOnly.insert (ifds::AcqFeeOption);
         }
      }
      else if (modPerm == I_("4")) //'price posted' order
      {
         noReadOnly.insert (ifds::GoodBad);
      }
   }
    else if (modPerm == I_("5"))
   {
	   noReadOnly.insert (ifds::GoodBad);
	   noReadOnly.insert (ifds::ExchRate);
	   noReadOnly.insert (ifds::TradeInDate);
	   noReadOnly.insert (ifds::SettleInDate);
	   noReadOnly.insert (ifds::ExchInFee);
   }
   else
   {
      assert (0); //no other value allowed
      bSetFieldsReadOnly = false; //at least give the opportunity of changing things
   }
   if (bSetFieldsReadOnly)
   {
      for (int i = 0; i < NUM_FIELDS; i++)
      {
         BFCBO::CLASS_FIELD_INFO fieldInfo = classFieldInfo [i];     
         const BFFieldId &fieldId = fieldInfo.getFieldId();

         if (noReadOnly.find (fieldId) == noReadOnly.end())
         {
            setFieldReadOnly (fieldId, idDataGroup, true);
         }
      }
   }
  
}
//******************************************************************************
inline bool Trade::isAccountCloningAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isAccountCloningAllowed"));
   return false;
}

//******************************************************************************
bool Trade::isBankingNeeded (const BFDataGroupId &idDataGroup,
                             BFAbstractCBO* pObjToCheck /*= NULL*/)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isBankingNeeded"));
   DString payMethod, 
      payType;

   if (!pObjToCheck)
   {
      getField (ifds::TradesPayType, payType, idDataGroup, false);
      getField (ifds::PayMethod, payMethod, idDataGroup, false);
   }
   else
   {
      pObjToCheck->getField (ifds::PayType, payType, idDataGroup, false);
      pObjToCheck->getField (ifds::PayMethod, payMethod, idDataGroup, false);
   }

   payMethod.strip ().upperCase ();

   return (payType == PAYTYPE::EFT || payType == PAYTYPE::DIRECT_DEPOSIT)  &&  (payMethod != I_("CHQ") );
}

//******************************************************************************
bool Trade::isShareholderAddressNeeded (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isShareholderAddressNeeded"));
   DString payMethod, 
      payType;

   getField (ifds::TradesPayType, payType, idDataGroup, false);
   getField (ifds::PayMethod, payMethod, idDataGroup, false);
   return payType == PAYTYPE::EFT && 
          payMethod == I_("CHQ") && 
          !arePayInstructAllowed (idDataGroup);
}

//******************************************************************************
bool Trade::areAllocationsAllowed (const BFDataGroupId &idDataGroup)
{
//this method is called by the GUI to determine whether the allocations should be displayed
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isAllocationAllowed"));
   DString invAdvice,
      amtType;

   getWorkSession().getOption ( ifds::InvAdvice,
                                invAdvice,
                                BF::HOST,
                                false);
   getField (ifds::AmtType, amtType, idDataGroup, false);
   return //if transaction supports allocations 
          (supportsAllocations (idDataGroup) || supportsFromAllocations (idDataGroup)) &&
          //system feature
          invAdvice == Y && 
          //amount type units and allocations are incompatible
          amtType != I_("U") && 
          !canCloseAccount (idDataGroup);
}

//******************************************************************************
bool Trade::areRESPBenefAllocationsAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("areRESPBenefAllocationsAllowed"));

   return false;
}

//******************************************************************************
inline bool Trade::isRESPTransferAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isRESPTransferAllowed"));

   return false;
}

//******************************************************************************
inline bool Trade::isAIPAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isAIPAllowed"));

   return false;
}
//******************************************************************************
inline bool Trade::isAssociationWithBeneficiaryAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isAssociatedBeneficiaryAllowed"));

   return isRESPTradeAccount (idDataGroup) && 
          !areRESPBenefAllocationsAllowed (idDataGroup) && 
          !isRESPTransferAllowed (idDataGroup) &&
          !isAIPAllowed (idDataGroup);
}

//******************************************************************************
inline bool Trade::areTaxRatesAllowed (const BFDataGroupId &idDataGroup)
{
   //redemption will respond with true; admin fee/mgmt fee/rollovers with false
   return false;
}

//******************************************************************************
inline bool Trade::isPSEEAPAllowed(const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
inline bool Trade::isRDSPTransferAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isRDSPTransferAllowed"));

   return false;
}

//******************************************************************************
bool Trade::isSplitCommissionAllowed (const BFDataGroupId &idDataGroup)
{
   bool bAllowed = false;

   if (supportsAllocations (idDataGroup) && !SplitCommission::isTypeZERO (getWorkSession()))
   {
      DString feeWaived;

      getAccountField (ifds::FeeWaived, feeWaived, idDataGroup);
      bAllowed = feeWaived != Y;
      if (bAllowed)
      {
         TradeFundAllocList *pFundAllocationList = NULL;

         if ( getFundAllocationList (pFundAllocationList, idDataGroup, false) <= WARNING &&
              pFundAllocationList)
         {
            BFObjIter iter (*pFundAllocationList, idDataGroup);

            while (!iter.end())
            {
               TradeFundAlloc *pTradeFundAlloc = dynamic_cast <TradeFundAlloc *> (iter.getObject());

               if (pTradeFundAlloc)
               {
                  pTradeFundAlloc->refreshSplitCommFlag (idDataGroup);
               }
               ++iter;
            }
            
            DString splitComm;

            pFundAllocationList->GetSplitCommFlag (idDataGroup, splitComm);   
            bAllowed = splitComm == Y;
         }
         else
         {
            bAllowed = false;
         }
      }
   }
   return bAllowed;
}

//******************************************************************************
bool Trade::isSettleLocAllowed (const BFDataGroupId &idDataGroup)
{
   return false; //generally we do not allow settle locations
}


//******************************************************************************
bool Trade::areMultipleSettleLocAllowed (const BFDataGroupId &idDataGroup)
{
   return false; //in general we do not allow multiple settle locations
}
//******************************************************************************
bool Trade::isGIAAttribAllowed (const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
bool Trade::isGIInvestmentListApplicable(const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
bool Trade::isEstateAllocationListApplicable(const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
bool Trade::isMaturityInstrAllowed (const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
bool Trade::isSegTrade (const BFDataGroupId &idDataGroup)
{
   bool bIsSegTrade = false;
   
   if (isSegEnvironment (idDataGroup))
   {
      DString fundCode, 
         classCode;

      if(isOneSideTrade (idDataGroup))
      {
         getFundField (ifds::FundCode, fundCode, idDataGroup); 
         getFundField (ifds::ClassCode, classCode, idDataGroup);
         if (!fundCode.empty() && !classCode.empty())
         {
            FundMasterList *pFundMasterList (NULL);

            if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
                 pFundMasterList)
            {
               bIsSegTrade = pFundMasterList->isSegregatedFund (fundCode);
            }
         }
      }
      else
      {
         if(isAllTransfer (idDataGroup))
         {
            bIsSegTrade = isSEGPortfolio(idDataGroup);
         }
         else
         {
            getField (ifds::FromFund, fundCode, idDataGroup); 
            getField (ifds::FromClass, classCode, idDataGroup);
            if (!fundCode.empty() && !classCode.empty())
            {
               FundMasterList *pFundMasterList (NULL);

               if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
                    pFundMasterList)
               {
                  bIsSegTrade = pFundMasterList->isSegregatedFund (fundCode);
               }
            }

            getField (ifds::ToFund, fundCode, idDataGroup); 
            getField (ifds::ToClass, classCode, idDataGroup);
            if (!fundCode.empty() && !classCode.empty() )
            {
               FundMasterList *pFundMasterList (NULL);

               if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
                    pFundMasterList)
               {
                  bIsSegTrade |= pFundMasterList->isSegregatedFund (fundCode);
               }
            }
         }
      }
   }

   return bIsSegTrade;
}

//******************************************************************************
bool Trade::isValidDateLag (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isValidDateLag"));

   DString tradeDateLag;

   getWorkSession ().getOption2 ( ifds::TradeDateLag, 
                                  tradeDateLag, 
                                  BF::HOST, 
                                  false);

   if (tradeDateLag == Y)
   {
      BFData requestData (ifds::DSTC0181_REQ);
      BFData receivedData (ifds::DSTC0181_VW);

      DString mgmtCoIdOut, 
         transNum;
      
      getField (ifds::TransNum, transNum, idDataGroup);
      requestData.setElementValue (ifds::CompanyId, getMgmtCoId (mgmtCoIdOut));
      requestData.setElementValue (ifds::TransNum, transNum);
      requestData.setElementValue (ifds::Track, I_ ("N"));
      requestData.setElementValue (ifds::Activity, NULL_STRING);
      BFDataBroker::getInstance ()->receive ( DSTC_REQUEST::TRADE_DATE_LAG_VALIDATION, 
                                              requestData, 
                                              receivedData, 
                                              DSTCRequestor (getSecurity (), true, true));

   }
   return GETCURRENTHIGHESTSEVERITY () <= WARNING;
}

//******************************************************************************
inline int Trade::getYear (const DString &strDate)
{
   int year = 0;
   DString strTemp (strDate);
   BFDate date (strDate, BFDate::DF_DDATE_DEPRECATED);   
   
   if (!strTemp.strip ().empty ())
   {
      year = date.getYear ();
   }
   return year;
}

//******************************************************************************
bool Trade::canCloseAccount (const BFDataGroupId &idDataGroup)
{
//method called useful in Redemption/Transfer   
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("canCloseAccount"));

   DString redCode, 
      fundCode, 
      classCode, 
      amount,
      trexclRCList;

   getField (ifds::Amount, amount, idDataGroup);
   getField (ifds::RedCode, redCode, idDataGroup);
   getFundField (ifds::FundCode, fundCode, idDataGroup); 
   getFundField (ifds::ClassCode, classCode, idDataGroup);

   double dec_amount = DSTCommonFunctions::convertToDouble (amount);

   getWorkSession().getOption ( ifds::TRExclRedCodes, 
                                trexclRCList, 
                                BF::HOST,
                                false);
   return !redCode.empty() &&
          DSTCommonFunctions::codeInList (redCode, trexclRCList) && 
          dec_amount == 0 && 
          fundCode.empty() && 
          classCode.empty();
}

//******************************************************************************
bool Trade::isSameAccountOwner (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isSameAccountOwner"));   
   DString accountNum,
      accountTo;

   getField (ifds::AccountNum, accountNum, idDataGroup);
   accountNum.stripLeading('0').strip();
   getField (ifds::AccountTo, accountTo, idDataGroup, false); 
   accountTo.stripLeading('0').strip();
   
   bool bIsSameOwner = accountTo == accountNum;
   
   if ( !accountTo.empty() && 
        !accountNum.empty() && 
        !bIsSameOwner) //check whether the owner is the same
   {
      AccountEntityXref *pAccountEntityXref = NULL;
      if ( getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
           pAccountEntityXref)
      {
         DString entityId01;
         EntityIdsList *pEntityIdsList (NULL);

         if (pAccountEntityXref->GetEntityIdForAccountOwnerSequence1 ( accountNum, 
                                                                       idDataGroup, 
                                                                       entityId01) <= WARNING)
         {
            DString cssStopSINMatch;

            getWorkSession ().getOption ( ifds::CSSStopSINMatch, 
                                          cssStopSINMatch, 
                                          BF::HOST,
                                          false);
            
//if the generic control is turned on we need to look if the SIN# are matching
            if (cssStopSINMatch == I_("Y"))
            {
               Entity *pEntity (NULL);
               if ( getWorkSession().getEntity ( idDataGroup, 
                                                 entityId01, 
                                                 pEntity) <= WARNING &&
                     pEntity)
               {

                  if ( pEntity->getEntityIdsList (pEntityIdsList, idDataGroup) <= WARNING &&
                       pEntityIdsList)
                  {
                        ;// do nothing
                  }
               }
            }

            typedef std::vector< DString > ENTITIES_VECTOR;
            ENTITIES_VECTOR toOwnerEntities;
   
            pAccountEntityXref->getAcctOwnerEntities ( toOwnerEntities, 
                                                       accountTo, 
                                                       idDataGroup);
            for (ENTITIES_VECTOR::size_type j = 0; j < toOwnerEntities.size(); ++j)
            {
               if (cssStopSINMatch == I_("Y"))
               {
                  if (pEntityIdsList && GETCURRENTHIGHESTSEVERITY () <= WARNING)
                  {
                     BFObjIter iter (*pEntityIdsList, idDataGroup);

                     while (!iter.end())
                     {
                        DString idType;

                        iter.getObject()->getField (ifds::IdType, idType, idDataGroup);
                        if (idType == I_("06")) //SIN
                        {
                           DString idValue;

                           iter.getObject()->getField (ifds::IdValue, idValue, idDataGroup);
                           //read the entity ids list of the other account owner
                           Entity *pEntity (NULL);
                           if ( getWorkSession().getEntity ( idDataGroup, 
                                                             toOwnerEntities [j], 
                                                             pEntity) <= WARNING &&
                                pEntity)
                           {
                              EntityIdsList *pEntityIdsListTo = NULL;

                              if ( pEntity->getEntityIdsList (pEntityIdsListTo, idDataGroup) <= WARNING &&
                                   pEntityIdsListTo)
                              {
                                 BFObjIter iter1 (*pEntityIdsListTo, idDataGroup);

                                 while (!iter1.end())
                                 {
                                    DString idType;

                                    iter1.getObject()->getField (ifds::IdType, idType, idDataGroup);
                                    if (idType == I_("06")) //SIN
                                    {
                                       DString idValueTo;

                                       iter1.getObject()->getField (ifds::IdValue, idValueTo, idDataGroup);
                                       if (idValue == idValueTo)
                                       {
                                          bIsSameOwner = true;
                                          break;
                                       }
                                    }
                                    ++iter1;
                                 }
                              }
                           }
                        }
                        if (bIsSameOwner)
                        {
                           break; //entity id owner loop for from account owner
                        }
                        ++iter;
                     } //entity ids owner loop
                  }
                  if (bIsSameOwner)
                  {
                     break; //to account owners loop
                  }
               }
               else
               {
                  if (entityId01 == toOwnerEntities [j])
                  {
                     bIsSameOwner = true;
                     break;
                  }
               }
            }
         }
      }
   }
   return bIsSameOwner;
}

//******************************************************************************
SEVERITY Trade::copyFeeValuesForCycleProcessing (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("copyFeeValuesForCycleProcessing"));
   //go thru the fees list
   TransFeeList *pTransFeeList = NULL;

   if ( getTransFeeList (pTransFeeList, idDataGroup, false) <= WARNING &&
        pTransFeeList)
   {
      initFeeFields (idDataGroup); //clear the fee fields...

      BFObjIter iter ( *pTransFeeList, 
                       idDataGroup, 
                       0, 
                       BFObjIter::ITERTYPE::NON_DELETED);

      while (!iter.end())
      {
         TransFee *pFee = dynamic_cast <TransFee*> (iter.getObject());
         if (pFee)
         {
            DString feeCode,
               feeRate,
               feeType,
               feeCharge,
               currency;
            
            pFee->getField (ifds::TransFeeCode, feeCode, idDataGroup);
            pFee->getField (ifds::FeeRate, feeRate, idDataGroup, false);
            pFee->getField (ifds::FeeType, feeType, idDataGroup, false);
            pFee->getField (ifds::Currency, currency, idDataGroup, false);
            if (pFee->isChargeFee (idDataGroup))
            {
               pFee->getField (ifds::FeeCharge, feeCharge, idDataGroup, false);
            }
            if ( feeCode == FEES::ACQUISITION || //acq fee
                 feeCode == FEES::EXCHANGE || //exchange fee, for non split env
                 feeCode == FEES::XFER_OUT || //split comm for trsf/exch
                 feeCode == FEES::REDEMPTION)  //redemption fee
            {
               setFieldNoValidate ( ifds::Fee, feeRate, idDataGroup, false, 
                                    true, false, false);
               if (feeType == I_("0")) //flat
               {
                  setFieldNoValidate ( ifds::FlatPercent, Y, idDataGroup, false, 
                                       true, false, false); //Flat 
               }
               else if (feeType == I_("1")) //percent
               {
                  setFieldNoValidate ( ifds::FlatPercent, I_("N"), idDataGroup, false, 
                                       true, false, false); //Percentage 
               }
               setFieldNoValidate ( ifds::FeeCurrency, currency, idDataGroup, false, 
                                    true, false, false); //Percentage 
            }
            else if (feeCode == FEES::ADL) //adl fee
            {
               assert (!feeCharge.empty());
               if (feeCharge == I_("N"))
               {
                  setFieldNoValidate ( ifds::ADLFeeCharge, I_("0"), idDataGroup, false,  //no
                                       true, false, false);
               }
               else if (feeCharge == Y)
               {
                  setFieldNoValidate ( ifds::ADLFeeCharge, I_("1"), idDataGroup, false,  //yes
                                       true, false, false);
               }
            }
            else if (feeCode == FEES::DSC || feeCode == FEES::CLAWBACK)
            {               
               DString tradeFeeOption;

               pFee->getField (ifds::TradeFeeOption, tradeFeeOption, idDataGroup);
               if (tradeFeeOption == I_("2")) //only if the fee is overriden, assign the appropriate values
               {
                  setFieldNoValidate ( ifds::DSCOverrideAmt, feeRate, idDataGroup, false, 
                                       true, false, false);
                  if (feeType == I_("0")) //flat
                  {
                     setFieldNoValidate ( ifds::DSCOverrideCode, I_("1"), idDataGroup, false, 
                                          true, false, false); //Flat Amount DSC Override
                  }
                  else if (feeType == I_("1")) //percent
                  {
                     setFieldNoValidate ( ifds::DSCOverrideCode, I_("2"), idDataGroup, false, 
                                          true, false, false); //Percentage DSC Override
                  }
               }
               //P0178201FN01_WaiveDSCforClosedFund
               else if (tradeFeeOption == I_("4"))
               {
                  setFieldNoValidate ( ifds::DSCOverrideCode, I_("3"), idDataGroup, false, 
                     true, false, false); 
               }
            }
            else if ( feeCode == FEES::EARLY_REDEMPTION ||
                      feeCode == FEES::SHORT_TERM_TRANSFER)
            {
               assert (!feeCharge.empty());
               setFieldNoValidate ( ifds::ChargeERSTTRFee, feeCharge, idDataGroup, false, 
                                    true, false, false);
            }
            else if (feeCode == FEES::EXCHANGE_IN)
            {
               setFieldNoValidate ( ifds::ExchInFee, feeRate, idDataGroup, false, 
                                    true, false, false);
               if (feeType == I_("0")) //flat
               {
                  setFieldNoValidate ( ifds::ExchInFlatPercent, Y, idDataGroup, false, 
                                       true, false, false); //Flat 
               }
               else if (feeType == I_("1")) //percent
               {
                  setFieldNoValidate ( ifds::ExchInFlatPercent, I_("N"), idDataGroup, false, 
                                       true, false, false); //Percentage 
               }
            }
            else if (feeCode == FEES::EXCHANGE_OUT)
            {
               setFieldNoValidate ( ifds::ExchOutFee, feeRate, idDataGroup, false, 
                                    true, false, false);
               if (feeType == I_("0")) //flat
               {
                  setFieldNoValidate ( ifds::ExchOutFlatPrcnt, Y, idDataGroup, false, 
                                       true, false, false); //Flat 
               }
               else if (feeType == I_("1")) //percent
               {
                  setFieldNoValidate ( ifds::ExchOutFlatPrcnt, I_("N"), idDataGroup, false, 
                                       true, false, false); //Percentage 
               }
            }
            else if (feeCode == FEES::WITHDRAWAL)
            {
               assert (!feeCharge.empty());
               setFieldNoValidate ( ifds::ChargeWDFee, feeCharge, idDataGroup, false, 
                                    true, false, false);
            }
            else if (feeCode == FEES::XFER_IN)
            {
               setFieldNoValidate ( ifds::FeeTo, feeRate, idDataGroup, false, 
                                    true, false, false);

               if (feeType == I_("0")) //flat
               {
                  setFieldNoValidate ( ifds::ToFlatPercent, Y, idDataGroup, false, 
                                       true, false, false); //Flat 
               }
               else if (feeType == I_("1")) //percent
               {
                  setFieldNoValidate ( ifds::ToFlatPercent, I_("N"), idDataGroup, false, 
                                       true, false, false); //Percentage 
               }
            }
         }
         ++iter;
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::initFeeFields (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("initFeeFields"));
//last four flags mean:
//not formatted/always valid/no side effect/no apply related changes
   setFieldNoValidate (ifds::Fee, I_("0"), idDataGroup, false, true, false, false);
   setFieldNoValidate (ifds::FeeTo, I_("0"), idDataGroup, false, true, false, false);
   setFieldNoValidate (ifds::FlatPercent, I_("N"), idDataGroup, false, true, false, false); //percentage
   setFieldNoValidate (ifds::ToFlatPercent, I_("N"), idDataGroup, false, true, false, false); //percentage
   setFieldNoValidate (ifds::ADLFeeCharge, I_("0"), idDataGroup, false, true, false, false); //no
   setFieldNoValidate (ifds::ChargeERSTTRFee, I_("N"), idDataGroup, false, true, false, false);
//Incident# 271000, default ChargeWDFee should always be set to Y if Redemption fee is to be charged - cycle rule            
   setFieldNoValidate (ifds::ChargeWDFee, Y, idDataGroup, false, true, false, false);
   setFieldNoValidate (ifds::ExchOutFee, I_("0"), idDataGroup, false, true, false, false);
   setFieldNoValidate (ifds::ExchOutFlatPrcnt, I_("N"), idDataGroup, false, true, false, false); //percentage
   setFieldNoValidate (ifds::ExchInFee, I_("0"), idDataGroup, false, true, false, false);
   setFieldNoValidate (ifds::ExchInFlatPercent, I_("N"), idDataGroup, false, true, false, false);//percentage
   setFieldNoValidate (ifds::FeeCurrency , I_(""), idDataGroup, false, true, false, false);
   setFieldNoValidate (ifds::DSCOverrideCode, I_("0"), idDataGroup, false, true, false, false); //no override
   setFieldNoValidate (ifds::DSCOverrideAmt, I_("0"), idDataGroup, false, true, false, false);
   return GETCURRENTHIGHESTSEVERITY ();
}
//*********************************************************************
bool Trade::isROAApplicable (const BFDataGroupId &idDataGroup)
{
    return false;
}
//*********************************************************************
void Trade::roaAmountRelatedChanges (const BFDataGroupId &idDataGroup)
{
   if (isROAApplicable (idDataGroup))
   {
      refreshSplitCommissions (idDataGroup);
   }
}

//*********************************************************************
void Trade::exchRateRelatedChanges (const BFDataGroupId &idDataGroup)
{
    if (isROAApplicable (idDataGroup))
    {
       refreshSplitCommissions (idDataGroup);    
    }
	setFieldValid( ifds::Amount, idDataGroup, false);
}

//*********************************************************************
void Trade::getROARelatedFields ( DString &amt, 
                                  DString &amtType, 
                                  DString &currency,
                                  DString &exchRate, 
                                  const BFDataGroupId &idDataGroup)
{
    amt = I_("0.0"); // in case of Non ROA enviroment,amt should be set to 0.0
    getField (ifds::AmtType,amtType,idDataGroup );
    getField (ifds::SettleCurrency,currency,idDataGroup );
    getField (ifds::ExchRate,exchRate,idDataGroup );
}

//*****************************************************************************
SEVERITY Trade::clearROAAmount (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("clearROAAmount"));

   //check if this is an ROA transtype
   //do not clear the field otherwise, field is not avaialable
   //clearing it will trigger fee notifications
   //no need to notify the fees if the field doesn't count for the business
   if (isROATransType (idDataGroup))
   {
      bool bReadOnly = !isROAApplicable (idDataGroup);

      if (bReadOnly) 
      {
         setFieldNoValidate (ifds::ROAAmount, I_("0.0"), idDataGroup, false, true, true);
      }
      setFieldReadOnly (ifds::ROAAmount, idDataGroup, bReadOnly);
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//*****************************************************************************
bool Trade::isROATransType (const BFDataGroupId &idDataGroup)
{
   DString roaTransType,
      transType;
   
   getWorkSession ().getOption (ifds::ROATransType, roaTransType, BF::HOST, false);
   getField (ifds::TradesTransType, transType, idDataGroup, false);
   roaTransType.strip();
   transType.strip();
   return DSTCommonFunctions::codeInList (transType, roaTransType);
}

//*****************************************************************************
bool Trade::isDilutionAllowed (const BFDataGroupId &idDataGroup)
{
   DString dstrSplitAcCode, 
           dstrAccountableMand,
           dstrFundSERVClient;

   getWorkSession ().getOption (ifds::SplitAcCode, dstrSplitAcCode, BF::HOST, false);
   getWorkSession ().getOption (ifds::AccountableMandatory, dstrAccountableMand, BF::HOST, false);
   getWorkSession ().getOption (ifds::FundSERVClient, dstrFundSERVClient, BF::HOST, false);
   
   return isBackdatedTrade (idDataGroup) &&
          ((dstrSplitAcCode == Y && dstrAccountableMand == Y) ||
          (dstrSplitAcCode == N && dstrFundSERVClient == Y));
}

//******************************************************************************
SEVERITY Trade::getDilutionAllocList ( DilutionAllocList *&pDilutionAllocList, 
                                       const BFDataGroupId &idDataGroup, 
                                       bool bCreate ) // true

{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getDilutionAllocList"));

   pDilutionAllocList = NULL;
   SEVERITY severity = NO_CONDITION;
   bool bSetObject = false;

   DString strKey = I_("DilutionAllocList");

   pDilutionAllocList = 
         dynamic_cast <DilutionAllocList *> ( getObject ( strKey, 
                                                          idDataGroup));

   if (isDilutionAllowed (idDataGroup))
   {
      if (!pDilutionAllocList && bCreate)
      {
         bSetObject = true;
         pDilutionAllocList = new DilutionAllocList (*this);
         if ( isNew() ) // new trade
         {
            severity = pDilutionAllocList->initNew (idDataGroup);
         }
         else if (_bRebook)
         {
            TransactionList *pTransactionList = nullptr;
            getAdjustTransactionList (pTransactionList,idDataGroup);

            DString dstrOrgTransId, 
               dstrTransId;

            getField (ifds::TransId, dstrTransId, idDataGroup, false);
            dstrTransId.strip().upperCase();
            if (pTransactionList)
            {
               BFObjIter iterAdjustedTrans(*pTransactionList, idDataGroup, BFObjIter::NON_DELETED);

               iterAdjustedTrans.begin();
               while (!iterAdjustedTrans.end())
               {
                  BFCBO *pObj = 
                     dynamic_cast<BFCBO*>(iterAdjustedTrans.getObject());

                  if (pObj != nullptr)
                  {
                     pObj->getField (ifds::TransId, dstrOrgTransId, idDataGroup, false);
                     dstrOrgTransId.strip().upperCase();

                     if (dstrTransId != dstrOrgTransId) break;
                  }
                  ++iterAdjustedTrans;
               }

               DilutionAllocList* pDilutionAllocListClone = new DilutionAllocList (*this);

               if (pDilutionAllocList->init (dstrOrgTransId, idDataGroup) <= WARNING)
               {
                  if ((severity = pDilutionAllocListClone->cloneForReebokWithNewTransId (dstrTransId, pDilutionAllocList, idDataGroup)) <= WARNING)
                  {
                     delete pDilutionAllocList;
                     pDilutionAllocList = NULL;
                     pDilutionAllocList = pDilutionAllocListClone;
                  }
               }
            }
         }
         else
         {
            DString dstrTransId;
            getField (ifds::TransId, dstrTransId, idDataGroup, false);
            severity = pDilutionAllocList->init (dstrTransId,
                                                 idDataGroup);
         }
      }

      if (severity <= WARNING && pDilutionAllocList)
      {
         BFObjIter iter ( *pDilutionAllocList, 
                           idDataGroup, 
                           false, 
                           BFObjIter::ITERTYPE::NON_DELETED);

         DString dstrAccountable, dstrBackDatedReason;

         if (iter.getNumberOfItemsInList () == 0)
         {
            
            getField (ifds::Accountable,dstrAccountable,idDataGroup,false);
            getField (ifds::BackDatedReason,dstrBackDatedReason,idDataGroup,false);

            //this adds the 100 % allocation
            severity =    pDilutionAllocList->addNewAllocation(   dstrAccountable, 
                                                               dstrBackDatedReason, 
                                                               idDataGroup);
         }

         if (severity <= WARNING)
         {
            if (bSetObject)
            {
               setObject ( pDilutionAllocList, 
                           strKey, 
                           OBJ_ACTIVITY_NONE, 
                           idDataGroup);

               if (((_bRebook) || (!_bRebook && _bInitPending))&& iter.getNumberOfItemsInList () == 1)
               {
                  iter.begin();
                  iter.getObject()->getField(ifds::Accountable,dstrAccountable,idDataGroup,false);
                  iter.getObject()->getField(ifds::BackDatedReason,dstrBackDatedReason,idDataGroup,false);
                  dstrAccountable.strip().upperCase();
                  dstrBackDatedReason.strip().upperCase();

                  setFieldNoValidate(ifds::Accountable,dstrAccountable,idDataGroup,false,true,true,false);
                  setFieldNoValidate(ifds::BackDatedReason,dstrBackDatedReason,idDataGroup,false,true,true,false);
               }
            }
//to force validation on those fields
            setFieldValid (ifds::Accountable, idDataGroup, false);
            setFieldValid (ifds::BackDatedReason, idDataGroup, false);
            setFieldValid (ifds::AcctableTradeDate, idDataGroup, false); 
         }
         else
         {
            delete pDilutionAllocList;
            pDilutionAllocList = NULL;
         }
      }
   }
   else 
   {
      if (pDilutionAllocList != NULL)
      {
         if (!isNew () && !_bRebook)
         {
            BFObjIter bfIter (*pDilutionAllocList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);
   
            bfIter.begin();
            while (!bfIter.end())
            {            
               bfIter.deleteObject ();
            }
         }
         else
         {
            BFObjIter bfIter (*this, idDataGroup);

            if (bfIter.positionByKey (strKey))
            {
               bfIter.removeObjectFromMap (true);
               pDilutionAllocList = NULL;
            }
         }
      }
   }

   if ( NULL != pDilutionAllocList )
   {
      DString dstrTradeDate, dstrSettleDate;
      getField( ifds::EffectiveDate, dstrTradeDate,  idDataGroup, false );
      getField( ifds::SettleDate,    dstrSettleDate, idDataGroup, false );

      pDilutionAllocList->setTradeDate( dstrTradeDate );
      pDilutionAllocList->setSettleDate( dstrSettleDate );
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getSettlementLocsList (TradeSettlementLocationsList *&pTradeSettlementLocationsList, 
                                       const BFDataGroupId &idDataGroup, 
                                       bool bCreate)

{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getSettlementLocsList"));

   pTradeSettlementLocationsList = NULL;
   SEVERITY severity = NO_CONDITION;
   bool bSetObject = false;

   DString dstrTransNum;

   getField (ifds::TransNum, dstrTransNum, idDataGroup, false);

   DString strKey = I_("TransNum=") + dstrTransNum;

   pTradeSettlementLocationsList = dynamic_cast <TradeSettlementLocationsList*> (getObject (strKey, idDataGroup));

   if (areMultipleSettleLocAllowed (idDataGroup))
   {
      if (!pTradeSettlementLocationsList && bCreate)
      {

         bSetObject = true;
         pTradeSettlementLocationsList = new TradeSettlementLocationsList (*this);
         if (isNew() || _bRebook) //for rebook it should behave as a new trade
         {
            severity = pTradeSettlementLocationsList->initNew (idDataGroup);
         }
         else
         {
            severity = pTradeSettlementLocationsList->init (dstrTransNum, idDataGroup);
         }
      }

      if (severity <= WARNING && pTradeSettlementLocationsList)
      {
         if (severity <= WARNING)
         {
            if (bSetObject)
            {
               setObject (pTradeSettlementLocationsList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
            }
         }
         else
         {
            delete pTradeSettlementLocationsList;
            pTradeSettlementLocationsList = NULL;
         }
      }
   }
   else 
   {
      if (pTradeSettlementLocationsList != NULL)
      {
         if (!isNew ())
         {
            BFObjIter bfIter (*pTradeSettlementLocationsList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

            bfIter.begin();
            while (!bfIter.end())
            {            
               bfIter.deleteObject ();
            }
         }
         else
         {
            BFObjIter bfIter (*this, idDataGroup);

            if (bfIter.positionByKey (strKey))
            {
               bfIter.removeObjectFromMap (true);
               pTradeSettlementLocationsList = NULL;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getRESPBenefAllocationList (RESPBeneficiaryAllocationList *&pRESPBeneficiaryAllocationList, 
                                            const BFDataGroupId &idDataGroup, 
                                            bool bCreate)

{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getRESPBenefAllocationList"));

   pRESPBeneficiaryAllocationList = NULL;
   SEVERITY severity = NO_CONDITION;
   bool bSetObject = false;

   DString accountNum,
      depositType,
      transId;

   getAccountNumToPopulateRespBeneficiary (accountNum, idDataGroup);
   getField (ifds::DepositType, depositType, idDataGroup,false);
   getField (ifds::TransId, transId, idDataGroup,false);

   DString strKey = I_("RESPBeneficiaryAllocationList");

   pRESPBeneficiaryAllocationList = dynamic_cast <RESPBeneficiaryAllocationList*> (getObject (strKey, idDataGroup));

   if (areRESPBenefAllocationsAllowed (idDataGroup))
   {
   //to clear the list - both lists depend on similar criteria
      RESPTransferList *pRESPTransferList = NULL;

      if (getRESPTransferList (pRESPTransferList, idDataGroup, false) <= WARNING && 
          pRESPTransferList)
      {
         //do nothing;
      }
      if (!pRESPBeneficiaryAllocationList && bCreate)
      {
         bSetObject = true;

         pRESPBeneficiaryAllocationList = new RESPBeneficiaryAllocationList (*this);
         if (isNew() || _bRebook) //for rebook it should behave as a new trade
         {
            severity = pRESPBeneficiaryAllocationList->initNew (accountNum, idDataGroup);
            if (isNew())
            {
               pRESPBeneficiaryAllocationList->add100PercentBeneAlloc (idDataGroup);
            }
         }
         else
         {
            severity = pRESPBeneficiaryAllocationList->init (accountNum, transId);
         }
      }

      if (severity <= WARNING && pRESPBeneficiaryAllocationList)
      {
         if (severity <= WARNING)
         {
            if (bSetObject)
            {
               setObject (pRESPBeneficiaryAllocationList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 

               DString amount, 
                  amtType, 
                  currency,
                  tradeDate;

               getField (ifds::Amount, amount, idDataGroup, false);
               getField (ifds::AmtType, amtType, idDataGroup, false);
               getField (ifds::Currency, currency, idDataGroup, false);
               getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
               pRESPBeneficiaryAllocationList->setField ( ifds::Amount, 
                                                          amount, 
                                                          idDataGroup, 
                                                          false);
               pRESPBeneficiaryAllocationList->setField ( ifds::AmtType, 
                                                          amtType, 
                                                          idDataGroup, 
                                                          false);            
               pRESPBeneficiaryAllocationList->setField ( ifds::Currency, 
                                                          currency, 
                                                          idDataGroup, 
                                                          false);
               pRESPBeneficiaryAllocationList->setField ( ifds::EffectiveDate, 
                                                          tradeDate, 
                                                          idDataGroup, 
                                                          false);
            }
         }
         else
         {
            delete pRESPBeneficiaryAllocationList;
            pRESPBeneficiaryAllocationList = NULL;
         }
      }
   }
   else 
   {
      if (pRESPBeneficiaryAllocationList != NULL)
      {
         if (!isNew ())
         {
            BFObjIter bfIter (*pRESPBeneficiaryAllocationList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

            bfIter.begin();
            while (!bfIter.end())
            {            
               bfIter.deleteObject ();
            }
         }
         else
         {
            BFObjIter bfIter (*this, idDataGroup);

            if (bfIter.positionByKey (strKey))
            {
               bfIter.removeObjectFromMap (true);
               pRESPBeneficiaryAllocationList = NULL;
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getRESPTransferList (RESPTransferList *&pRESPTransferList, 
                                     const BFDataGroupId &idDataGroup, 
                                     bool bCreate)

{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getRESPTransferList"));

   pRESPTransferList = NULL;

   DString redCode,
      depositType;

   getField (ifds::DepositType, depositType, idDataGroup,false);
   getField (ifds::RedCode, redCode, idDataGroup, false);

   DString strKey (I_("RESPTransferList"));

   pRESPTransferList = dynamic_cast <RESPTransferList*> (getObject (strKey, idDataGroup));

   if (isRESPTransferAllowed (idDataGroup))
   {
//to clear the list
      RESPBeneficiaryAllocationList *pRESPBeneficiaryAllocationList = NULL;

      if ( getRESPBenefAllocationList (pRESPBeneficiaryAllocationList, idDataGroup, false) <= WARNING && 
           pRESPBeneficiaryAllocationList)
      {
         //do nothing;
      }

      SEVERITY severity = NO_CONDITION;
      bool bSetObject = false;

      DString accountNum,
         accountNumTo,
         transId,
         transType,
         tradeDate,
         amount;

      getField (ifds::AccountNum, accountNum, idDataGroup);
      getField (ifds::AccountTo, accountNumTo, idDataGroup);
      getField (ifds::TransId, transId, idDataGroup, false);
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      getField (ifds::Amount, amount, idDataGroup, false);
      if (!pRESPTransferList && bCreate)
      {
         bSetObject = true;

         pRESPTransferList = new RESPTransferList (*this);
         if (isNew() || _bRebook) //for rebook it should behave as a new trade
         {
            severity = pRESPTransferList->initNew ( accountNum,
                                                    accountNumTo,
                                                    transType,
                                                    tradeDate,
                                                    depositType,
                                                    redCode,
                                                    amount,
                                                    idDataGroup);
         }
         else
         {
            severity = pRESPTransferList->init ( accountNum,
                                                 accountNumTo,
                                                 transId,
                                                 transType,
                                                 tradeDate,
                                                 depositType,
                                                 redCode,
                                                 amount);

            DString dstrFromPlanNum, dstrFromContractId, dstrNEQ1;
            DString dstrToPlanNum, dstrToContractId, dstrNEQ2;
            DString dstrInceptionDate, dstrTerminationDate;
            DString dstrRESPTransStat, dstrRESPLetter, dstrAcctLvlOverride;

            pRESPTransferList->getField (ifds::FromPlanNum, dstrFromPlanNum, idDataGroup, false);
            pRESPTransferList->getField (ifds::FromContractId, dstrFromContractId, idDataGroup, false);
            pRESPTransferList->getField (ifds::ToPlanNum, dstrToPlanNum, idDataGroup, false);
            pRESPTransferList->getField (ifds::ToContractId, dstrToContractId, idDataGroup, false);
            pRESPTransferList->getField (ifds::InceptionDate, dstrInceptionDate, idDataGroup, false);
            pRESPTransferList->getField (ifds::TerminationDate, dstrTerminationDate, idDataGroup, false);
            pRESPTransferList->getField (ifds::NEQ1, dstrNEQ1, idDataGroup, false);
            pRESPTransferList->getField (ifds::NEQ2, dstrNEQ2, idDataGroup, false);
            pRESPTransferList->getField (ifds::RESPTransStat, dstrRESPTransStat, idDataGroup, false);
            pRESPTransferList->getField (ifds::RESPLetter, dstrRESPLetter, idDataGroup, false);
            pRESPTransferList->getField (ifds::AcctLvlOverride, dstrAcctLvlOverride, idDataGroup, false);

            setFieldNoValidate (ifds::FromPlanNum, dstrFromPlanNum, idDataGroup, false);
            setFieldNoValidate (ifds::FromContractId, dstrFromContractId, idDataGroup, false);
            setFieldNoValidate (ifds::ToPlanNum, dstrToPlanNum, idDataGroup, false);
            setFieldNoValidate (ifds::ToContractId, dstrToContractId, idDataGroup, false);
            setFieldNoValidate (ifds::NEQ1, dstrNEQ1, idDataGroup, false);
            setFieldNoValidate (ifds::NEQ2, dstrNEQ2, idDataGroup, false);
            setFieldNoValidate (ifds::RESPTransStat, dstrRESPTransStat, idDataGroup, false);
            setFieldNoValidate (ifds::RESPLetter, dstrRESPLetter, idDataGroup, false);
            setFieldNoValidate (ifds::AcctLvlOverride, dstrAcctLvlOverride, idDataGroup, false);
            setFieldNoValidate (ifds::InceptionDate, dstrInceptionDate, idDataGroup, false);
            setFieldNoValidate (ifds::TerminationDate, dstrTerminationDate, idDataGroup, false);
         }
      }

      if (severity <= WARNING && pRESPTransferList)
      {
         if (severity <= WARNING)
         {
            if (bSetObject)
            {
               setObject (pRESPTransferList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
            }
         }
         else
         {
            delete pRESPTransferList;
            pRESPTransferList = NULL;
         }
      }
   }
   else 
   {
      setFieldNoValidate (ifds::RESPLetter, I_("N"), idDataGroup, false);
      setFieldNoValidate (ifds::RESPTransStat, I_("N"), idDataGroup, false);
      if (pRESPTransferList != NULL)
      {
         if (!isNew ())
         {
            BFObjIter bfIter (*pRESPTransferList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

            bfIter.begin();
            while (!bfIter.end())
            {
               bfIter.deleteObject ();
            }
         }
         else
         {
            BFObjIter bfIter (*this, idDataGroup);

            if (bfIter.positionByKey (strKey))
            {
               bfIter.removeObjectFromMap (true);
               pRESPTransferList = NULL;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getMaturityInstrList (MatSweepInstrList *&pMaturityInstrList, 
                                      const BFDataGroupId &idDataGroup, 
                                      bool bCreate)

{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getMaturityInstrList"));

   pMaturityInstrList = NULL;

   DString dstrAccountNum,
      dstrFund,
      dstrClass,
      dstrTransNum,
      dstrTransId,
      dstrIntInvestId,
      dstrInstrType,
      dstrAmount,
      dstrTradesTransType;

   getField (ifds::AccountNum, dstrAccountNum, idDataGroup,false);
   getField (ifds::TradesTransType, dstrTradesTransType, idDataGroup, false);

   if( DSTCommonFunctions::codeInList (dstrTradesTransType, I_("XR,TR")) )
   {
      getField (ifds::ToFund, dstrFund, idDataGroup,false);
      getField (ifds::ToClass, dstrClass, idDataGroup, false);	
   }
   else
   {
      getField (ifds::FromFund, dstrFund, idDataGroup,false);
      getField (ifds::FromClass, dstrClass, idDataGroup, false);
   }

   getField (ifds::TransNum, dstrTransNum, idDataGroup, false);
   getField (ifds::Amount, dstrAmount, idDataGroup, false);
   getField (ifds::TransId, dstrTransId, idDataGroup, false);
   getField (ifds::InvHisInvestId, dstrIntInvestId, idDataGroup, false);

   dstrInstrType = I_("MAT");

   DString strKey = I_("MatSweepInstrList") + dstrAccountNum + dstrFund + dstrClass + dstrTransNum;

   pMaturityInstrList = dynamic_cast <MatSweepInstrList*> (getObject (strKey, idDataGroup));

   if (isMaturityInstrAllowed (idDataGroup))
   {

      SEVERITY severity = NO_CONDITION;
      bool bSetObject = false;

      DString dstrTransId;
      DString dstrEffectiveDate;

      getField (ifds::TransId, dstrTransId, idDataGroup, false);
      getField (ifds::EffectiveDate, dstrEffectiveDate, idDataGroup, false);

      if (!pMaturityInstrList && bCreate)
      {
         bSetObject = true; 
         DString dstrLevel = isNew () ? I_("New") : I_("Pend");

         pMaturityInstrList = new MatSweepInstrList (*this);

         pMaturityInstrList->init (dstrAccountNum, 
                                   dstrInstrType, 
                                   dstrFund, 
                                   dstrClass, 
                                   dstrTransNum, 
                                   dstrTransId, 
                                   dstrIntInvestId, 
                                   dstrLevel, 
                                   dstrAmount, 
                                   I_("0"), 
                                   idDataGroup);
      }

      if (severity <= WARNING && pMaturityInstrList)
      {
         if (severity <= WARNING)
         {
            DString dstrIntInvestType;
            DString dstrIntCalcMthd;
            DString dstrInvestTerm;
            DString dstrIntCredFreq;

            getField (ifds::IntInvestType, dstrIntInvestType, idDataGroup, false);
            getField (ifds::IntCalcMthd, dstrIntCalcMthd, idDataGroup, false);
            getField (ifds::InvestTerm, dstrInvestTerm, idDataGroup, false);
            getField (ifds::IntCredFreq, dstrIntCredFreq, idDataGroup, false);

            pMaturityInstrList->setField (ifds::IntInvestType, dstrIntInvestType, idDataGroup, false);
            pMaturityInstrList->setField (ifds::IntCalcMthd, dstrIntCalcMthd, idDataGroup, false);
            pMaturityInstrList->setField (ifds::InvestTerm, dstrInvestTerm, idDataGroup, false);
            pMaturityInstrList->setField (ifds::IntCredFreq, dstrIntCredFreq, idDataGroup, false);	
            pMaturityInstrList->setField (ifds::Amount, dstrAmount, idDataGroup, false);

            if (bSetObject)
            {
               setObject (pMaturityInstrList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
            }
         }
         else
         {
            delete pMaturityInstrList;
            pMaturityInstrList = NULL;
         }
      }
   }
   else 
   {
      if (pMaturityInstrList != NULL)
      {
         if (!isNew ())
         {
            BFObjIter bfIter (*pMaturityInstrList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

            bfIter.begin();
            while (!bfIter.end())
            {            
               bfIter.deleteObject ();
            }
         }
         else
         {
            BFObjIter bfIter (*this, idDataGroup);

            if (bfIter.positionByKey (strKey))
            {
               bfIter.removeObjectFromMap (true);
               pMaturityInstrList = NULL;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::arePayInstructAllowed (const BFDataGroupId &idDataGroup)
{
   return false; 
}

//******************************************************************************
SEVERITY Trade::refreshTradePayInstructions (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("refreshTradePayInstructions"));

   TradePayInstructList *pTradePayInstructList (NULL);
//forces a refresh
   getTradePayInstructList (pTradePayInstructList, idDataGroup, true);
   setPayInstrOption (idDataGroup);
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getTradePayInstructList ( TradePayInstructList *&pTradePayInstructList, 
                                          const BFDataGroupId &idDataGroup, 
                                          bool bCreate /*=true*/,
                                          bool bDefault /*=false*/)

{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getTradePayInstructList"));

   pTradePayInstructList = NULL;

   SEVERITY severity = NO_CONDITION;
   bool bSetObject = false;
   DString paymentFor,
      strKey (I_("TradePayInstructList_")),
      payToEntity,
      broker,
      branch,
      slsrep,
      payType,
      payInstructExists;

   getField (ifds::PayInstructExists, payInstructExists, idDataGroup);
   getField (ifds::TradesPayType, payType, idDataGroup, false);
   if ( getTradePayToEntity (payToEntity, idDataGroup) <= WARNING &&
        !payToEntity.empty ())
   {
      if (payToEntity == PAY_TO::BROKER)
      {
         getField (ifds::Broker, broker, idDataGroup);
      }
      else if (payToEntity == PAY_TO::BRANCH)
      {
         getField (ifds::Broker, broker, idDataGroup);
         getField (ifds::Branch, branch, idDataGroup);
      }
      else if (payToEntity == PAY_TO::SALESREP)
      {
         getField (ifds::Broker, broker, idDataGroup);
         getField (ifds::Branch, branch, idDataGroup);
         getField (ifds::SlsrepCode, slsrep, idDataGroup);
      }
      strKey += I_("Broker=") + broker +
                I_(";Branch=") + branch +
                I_(";SalesRep=") + slsrep;
   }
   pTradePayInstructList = 
         dynamic_cast <TradePayInstructList *> ( getObject ( strKey, 
                                                             idDataGroup));
   getDefaultPaymentFor (paymentFor, idDataGroup);
   if ( !_bDefaultPayInstructPayTypeIsNotEFTOrSystemCheque &&
        (bDefault || payType == PAYTYPE::EFT || payType == PAYTYPE::SYSTEM_CHEQUE) &&
        !payToEntity.empty () &&
        !paymentFor.empty())
   {
      if (!pTradePayInstructList && bCreate)
      {        
         bSetObject = true;
         pTradePayInstructList = new TradePayInstructList (*this);
         
         if (isNew() || _bRebook || payInstructExists == N)
         {            

            if ( (payToEntity == PAY_TO::BROKER   && !broker.empty()) ||
                 (payToEntity == PAY_TO::BRANCH   && !broker.empty() && !branch.empty()) ||
                 (payToEntity == PAY_TO::SALESREP && !broker.empty() && !branch.empty() && !slsrep.empty()))
            {
               severity = pTradePayInstructList->init ( payToEntity,
                                                        broker, 
                                                        branch,
                                                        slsrep,
                                                        _currentBusinessDate,
                                                        paymentFor,
                                                        idDataGroup);
            }
            else //this is not valid
            {
               assert (0);
            }
         }
         else
         {
            DString transNum;

            getField (ifds::TransNum, transNum, idDataGroup);
            severity = pTradePayInstructList->init (payToEntity, transNum, idDataGroup);
         }

         if (severity <= WARNING && pTradePayInstructList && bSetObject)
         {
            if (severity <= WARNING)
            {
               if (bSetObject)
               {
                  setObject ( pTradePayInstructList, 
                              strKey, 
                              OBJ_ACTIVITY_NONE, 
                              idDataGroup);
                  if (!_bInitPending)
                  {
                     DString currency;

                     getField (ifds::SettleCurrency, currency, idDataGroup);
                     BFObjIter iter ( *pTradePayInstructList, 
                                       idDataGroup, 
                                       false, 
                                       BFObjIter::ITERTYPE::NON_DELETED);
                     int numItems = iter.getNumberOfItemsInList ();
                     bool bSetNullItems = false;

                     iter.begin ();
                     while (!iter.end ()) //set the currency
                     {
         //default pay type based on payment instructions set-up
                        if (numItems == 1) //one item in the list
                        {
            //copy fields to trade
                           DString payType,
                              payMethod,
                              fileProcessor;

                           if (iter.getObject ())
                           {
                              iter.getObject () ->getField (ifds::PayType, payType, idDataGroup);
                              iter.getObject () ->getField (ifds::PayMethod, payMethod, idDataGroup);
                              iter.getObject () ->getField (ifds::ACHProcessor, fileProcessor, idDataGroup);
                              setFieldNoValidate ( ifds::TradesPayType, payType, idDataGroup, 
                                                   false, false, true, !bDefault);
                              setFieldNoValidate ( ifds::PayMethod, payMethod, idDataGroup, 
                                                   false, false, true, !bDefault);
                              setFieldNoValidate ( ifds::ACHProcessor, fileProcessor, idDataGroup, 
                                                   false, false, true, !bDefault);
                           }
                        }
                        else if (numItems > 1 && !bSetNullItems)
                        {
                           bSetNullItems = true;
                           setFieldNoValidate ( ifds::TradesPayType, NULL_STRING, idDataGroup, 
                                                false, false, true, !bDefault);
                           setFieldNoValidate ( ifds::PayMethod, NULL_STRING, idDataGroup, 
                                                false, false, true, !bDefault);
                           setFieldNoValidate ( ifds::ACHProcessor, NULL_STRING, idDataGroup, 
                                                false, false, true, !bDefault);
                        }
                        if (iter.getObject ())
                        {
                           if (!currency.empty())
                           {
                              iter.getObject () ->setField (ifds::Currency, currency, idDataGroup, false);
                           }
                        }
                        ++iter;
                     }
                     if (bDefault && numItems > 0)
                     {
                        _bAlreadySetPayTypeDefaults = true;
                     }
                  }
               }
            }
            else
            {
               delete pTradePayInstructList;
               pTradePayInstructList = NULL;
            }
         }
      }
   }
   else 
   {
//no need to create the records in those cases...
      if (pTradePayInstructList)
      {
         if (!isNew () && payInstructExists == Y)
         {
            BFObjIter bfIter (*pTradePayInstructList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

            bfIter.begin();
            while (!bfIter.end())
            {
               bfIter.deleteObject ();
            }
         }
         else
         {
            BFObjIter bfIter (*this, idDataGroup);

            if (bfIter.positionByKey (strKey))
            {
               bfIter.removeObjectFromMap (true);
               pTradePayInstructList = NULL;
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::canIgnoreEUSDBackDateTrade ( const DString &dstrFund, 
                                         const DString &dstrClass, 
                                         const BFDataGroupId &idDataGroup)
{
   ErrMsgRulesList   *pErrMsgRulesList = NULL;
   DString dstrErrValue;

   if ( getWorkSession().getMgmtCo().getErrMsgRulesList( pErrMsgRulesList ) <= WARNING && 
        pErrMsgRulesList)
   {
      pErrMsgRulesList->getEWIValue (IFASTERR::MONEY_OUT_TXN_SHOULD_BE_CANCELELD_FIRST, idDataGroup, dstrErrValue);
      dstrErrValue.strip().upperCase();
   }
   return dstrErrValue == I_("I") || (dstrFund.empty () && dstrClass.empty ());
}

//******************************************************************************
SEVERITY Trade::validateEUSDBackdates( const DString &dstrFund,
                                       const DString &dstrClass,
                                       const DString &dstrAccountNum,
                                       const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateEUSDBackdates"));

   if (!canIgnoreEUSDBackDateTrade (dstrFund, dstrClass, idDataGroup))
   {
   
      DString dstrEUSDParticip,
              dstrAcctDesignation;

      MFAccount *pMFAccount(NULL);

      if ( getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && 
           pMFAccount)
      {
         pMFAccount->getField (ifds::AcctDesignation, dstrAcctDesignation, idDataGroup, false);
      }

      getWorkSession().getOption (ifds::EUSDParticip, dstrEUSDParticip, idDataGroup, false);
      if ( dstrEUSDParticip == Y && 
           dstrAcctDesignation == CLIENT &&
           isBackdatedTrade (idDataGroup))
      {
         DString dstrTradeDate;
         getField (ifds::EffectiveDate, dstrTradeDate, idDataGroup, false );

         DString dstrKey = I_( "EUSDBackDateValidation" ) + dstrAccountNum  + dstrFund + dstrClass + dstrTradeDate;

         EUSDValidation   *pEUSDValidation = dynamic_cast<EUSDValidation*> (getObject (dstrKey, idDataGroup));

         if (!pEUSDValidation)
         {
            pEUSDValidation = new EUSDValidation (*this);

            if (pEUSDValidation->init (dstrAccountNum, dstrFund, dstrClass, dstrTradeDate) <=WARNING)
            {
               setObject (pEUSDValidation, dstrKey, OBJ_ACTIVITY_NONE, idDataGroup);
            }
            else
            {
               delete pEUSDValidation;
               pEUSDValidation = NULL;
            }
         }
         if (pEUSDValidation && !pEUSDValidation->isBackDatedTradeAllowed (idDataGroup))
         {
            getErrMsg ( IFASTERR::MONEY_OUT_TXN_SHOULD_BE_CANCELELD_FIRST, 
                        CND::ERR_TRADE_BACKDATED_SUBSEQUENT_OUT_EXISTS, 
                        CND::WARN_TRADE_BACKDATED_SUBSEQUENT_OUT_EXISTS, 
                        idDataGroup);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//**********************************************************
SEVERITY Trade::getSegFundValidation ( SeqFundValidation *&pSeqFundValidation,
                                       const DString &fundCode, 
                                       const DString &classCode, 
                                       const DString &accountNum, 
                                       const DString &tradeDate,
                                       const BFDataGroupId &idDataGroup,
                                       const DString &dstrEventTransType,
                                       const DString &dstrTransType,
                                       const DString &toFundCode,
                                       const DString &toClassCode,
                                       const DString &toAccountNum)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getSeqFundValidation"));
   
   pSeqFundValidation = NULL;
   
   if (isSegTrade (idDataGroup))
   {
      DString strKey = 
            I_("SeqFundValidation_AccountNum=") + accountNum +
            I_(";FundCode=")       + fundCode +
            I_(";ClassCode=")      + classCode +
            I_(";TradeDate=")      + tradeDate +
            I_(";EventTransType=") + dstrEventTransType +
            I_(";TransType=")      + dstrTransType +
            I_(";ToFundCode=")     + toFundCode +
            I_(";ToClassCode=")    + toClassCode +
            I_(";AccountTo=")      + toAccountNum;

      pSeqFundValidation = 
         dynamic_cast<SeqFundValidation *> (getObject (strKey, idDataGroup));

      if (!pSeqFundValidation)
      {
         pSeqFundValidation = new SeqFundValidation (*this);

         DString dstrGuaranteesOverride;

         getField( ifds::GuaranteesOverride, dstrGuaranteesOverride, idDataGroup, false );
         dstrGuaranteesOverride.strip().upperCase();
         pSeqFundValidation->setField( ifds::GuaranteesOverride,dstrGuaranteesOverride,BF::HOST,false,false,false);

         if (pSeqFundValidation->init ( fundCode, 
                                       classCode, 
                                       accountNum, 
                                       tradeDate,
                                       dstrEventTransType,
                                       toFundCode,
                                       toClassCode,
                                       toAccountNum,
                                       dstrTransType) <= WARNING)
         {
            setObject ( pSeqFundValidation, 
                        strKey, 
                        OBJ_ACTIVITY_NONE, 
                        idDataGroup);
         }
         else
         {
            delete pSeqFundValidation;
            pSeqFundValidation = NULL;
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isSegEnvironment (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isSegEnvironment"));
   DString strSegClient, 
           strCotClient;

   getWorkSession().getOption (ifds::SegClient, strSegClient, idDataGroup);
   getWorkSession().getOption (ifds::CotClient, strCotClient, idDataGroup);

   return strSegClient.strip() == YES && strCotClient.strip() == YES;
}

//******************************************************************************
bool Trade::isEUSDApplicable (const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
bool Trade::isFundInScope (const BFDataGroupId &idDataGroup)
{
   bool bIsFundInScope = false;

   DString fundCode, 
      classCode;
   BFFieldId fundFieldId (ifds::NullFieldId),
      classFieldId (ifds::NullFieldId);

   getFundAndClassFieldIds (fundFieldId, classFieldId);
   getField (fundFieldId, fundCode, idDataGroup, false);
   getField (classFieldId, classCode, idDataGroup, false);

   FundDetailList *pFundDetailList = NULL;
   if ( getMgmtCo().getFundDetailList (pFundDetailList) <= WARNING &&
        pFundDetailList)
   {
      DString tradeDate;

   getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
   bIsFundInScope = pFundDetailList->isInScope (fundCode, classCode, tradeDate);
   }
   return bIsFundInScope;
}

//******************************************************************************
bool Trade::isFundLookedThru (const BFDataGroupId &idDataGroup)
{
   bool bIsFundLookThru = false;

   DString fundCode, 
      classCode;
   BFFieldId fundFieldId (ifds::NullFieldId),
      classFieldId (ifds::NullFieldId);

   getFundAndClassFieldIds (fundFieldId, classFieldId);
   getField (fundFieldId, fundCode, idDataGroup, false);
   getField (classFieldId, classCode, idDataGroup, false);

   FundDetailList *pFundDetailList = NULL;
   if ( getMgmtCo().getFundDetailList (pFundDetailList) <= WARNING &&
        pFundDetailList)
   {
      DString tradeDate;

   getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
   bIsFundLookThru = pFundDetailList->isLookThru (fundCode, classCode, tradeDate);
   }
   return bIsFundLookThru;
}

//******************************************************************************
SEVERITY Trade::setDefaultSuppressIndicators(   const BFFieldId &idFieldMCHDefault,
                                                const BFFieldId &idFieldSecRecDefault,
                                                const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setDefaultSuppressIndicators"));

   if (isMCHSecRecIndApplicable(idDataGroup) )
   {
      setSuppressIndicatorsSubstitutionSet(idDataGroup);

      setDefaultMCHIndicator (idFieldMCHDefault, idDataGroup);

      setDefaultSecRecIndicator (idFieldSecRecDefault, idDataGroup);

   }
   else 
   {
      setFieldNoValidate ( ifds::MCHFileIndicator, I_("2"), idDataGroup, false, false, true);
      setFieldNoValidate ( ifds::SecRecFileIndicator, I_("2"), idDataGroup, false, false, true);

      setFieldReadOnly (ifds::MCHFileIndicator, idDataGroup, true);
      setFieldReadOnly (ifds::SecRecFileIndicator, idDataGroup, true);

   }

   return GETCURRENTHIGHESTSEVERITY ();

}

//*********************************************************************
void Trade::setSuppressIndicatorsPerm (const BFDataGroupId &idDataGroup)
{
   setFieldReadOnly ( ifds::MCHFileIndicator, idDataGroup, 
                      !getWorkSession().hasUpdatePermission (UAF::MCH_AND_SECUR_REC_FILE_INDICATOR));
   setFieldReadOnly ( ifds::SecRecFileIndicator, idDataGroup, 
                      !getWorkSession().hasUpdatePermission (UAF::MCH_AND_SECUR_REC_FILE_INDICATOR));

}

//******************************************************************************
bool Trade::isMCHSecRecIndApplicable (const BFDataGroupId &idDataGroup)
{
   DString dstrMCHSRActive;

   getWorkSession ().getOption ( ifds::MCHSRActive, 
                                 dstrMCHSRActive, 
                                 BF::HOST, 
                                 false);

   return dstrMCHSRActive == Y; 
}


//******************************************************************************
bool Trade::canFundBeAllocated (const DString& fundCode,
                                const DString& classCode,
                                const BFDataGroupId &idDataGroup)
{
   DString      transType;
   DString      customSchedList;
   FundDetail   *pFundDetail = NULL;

   getField (ifds::TradesTransType, transType, idDataGroup);


   if (getWorkSession().getFundDetail (fundCode, classCode, idDataGroup, pFundDetail) 
      || pFundDetail != NULL)
      pFundDetail->getField (ifds::CustomScheduleList, customSchedList, idDataGroup);

   bool codeInList = DSTCommonFunctions::codeInList (transType, customSchedList);

   return !codeInList;
}

//******************************************************************************
bool Trade::allowESGSettleForNominee (const BFDataGroupId &idDataGroup)
{
   DString dstrAllowed (N);

   MFAccount *pMFAccount = NULL;   
   if (getAccount (pMFAccount, idDataGroup) <= WARNING  && pMFAccount) 
   {
      DString dstrAcctDesignation;
      pMFAccount->getField (ifds::AcctDesignation, dstrAcctDesignation, idDataGroup, false);
      {
         if (dstrAcctDesignation == I_("2"))
         {
            Broker *pBroker = NULL;

            if (getBroker (pBroker, idDataGroup) <= WARNING && pBroker)
            {
               if (isAutoWithdraw (idDataGroup))
               {
                  pBroker->getField ( ifds::SWPSettleESGElig, dstrAllowed, idDataGroup, false);
               }
               else if (isManualDividend (idDataGroup) || isManualMFRAdjustment(idDataGroup))
               {
                  pBroker->getField (ifds::CashIDSettleESGElig, dstrAllowed, idDataGroup, false);
               }
            }
         }
      }
   }
   return dstrAllowed == Y; 
}

//******************************************************************************
bool Trade::allowESGSettleForIntermediary (const BFDataGroupId &idDataGroup)
{
   DString dstrAllowed (N);

   MFAccount *pMFAccount = NULL;   
   if (getAccount ( pMFAccount, idDataGroup) <= WARNING && pMFAccount) 
   {
      DString dstrAcctDesignation;
      pMFAccount->getField (ifds::AcctDesignation, dstrAcctDesignation, idDataGroup, false);
      {
         if (dstrAcctDesignation == I_("3"))
         {
            DString dstrInterCode;
            pMFAccount->getField (ifds::InterCode, dstrInterCode, idDataGroup, false);

            IntermediaryList *pIntermediaryList = NULL;
            if (getMgmtCo ().getIntermediaryList (pIntermediaryList) <= WARNING && pIntermediaryList)
            {
               Intermediary* pIntermediary = NULL;

               if (pIntermediaryList->getIntermediary (idDataGroup, dstrInterCode, pIntermediary) && pIntermediary)
               {
                   if (isAutoWithdraw (idDataGroup))
                  {
                     pIntermediary->getField ( ifds::SWPSettleESGElig, dstrAllowed, idDataGroup, false);
                  }
                  else if (isManualDividend (idDataGroup) || isManualMFRAdjustment(idDataGroup))
                  {
                     pIntermediary->getField ( ifds::CashIDSettleESGElig, dstrAllowed, idDataGroup, false);
                  }
               }
            }
         }
      }
   }
   return dstrAllowed == Y; 
}

//******************************************************************************
inline SEVERITY Trade::validateESGSettle (const DString &strValue, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateESGSettle"));
//logic placed in ATWithdraw/Manual Dividend
   return GETCURRENTHIGHESTSEVERITY();
}

//****************************************************************************** 
SEVERITY Trade::esgSettleRelatedChange (const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("esgSettleRelatedChange"));

// PET 1334 FN1 -- Rules to allow update ESGSettle - only for Canadian markets
   if (DSTCommonFunctions::getMarket() == MARKET_IDS::CANADA)
   {
      DString dstrAcctDesignation,
              dstrSWPSettleESGElig, 
              dstrCashIDSettleESGElig;

      getWorkSession().getOption (ifds::SWPSettleESGElig, dstrSWPSettleESGElig, BF::HOST, false);
      getWorkSession().getOption (ifds::CashIDSettleESGElig, dstrCashIDSettleESGElig, BF::HOST, false);

      if ( (allowESGSettleForNominee (idDataGroup)  || 
            allowESGSettleForIntermediary (idDataGroup)) && 
         ( (isAutoWithdraw (idDataGroup) && dstrSWPSettleESGElig == Y) || 
            ((isManualDividend (idDataGroup) || isManualMFRAdjustment(idDataGroup)) && dstrCashIDSettleESGElig == Y)))
      {
         setFieldReadOnly (ifds::ESGSettle, idDataGroup, false);
      }
      else
      {
         setFieldReadOnly (ifds::ESGSettle, idDataGroup, true);
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}


//******************************************************************************
bool Trade::isCASHSettleESGElig (const BFDataGroupId &idDataGroup)
{
   DString dstrCashIDSettleESGElig;

   getWorkSession().getOption (ifds::CashIDSettleESGElig, dstrCashIDSettleESGElig, BF::HOST, false);

   return  (allowESGSettleForNominee (idDataGroup ) || allowESGSettleForIntermediary (idDataGroup )) &&
       (isManualDividend (idDataGroup) || isManualMFRAdjustment(idDataGroup)) && 
           dstrCashIDSettleESGElig == Y;
}

//*********************************************************************
void Trade::setSuppressIndicatorsSubstitutionSet (const BFDataGroupId &idDataGroup)
{

   if (isMCHSecRecIndApplicable( idDataGroup))
   {
      BFProperties *pBFPropertiesMCHSecRecIndicators = getFieldProperties (ifds::MCHFileIndicator, idDataGroup);

      if (pBFPropertiesMCHSecRecIndicators)
      {

         DString secRecMCHsubst;

         pBFPropertiesMCHSecRecIndicators->getAllSubstituteValues (secRecMCHsubst);

         secRecMCHsubst = removeItemFromSubtList ( secRecMCHsubst, 
                                                   I_("2") );

         setFieldAllSubstituteValues ( ifds::MCHFileIndicator, 
                                       idDataGroup, 
                                       secRecMCHsubst);

         setFieldAllSubstituteValues ( ifds::SecRecFileIndicator, 
                                       idDataGroup, 
                                       secRecMCHsubst);
      }
   }
}

//******************************************************************************
void Trade::setNetworkIDSendRefNum (const BFDataGroupId &idDataGroup, bool bSetNetworkID)
{

   DString accountNum;
   MFAccount *pMFAccount = NULL;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   accountNum.stripLeading ('0').strip();
   if ( getWorkSession().getMFAccount ( idDataGroup, 
                                        accountNum, 
                                        pMFAccount) <= WARNING && pMFAccount)
   {
      //read the NetworkID from account, and set it to trade objcet         
       DString dstrNetworkTypeUpd;
      getWorkSession().getOption ( ifds::NetworkTypeUpd,
                                     dstrNetworkTypeUpd,
                                     BF::HOST,
                                     false );
      dstrNetworkTypeUpd.stripAll().upperCase();
      if (dstrNetworkTypeUpd == Y)
      {
         DString dstrNetworkID;
         pMFAccount->getField (ifds::NetworkID, dstrNetworkID, idDataGroup, false);

         if (!dstrNetworkID.empty())
         {
            if (bSetNetworkID)
            {
               setFieldNoValidate( ifds::NetworkID, dstrNetworkID, idDataGroup, false, 
                                   true, //valid 
                                   true, //notify,
                                   true); //applied related changes
            }
         }

         dstrNetworkID = I_( "" );
         getField( ifds::NetworkID, dstrNetworkID, idDataGroup );

         DString dstrTransNum;
         if ( !dstrNetworkID.strip().empty() )
               getField (ifds::TransNum, dstrTransNum, idDataGroup, false);

         setFieldNoValidate ( ifds::SendRefNum, dstrTransNum, idDataGroup, false, 
                              true, //valid 
                              true, //notify,
                              true); //applied related changes
      }
   }
}

//*********************************************************************
void Trade::setDefaultMCHIndicator( const BFFieldId &idFieldMCHDefault, 
                                    const BFDataGroupId &idDataGroup)
{
   DString mchDefault, fundCode;

   getWorkSession ().getOption ( idFieldMCHDefault, 
                                 mchDefault, 
                                 BF::HOST, 
                                 false);

   getField (ifds::FromFund, fundCode, idDataGroup, false);

   if (!fundCode.empty())
   {
      FundMasterList *pFundMasterList;

      if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && 
           pFundMasterList)
      {
         if (pFundMasterList->is3rdPartyFund (fundCode))
             mchDefault = I_("0");  // should be "exclude" for 3rd party funds 
      }
   }
   setFieldNoValidate ( ifds::MCHFileIndicator, mchDefault, idDataGroup, false, false, true);
}

//*********************************************************************
void Trade::setDefaultSecRecIndicator( const BFFieldId &idFieldSecRecDefault, 
                                       const BFDataGroupId &idDataGroup )
{

   DString secRecDefault;

   getWorkSession ().getOption ( idFieldSecRecDefault, 
                                 secRecDefault, 
                                 BF::HOST, 
                                 false);

   setFieldNoValidate (ifds::SecRecFileIndicator, secRecDefault, idDataGroup, false, false, true);

}

//*********************************************************************
SEVERITY Trade::setDefaultOrderType (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setDefaultOrderType"));
   //this is applicable for trades that are not TR or XR.
   //for TR and XR the method is re-written
   FundDetail  *pFundDetail = NULL;

   DString fundCode,
      classCode;

   getField (ifds::FromFund, fundCode, idDataGroup, false);
   getField (ifds::FromClass, classCode, idDataGroup, false);

   DString dstrOrderType;
   if (!fundCode.empty () && !classCode.empty ())
   {
      if ( getWorkSession().getFundDetail (fundCode, classCode, idDataGroup, pFundDetail) &&
           pFundDetail)
      {
         DString fundOrderType;

         pFundDetail->getField (ifds::DftOrdType, fundOrderType, idDataGroup);
         if (!fundOrderType.empty())
         {
            dstrOrderType = ( fundOrderType == I_("D") )? I_("N") : I_("Y");
         }
      }
   }
   
   if (dstrOrderType.empty())
   {
	   if(_pBatchInfoList != NULL)
	   {
			DString dstrBatchId;
			getField (ifds::BatchName, dstrBatchId, idDataGroup);

			BFObjIter iter ( *_pBatchInfoList, idDataGroup, true);
			iter.begin(OBJ_TYPE_NONE, OBJ_ACTIVITY_NONE, dstrBatchId);
			if(!iter.end())
			{
				iter.getObject()->getField(ifds::BatchOrdType, dstrOrderType, idDataGroup);
			}
	   }

   }
   if (!dstrOrderType.empty())
   {
		setFieldNoValidate ( ifds::OrderType, dstrOrderType , idDataGroup, false, 
                                 true, 
                                 true, //notify
                                 true);


   }
   return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
bool Trade::isWireSupported (const BFDataGroupId &idDataGroup)
{
   return true;
}

//**********************************************************************************************
SEVERITY Trade::setDilutionRespDateInvalid (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setDilutionRespDateInvalid"));

   DilutionAllocList *pDilutionAllocList = NULL;

   if ( getDilutionAllocList ( pDilutionAllocList, 
                               idDataGroup, 
                               true) <= WARNING &&
        pDilutionAllocList)
   {
      BFObjIter iter ( *pDilutionAllocList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      iter.begin();
      while (!iter.end())
      {
         DilutionAlloc *pDilutionAlloc = dynamic_cast <DilutionAlloc *> (iter.getObject());
         if (pDilutionAlloc)
         {
            pDilutionAlloc->setRespDateInvalid( idDataGroup );
         }
         ++iter;
      }
   }

   return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
SEVERITY Trade::setTradeDateToRespDate (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setTradeDateToRespDate"));

   DilutionAllocList *pDilutionAllocList = NULL;

   if ( getDilutionAllocList ( pDilutionAllocList, 
                               idDataGroup, 
                               true) <= WARNING &&
        pDilutionAllocList)
   {
      BFObjIter iter ( *pDilutionAllocList, 
                        idDataGroup, 
                        false, 
                        BFObjIter::ITERTYPE::NON_DELETED);

      iter.begin();
      while (!iter.end())
      {
         DilutionAlloc *pDilutionAlloc = dynamic_cast <DilutionAlloc *> (iter.getObject());

         if (pDilutionAlloc)
         {
            //only set the resp date to the trade date for the first record...
            DString tradeDate;

            getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
            pDilutionAlloc->setTradeDateToRespDate (tradeDate, idDataGroup);
            break;
         }
         ++iter;
      }
   }
   return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
SEVERITY Trade::setSettleLocsInstructionsInvalid( const BFDataGroupId &idDataGroup )
{
	MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("setSettleLocSInstrucitonsInvalid"));

  	TradeSettlementLocationsList *pTradeSettlementLocationsList = NULL;
	
	if (!areMultipleSettleLocAllowed (idDataGroup))
	{
		// environment does not support multiple settlement instructions
		return GETCURRENTHIGHESTSEVERITY ();
	}

	if (getSettlementLocsList (pTradeSettlementLocationsList, idDataGroup, false) <= WARNING 
		&& pTradeSettlementLocationsList != NULL)
	{
		BFObjIter iter (*pTradeSettlementLocationsList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);
	    iter.begin();

	    while (!iter.end())
		{
			TradeSettlementLocations *pTradeSettlementLocations = dynamic_cast <TradeSettlementLocations *> (iter.getObject());
			
			if (pTradeSettlementLocations != NULL)
			{
				pTradeSettlementLocations->setSettleLocAmountInvalid( idDataGroup );
			}

			++iter;
		}
	}
	
	return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
SEVERITY Trade::setBeneficiaryAllocationsInvalid( const BFDataGroupId &idDataGroup )
{
	MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("setBeneficiaryAllocationsInvalid"));

  	RESPBeneficiaryAllocationList *pRESPBeneficiaryAllocationList = NULL;
	
	if (!areRESPBenefAllocationsAllowed (idDataGroup))
	{
		// environment does not support multiple settlement instructions
		return GETCURRENTHIGHESTSEVERITY ();
	}

	if (getRESPBenefAllocationList (pRESPBeneficiaryAllocationList, idDataGroup, false) <= WARNING 
		&& pRESPBeneficiaryAllocationList != NULL)
	{
		BFObjIter iter (*pRESPBeneficiaryAllocationList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);
	    iter.begin();

	    while (!iter.end())
		{
			RESPBeneficiaryAllocation *pRESPBeneficiaryAllocation = dynamic_cast <RESPBeneficiaryAllocation *> (iter.getObject());
			
			if (pRESPBeneficiaryAllocation != NULL)
			{
				pRESPBeneficiaryAllocation->setBeneficiaryAmountInvalid( idDataGroup );
			}

			++iter;
		}
	}
	
	return GETCURRENTHIGHESTSEVERITY (); 
}

//**********************************************************************************************
SEVERITY Trade::validateDefaultSettleInstr(const DString &accountNum, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
      CLASSNAME, 
      I_("validateDefaultSettleInstr"));

   MFAccount *pMFAccount = NULL;

   if ( getWorkSession().getMFAccount ( idDataGroup,accountNum, pMFAccount) <= WARNING &&
      pMFAccount && pMFAccount->isClearingAcount (idDataGroup))
   {

      if ( validateClearingAccount (pMFAccount, idDataGroup) <= WARNING)
      {
         //raise an error if default settlement instructions are expired
         AcctSettlementInstrList *pAcctSettlementInstrList = NULL;
         if ( pMFAccount->getSettlementInstrList(   pAcctSettlementInstrList, 
            idDataGroup, 
            true ) <= WARNING &&
            NULL != pAcctSettlementInstrList )
         {
            BFObjIter acctSettlementInstrListIter( *pAcctSettlementInstrList, 
               idDataGroup, 
               true, 
               BFObjIter::ITERTYPE::NON_DELETED );

            acctSettlementInstrListIter.begin();  

            bool bDisplayError = false;
            DString formattedStopDate;
            while (!acctSettlementInstrListIter.end())
            {
               DString  dstrDefaultSettleInstrCode;
               DString  dstrEffectiveDate;
               DString  dstrStopDate;

               acctSettlementInstrListIter.getObject()->getField( ifds::DefaultSettlementInstr, 
                  dstrDefaultSettleInstrCode, 
                  idDataGroup);


               if (I_( "Y" ) == dstrDefaultSettleInstrCode)
               {
                  DString dstrSettleInstrCode;

                  acctSettlementInstrListIter.getObject()->getField (ifds::SettlementInstrCode, dstrSettleInstrCode, idDataGroup);
                  acctSettlementInstrListIter.getObject()->getField (ifds::EffectiveDate, dstrEffectiveDate, idDataGroup);
                  acctSettlementInstrListIter.getObject()->getField (ifds::StopDate, dstrStopDate, idDataGroup);
                  if (!DSTCommonFunctions::IsDateBetween (dstrEffectiveDate, dstrStopDate, _currentBusinessDate))
                  {
                     acctSettlementInstrListIter.getObject()->getField (ifds::StopDate, formattedStopDate, idDataGroup, true);                                          
                     bDisplayError = true;
                  }
                  else
                  {
                    // found a good one, so don't display any error and break here
                    bDisplayError = false;
                    break;
                  }
               }
               ++acctSettlementInstrListIter;
            }
            if( bDisplayError )
            {
               DString idiStr;
               addIDITagValue (idiStr, I_("asofdate"), formattedStopDate);
               addIDITagValue (idiStr, I_("accountNum"), accountNum);
               //raise error
               ADDCONDITIONFROMFILEIDI (CND::ERR_SETTLEMENT_INSTRUCTIONS_EXPIRED_AS_OF, idiStr);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::refreshSettleDateByCurrencyChanges(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("refreshSettleDateByCurrencyChanges"));

   if ( _multiCurrency != Y ) return GETCURRENTHIGHESTSEVERITY ();

   // in#1283327, ensure that if there is any change in settle currency 
   // date validation should be called

   DString strFromCurrency, strToCurrency, strSettleCurrency;

   getField( ifds::FromCurrency, strFromCurrency, idDataGroup );
   getField( ifds::SettleCurrency, strSettleCurrency, idDataGroup );
   //getField( ifds::ToCurrency, strToCurrency, idDataGroup );

   if ( !strSettleCurrency.empty() )
   {
      //if ( isPurchaseLike( idDataGroup ) )
      if ( isOneSideTrade( idDataGroup ) )
      {
         setField( ifds::FrSettlCurrency, strSettleCurrency, idDataGroup, false);
         setField( ifds::ToSettlCurrency, strFromCurrency, idDataGroup, false);
      }
      else // TR/EX
      {
         DString strFundTo,strClassTo,strFundFrom,strClassFrom;
         DString strFrSettlCurrency,strToSettlCurrency;

         getField (ifds::FromFund, strFundFrom, idDataGroup, false);
         getField (ifds::FromClass, strClassFrom, idDataGroup, false);
         getFundField (strFundFrom, strClassFrom, ifds::Currency, strFrSettlCurrency);

         getField (ifds::ToFund, strFundTo, idDataGroup, false);
         getField (ifds::ToClass, strClassTo, idDataGroup, false);
         getFundField (strFundTo, strClassTo, ifds::Currency, strToSettlCurrency);

         setField( ifds::ToSettlCurrency, strToSettlCurrency, idDataGroup, false);
         setField( ifds::FrSettlCurrency, strFrSettlCurrency, idDataGroup, false);
      }
   }

   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::reCall135ForSettleDateOnly(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("reCall135ForSettleDateOnly"));

   DString strOldSettleDate, strOldTradeDate, strOldDepositDate;
   DString strOldValueDate,  strOldSettleInDate;
   DString strOldTradeInDate;

   getField( ifds::SettleDate,      strOldSettleDate,    idDataGroup );
   getField( ifds::EffectiveDate,   strOldTradeDate,     idDataGroup );
   getField( ifds::DepositDate,     strOldDepositDate,   idDataGroup );
   getField( ifds::ValueDate,       strOldValueDate,     idDataGroup );
   getField( ifds::SettleInDate,    strOldSettleInDate,  idDataGroup );
   getField( ifds::TradeInDate,     strOldTradeInDate,   idDataGroup );

   DateValidation *pTrade_DateValidation = NULL;

   if ( getTradeDateValidation ( pTrade_DateValidation, 
                                 DATE_VALIDATION::SETTLE_DATE, 
                                 strOldTradeDate, // trade date
                                 strOldTradeDate, // settle date
                                 strOldDepositDate, 
                                 strOldValueDate, 
                                 strOldTradeDate, // settle in date
								 strOldTradeInDate,
                                 idDataGroup ) <= WARNING &&
      pTrade_DateValidation)
   {
      DString strSettleDate;
      DString strValueDate;
	  DString strCashDate;

      pTrade_DateValidation->getField( ifds::SettleDate, strSettleDate, idDataGroup, false ); 
      pTrade_DateValidation->getField( ifds::ValueDate, strValueDate, idDataGroup, false ); 
	  pTrade_DateValidation->getField( ifds::CashDate, strCashDate, idDataGroup, false ); 
      
      if ( !strSettleDate.empty() )
      {
         setFieldNoValidate ( ifds::SettleDate, strSettleDate, idDataGroup,  false, 
                              true, 
                              true); //notify
      }
      
      if ( !strValueDate.empty() )
      {
         setFieldNoValidate ( ifds::ValueDate, strValueDate, idDataGroup,  false, 
                              true, 
                              true); //notify
      }
	  CONDITIONVECTOR *pConditionVector = NULL;

	  getFieldConditionVector (ifds::SettleDate, idDataGroup, pConditionVector);
	  //if any condition error codes are returned by view 135, just add them
	  pTrade_DateValidation->addConditions (DATE_VALIDATION::SETTLE_DATE, idDataGroup,ifds::SettleDate,pConditionVector);
	  if (pConditionVector)
	  {
		  setFieldConditionVector (ifds::SettleDate, idDataGroup, pConditionVector);
		  //field should be valid with warnings on it...if any
		  setFieldValid (ifds::SettleDate, idDataGroup, false);         
	  }
    }

   else 
   {
	   // if it is during the time setting up parent fund and class for AMS, no need error.
	   if (_bSetAmsParentFundClass)
	   {
		   int count = CONDITIONCOUNT();
		   for (int i = 0; i < count; i++)
		   {
			   CLEARCONDITION( i );
		   }
		  
	   }
   }
   return GETCURRENTHIGHESTSEVERITY (); 

}

//******************************************************************************

SEVERITY Trade::setRecptIssuedForRebook( const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("setRecptIssuedForRebook"));

   if( isRebook() )
   {
      DString strAmount, strRcptStatus;
      getField( ifds::Amount, strAmount, idDataGroup );
      getField( ifds::RcptStatus, strRcptStatus, idDataGroup );
      if( getWorkSession().hasUpdatePermission( UAF::CTRBT_RCPT_CANCELLATION ) &&
          isRebookForSameAcctTransType() && 
          strRcptStatus.strip().upperCase() != I_("C") &&
          strAmount.strip() == getInitialRebookTradeAmount().strip() )
      {
         DString strFromHistoryTrade;
         getField( ifds::FromHistoryTrade, strFromHistoryTrade, idDataGroup, false );

         if ( strFromHistoryTrade == I_("Y"))
         {
            if( isPurchase(idDataGroup) )
            {
               setFieldReadOnly ( ifds::RecptIssued, idDataGroup, false );
               setFieldNoValidate ( ifds::RecptIssued, I_("N"), idDataGroup, false, true, true, false);
            }
            else
            {
               setFieldReadOnly ( ifds::RecptIssued, idDataGroup, true );
               setFieldNoValidate ( ifds::RecptIssued, I_("N"), idDataGroup, false, true, true, false);
            }
         }
         else
         {
            setFieldReadOnly ( ifds::RecptIssued, idDataGroup, false );
            setFieldNoValidate ( ifds::RecptIssued, I_("N"), idDataGroup, false, true, true, false);
         }
      }
      else
      {
         setFieldReadOnly ( ifds::RecptIssued, idDataGroup, true );
         setFieldNoValidate ( ifds::RecptIssued, I_("N"), idDataGroup, false, true, true, false);
      }
   }

   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************

SEVERITY Trade::setUnitRoundMethodDefaultValue(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("setUnitRoundMethodDefaultValue"));
   /*Blackrock unit rounding project
   //first, check the GC, if applicable
   DString strUnitRoundApplicable, strFundCode, strClassCode, strAmtType, strSystemUnitRoundMethod;
   getWorkSession ().getOption ( ifds::UnitRoundingApplicable, strUnitRoundApplicable, BF::HOST, false);
   getField( ifds::FromFund,  strFundCode,  idDataGroup );
   getField( ifds::FromClass, strClassCode, idDataGroup );
   getField( ifds::AmtType,       strAmtType,   idDataGroup );   
   if( strUnitRoundApplicable.strip().upperCase() == YES && 
	   strAmtType.strip().upperCase() == I_("D") )
   {
	  //first, set the field to be updateable
	  setFieldReadOnly( ifds::UnitRoundMethod, idDataGroup, false);

      //next, check account level rounding type
	   MFAccount *pMFAccount = NULL;
	   if( getAccount( pMFAccount, idDataGroup ) <= WARNING && pMFAccount )
	   {
		   DString strUnitRoundingMethod;
		   pMFAccount->getField( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup );
		   if( !strUnitRoundingMethod.strip().empty() )



		   {
              setFieldNoValidate( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup, false, true, true);//side effect

		   }
		   else
		   {
			   //nothing at account level, try fund/class, if available
               if( !strFundCode.strip().empty() && !strClassCode.strip().empty() )
			   {
				   //check fund/class level
				   FundDetailList *pFundDetailList = NULL;
					if ( getMgmtCo().getFundDetailList (pFundDetailList) <= WARNING && pFundDetailList)
					{
						FundDetail *pFundDetail = NULL;
                       if( pFundDetailList->getFundDetail( strFundCode, strClassCode, idDataGroup, pFundDetail ) && pFundDetail)
					   {
						   pFundDetail->getField(ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup );
                           if( !strUnitRoundingMethod.strip().empty() )
							{
								setFieldNoValidate( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup, false, true, true);//side effect
							}
							else
							{
								//nothing at fund/class level, go for fund level
								FundMasterList *pFundMasterList = NULL; 
								if ( getMgmtCo().getFundMasterList (pFundMasterList) <= WARNING && pFundMasterList )
								{
								   FundMaster *pFundMaster = NULL;
                                   if( pFundMasterList->getFundMaster ( strFundCode, idDataGroup, pFundMaster ) && pFundMaster )
								   {
									   pFundMaster->getField( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup );
                                       if( !strUnitRoundingMethod.strip().empty() )
										{
											setFieldNoValidate( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup, false, true, true);//side effect
										}
										else
										{
											//nothing at fund level; go for fund sponsor
                                            FundSponsorsList* pFundSponsorsList = NULL;
											if ( getMgmtCo ().getFundSponsorsList( pFundSponsorsList ) <= WARNING && pFundSponsorsList )
											{
											   BFAbstractCBO *pFundSponsor = NULL;
											   DString strFundGroup;
											   pFundMaster->getField( ifds::FundGroup, strFundGroup, idDataGroup );											   
                                               if( pFundSponsorsList->getFundSponsor( strFundGroup.strip(), pFundSponsor ) <= WARNING && pFundSponsor )
											   {
												   pFundSponsor->getField( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup );
												   if( !strUnitRoundingMethod.strip().empty() )
													{
														setFieldNoValidate( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup, false, true, true);//side effect
													}
													else
													{
														//nothing at Fund sponsor level; try system level
														getWorkSession ().getOption ( ifds::UnitRoundMethod, strUnitRoundingMethod, BF::HOST, false);
														if( !strUnitRoundingMethod.strip().empty() )
														{
															setFieldNoValidate( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup, false, true, true);//side effect
														}
														else
														{
															//nothing at system level, go for Standard
															setFieldNoValidate( ifds::UnitRoundMethod, STANDARD_MATHEMATICAL, idDataGroup, false, true, true);//side effect
														}
													}
											   }
											}
										}
								   }
								}
							}
					   }
					}                   
			   }
			   else
			   {
				   //fund and/or class not entered - must be allocated trade, go to system level
                   getWorkSession ().getOption ( ifds::UnitRoundMethod, strUnitRoundingMethod, BF::HOST, false);
				   if( !strUnitRoundingMethod.strip().empty() )
					{
						setFieldNoValidate( ifds::UnitRoundMethod, strUnitRoundingMethod, idDataGroup, false, true, true);//side effect
					}
				   else
				   {
					   //nothing at system level, go for Standard
					   setFieldNoValidate( ifds::UnitRoundMethod, STANDARD_MATHEMATICAL, idDataGroup, false, true, true);//side effect
				   }
			   }
		   }
	   }
   }
   else
   {
	   //either GC is off or this is not a 'Cash/Dollar' type trade
      setFieldReadOnly( ifds::UnitRoundMethod, idDataGroup, true);
	  setFieldNoValidate( ifds::UnitRoundMethod, NULL_STRING, idDataGroup, false, true, true);//side effect
   }*/
   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::getFormerSpouseList( DString& strFormerSpouses, 
                                     const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("getFormerSpouseList"));
   strFormerSpouses = I_("0=N/A;");
   return GETCURRENTHIGHESTSEVERITY(); 
}

//******************************************************************************
SEVERITY Trade::populateFormerSpouseList( const DString& strAccountNum, 
                                          DString& strFormerSpouses, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("setUnitRoundMethodDefaultValue"));
   strFormerSpouses = I_("0=N/A;");

   //get the account owners vector
   if (!strAccountNum.empty())
   {
      AccountEntityXref *pAccountEntityXref = NULL;
      if ( getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
              pAccountEntityXref)
      {
         ENTITIES_VECTOR formerSpouses;

         pAccountEntityXref->getFormerSpouses ( formerSpouses, 
                                                strAccountNum, 
                                                idDataGroup);
         for (ENTITIES_VECTOR::size_type i = 0; i < formerSpouses.size(); ++i)
         {
            DString entityId = formerSpouses [i];
            Entity *pEntity = NULL;

            if ( getWorkSession().getEntity ( idDataGroup, 
                                              entityId, 
                                              pEntity) <= WARNING && pEntity)
            {
               DString strFirstName, strLastName;
               strFormerSpouses += entityId;
               strFormerSpouses += I_("=");
               pEntity->getField( ifds::FirstName, strFirstName, idDataGroup, true );
               strFormerSpouses += strFirstName;
               strFormerSpouses += I_(" ");
               pEntity->getField( ifds::LastName, strLastName, idDataGroup, true );
               strFormerSpouses += strLastName;
               strFormerSpouses += I_(";");
            }
         } //for loop of former spouses
      }//account x ref
   }//account num is empty

   return GETCURRENTHIGHESTSEVERITY(); 
}

//******************************************************************************
SEVERITY Trade::getFundUnitPrecision(const DString& dstrFund, const DString& dstrClass, DString& strValue)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("getFundUnitPrecision"));
   getFundField( dstrFund, dstrClass, ifds::UnitsPrecision, strValue);
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::canUserModifyBatch (const DString &batchUser, const BFDataGroupId &idDataGroup)
{
	bool canModify = true;

	DString autoBatching;
	
	getWorkSession ().getOption (ifds::AutoBatch, autoBatching, BF::HOST, false);

	bool bAutoBatching = autoBatching.asInteger () == AUTO_BATCHING ? true : false;

	if (isNew() || !bAutoBatching)
		return canModify;

	bool bModifyBatch = getWorkSession ().hasUpdatePermission (UAF::MODIFY_BATCH_ID);

	DString dstrCurrentUser = dynamic_cast<const DSTCSecurity *> (getWorkSession ().getSecurity(DSTCHost::getPrimaryHost()))->getUserId();        
            
	if (dstrCurrentUser != batchUser)
	{
		canModify = !bModifyBatch;
		setFieldReadOnly (ifds::BatchName, idDataGroup, canModify);		
	}

	return canModify;
}

//******************************************************************************
SEVERITY Trade::validateClosedCountry ( const DString &account,
                                        const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateClosedCountry"));
    
   if (isAccountClosedCountry (account, idDataGroup))
   {
      DString idiStr;
      DString transTypeDescription;

      getField (ifds::TradesTransType, transTypeDescription, idDataGroup, true); //read the description
      addIDITagValue (idiStr, I_("TRADETYPE"), transTypeDescription);    
// Raise the error message
      ADDCONDITIONFROMFILEIDI (CND::ERR_CLOSED_COUNTRY_RESIDENT_FOR_MONEY_IN, idiStr);
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isAccountClosedCountry (const DString &accountNum, 
                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("isAccountClosedCountry"));
   
   bool bIsClosedCountryResident = false;
   // Common method checks account is closed country or not
   MFAccount *pMFAccount = NULL;
   // get MFAccount
   if ( getWorkSession().getMFAccount ( idDataGroup, 
                                        accountNum, 
                                        pMFAccount) <= WARNING && pMFAccount)
   {
      DString dstrIsClosedCountryResident;

      pMFAccount->getField (ifds::IsClosedCountryResident, dstrIsClosedCountryResident, idDataGroup, false);  

      bIsClosedCountryResident = dstrIsClosedCountryResident.strip().upperCase() == YES;
   }
   return bIsClosedCountryResident;
}

//******************************************************************************
SEVERITY Trade::validateClosedCountryForPendingTrades (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateClosedCountryForPendingTrades"));

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateTradePayTypeFundClass( const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateTradePayTypeFundClass"));

   return GETCURRENTHIGHESTSEVERITY ();
}

//**********************************************************************************************
SEVERITY Trade::isFeeApplicable (const DString &dstrFee, bool &bFeeApplicable, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isFeeApplicable"));

   TransFeeList   *pTransFeeList = NULL;
   TransFee       *pTransFee = NULL;

   if ( getTransFeeList (pTransFeeList, idDataGroup, false) <= WARNING && pTransFeeList != NULL)
   {
      pTransFeeList->getTransFee (dstrFee, pTransFee, idDataGroup);
   }

   bFeeApplicable = pTransFee != NULL;

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateNegativeAmount ( const DString &amount,
                                         const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateNegativeAmount"));

   double dec_amount = DSTCommonFunctions::convertToDouble (amount);
   if (dec_amount < 0)
   {
      ADDCONDITIONFROMFILEIDI (CND::ERR_INVALID_NEGATIVE_AMOUNT, DString (I_("FIELDNAME=Amount")));
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateBankVerifyStatus (const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateBankStatus"));

	TradeBankInstructionsList *pTradeBankInstructionsList (NULL);
    
	DString dstrGoodBad;
	bool	bVerificationEnabled;

   getField (ifds::GoodBad, dstrGoodBad, idDataGroup, false); 
	getWorkSession ().isVerificationEnabled (idDataGroup, BANKING_LEVEL, SHAREHOLDER, bVerificationEnabled);   

	if (dstrGoodBad == N) //|| !bVerificationEnabled)
		return GETCURRENTHIGHESTSEVERITY ();

    
	if ( getBankInstructionsList (pTradeBankInstructionsList, idDataGroup) <= WARNING &&
        pTradeBankInstructionsList)
    {
         BFObjIter iter1 (*pTradeBankInstructionsList, idDataGroup);
         bool bCheck = true,
            bRemoved = false;
         
         if (iter1.getNumberOfItemsInList () == 0) //no items - we have to force the creation...
         {
            removeTradeBankInstructionsList (idDataGroup);
   	      pTradeBankInstructionsList = NULL;
            bCheck = getBankInstructionsList (pTradeBankInstructionsList, idDataGroup, true) <= WARNING &&
                     pTradeBankInstructionsList;
            bRemoved = true;
         }
         if (bCheck)
         {
            BFObjIter iter (*pTradeBankInstructionsList, idDataGroup);   
            
            if (!iter.end()) //the bank list has only one item
            {
               if (bRemoved)
               {
                  TradeBankInstructions *pTradeBankInstructions = 
                        dynamic_cast <TradeBankInstructions*> (iter.getObject());

                  pTradeBankInstructions->copyToSpecificCBO (idDataGroup);
               }
               DString dstrVerifyStatus, 
                  acctID;

               iter.getObject() ->getField (ifds::VerifyStat, dstrVerifyStatus, idDataGroup);
               iter.getObject() ->getField (ifds::AcctID, acctID, idDataGroup);

               setFieldNoValidate (ifds::BnkAcctIDLink, acctID, idDataGroup);

               if (dstrVerifyStatus == UNVERIFIED)
               {
                  getErrMsg ( IFASTERR::UNVERIFIED_BANK_TRADE, 
                              CND::ERR_UNVERIFIED_BANK, 
                              CND::WARN_UNVERIFIED_BANK, 
                              idDataGroup);		
               }
            }
         }
    }

	return GETCURRENTHIGHESTSEVERITY ();
}
//******************************************************************************
SEVERITY Trade::getShareholderAddressByAddrCode( const DString &addrCode,
                                                 Address *&pAddress, 
                                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getShareholderAddress"));
   DString accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   accountNum.stripLeading ('0').strip();
   if (!accountNum.empty())
   {
      MFAccount *pMFAccount = NULL;

      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
           pMFAccount)
      {
         DString shrNum;
         DString strAcctDesg;
         Shareholder *pShareholder = NULL;

         pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup, false);
         pMFAccount->getField (ifds::AcctDesignation, 
                               strAcctDesg, idDataGroup);

         if ( getWorkSession().getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING && 
              pShareholder)
         {
            AddressList *pAddressList = NULL;

            if ( pShareholder->getAddressList (pAddressList, idDataGroup, true) <= WARNING && 
                 pAddressList)
            {
               if ( pAddressList )
               {
                  DString strAddrCode(addrCode);
                  strAddrCode.strip().upperCase();
                  //strAddrCode = I_( "1" ) == strAcctDesg ? I_("01") : I_("02");
                  pAddressList->getAddress( pAddress, strAddrCode, 
                                            NULL_STRING, idDataGroup );
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validatePayMethod( const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validatePayMethod"));

   bool bVerificationEnabled = false;
   getWorkSession ().isVerificationEnabled ( idDataGroup, 
                                             SHRHLDR_CATEGORY, 
                                             SHRHLDR_LEVEL, 
                                             bVerificationEnabled);

   if ( bVerificationEnabled && isRedemption(idDataGroup) && isRedemptionLike(idDataGroup) )
   {
      DString strPayType, strPayMethod;

      getField( ifds::TradesPayType, strPayType, idDataGroup, false );
      getField( ifds::PayMethod, strPayMethod, idDataGroup, false );

      strPayType.strip().upperCase();
      strPayMethod.strip().upperCase();

      if( ( (strPayMethod == I_("DDER") ) && (strPayType != PAYTYPE::DIRECT_DEPOSIT) ) || 
	      ( (strPayMethod != I_("DDER") ) && (strPayType == PAYTYPE::DIRECT_DEPOSIT) ) )
      {
         ADDCONDITIONFROMFILE (CND::ERR_INVALID_PAYMENT_METHOD);
      }

      if( strPayType == PAYTYPE::EFT && strPayMethod == I_("CHQ") )
      {
         Address *pAddress = NULL;
         DString strAddrCode;
         getField( ifds::AddrCode, strAddrCode, idDataGroup, false );
         getShareholderAddressByAddrCode( strAddrCode, pAddress, idDataGroup );

         if ( pAddress && GETCURRENTHIGHESTSEVERITY() <= WARNING )
         {
            DString strAddVerifyStat;
            pAddress->getField( ifds::VerifyStat, strAddVerifyStat, idDataGroup, false );
            if ( strAddVerifyStat == UNVERIFIED )
            {
               DString dstrIDI;
               addIDITagValue (dstrIDI, I_("OPERATION"), I_("Redeem"));

               getErrMsg ( IFASTERR::SHAREHOLDER_ADDRESS_NOT_VERIFIED_FOR_TRADE, 
                           CND::ERR_ADDRESS_NOT_VERIFY, 
                           CND::WARN_ADDRESS_NOT_VERIFY, 
                           idDataGroup,
                           dstrIDI);
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validatePayTypeCheque( const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validatePayTypeCheque"));

   bool bVerificationEnabled = false;
   getWorkSession ().isVerificationEnabled ( idDataGroup, 
                                             SHRHLDR_CATEGORY, 
                                             SHRHLDR_LEVEL, 
                                             bVerificationEnabled);

   if ( bVerificationEnabled && isRedemption(idDataGroup) && isRedemptionLike(idDataGroup) )
   {
      Address *pAddress = NULL;
      DString strAddrCode;
      getField( ifds::AddrCode, strAddrCode, idDataGroup, false );
      getShareholderAddressByAddrCode( strAddrCode, pAddress, idDataGroup );

      if ( pAddress && GETCURRENTHIGHESTSEVERITY() <= WARNING )
      {
         DString strAddVerifyStat;
         pAddress->getField( ifds::VerifyStat, strAddVerifyStat, idDataGroup, false );
         if ( strAddVerifyStat == UNVERIFIED )
         {
            DString dstrIDI;
            addIDITagValue (dstrIDI, I_("OPERATION"), I_("Redeem"));

            getErrMsg ( IFASTERR::SHAREHOLDER_ADDRESS_NOT_VERIFIED_FOR_TRADE, 
                        CND::ERR_ADDRESS_NOT_VERIFY, 
                        CND::WARN_ADDRESS_NOT_VERIFY, 
                        idDataGroup,
                        dstrIDI);
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateTUP (const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateTUP"));

	if (!isTUPApplicable (idDataGroup))
		return GETCURRENTHIGHESTSEVERITY();


	TradedUnitPosition *pTradedUnitPosition;

    if (getTradedUnitPosition (pTradedUnitPosition, idDataGroup) <= WARNING &&
		pTradedUnitPosition != NULL)
	{
		
		DString  dstrFundCode,dstrClassCode;
		getField (ifds::FromFund, dstrFundCode, idDataGroup);
		getField (ifds::FromClass, dstrClassCode, idDataGroup);
		
		DString dstrTUPFailed;

		pTradedUnitPosition->getField (ifds::TUPCalcFailed, dstrTUPFailed, idDataGroup, false);

		if (dstrTUPFailed == YES)
		{
            getErrMsg (IFASTERR::TUP_CALCULATION_ERROR,
                       CND::ERR_TUP_CALCULATION_ERROR, 
                       CND::WARN_TUP_CALCULATION_ERROR, 
                       idDataGroup);
		}

		DString dstrFullMoneyOut;

		pTradedUnitPosition->getField (ifds::FullMoneyOutFound, dstrFullMoneyOut, idDataGroup, false);

		if (dstrFullMoneyOut == YES)
		{
			ADDCONDITIONFROMFILE (CND::WARN_TUP_FULLMONEYOUT_PENDING_TRADE_EXISTS);
		}

		
		DString dstrToleranceLevelExceeded;

		pTradedUnitPosition->getField (ifds::ToleranceAmtExceeded, dstrToleranceLevelExceeded, idDataGroup, false);

		if (dstrToleranceLevelExceeded == YES)
		{
			DString idiStr;
 			DString dstrUnits;
			DString dstrPercentageAmount;
			DString dstrToleranceLevelUnits;
			DString dstrTradeUnits;
			DString dstrShares;

			pTradedUnitPosition->getField (ifds::TUPUnits, dstrUnits, idDataGroup);
			pTradedUnitPosition->getField (ifds::TUPToleranceRate, dstrPercentageAmount, idDataGroup);
			pTradedUnitPosition->getField (ifds::TUPToleranceUnits, dstrToleranceLevelUnits, idDataGroup);
			pTradedUnitPosition->getField (ifds::TradeEstimatedUnits, dstrTradeUnits, idDataGroup);
			pTradedUnitPosition->getField (ifds::TUPOversellUnits, dstrShares, idDataGroup);

			addIDITagValue (idiStr, TUP_UNITS, dstrUnits);
			ADDCONDITIONFROMFILEIDI (CND::WARN_TRADED_UNIT_POSITION, idiStr);

			idiStr = I_("");
			addIDITagValue (idiStr, PERCENT, dstrPercentageAmount);
			ADDCONDITIONFROMFILEIDI (CND::WARN_TUP_TOLERANCE_PERCENT, idiStr);

			idiStr = I_("");
			addIDITagValue (idiStr, TOLUNITS, dstrToleranceLevelUnits);
			ADDCONDITIONFROMFILEIDI (CND::WARN_TUP_TOLERANCE_UNITS, idiStr);

			idiStr = I_("");
			addIDITagValue (idiStr, ESTIMATED_UNITS, dstrTradeUnits);
			ADDCONDITIONFROMFILEIDI (CND::WARN_TUP_ESTIMATED_UNITS, idiStr);

			idiStr = I_("");
			addIDITagValue (idiStr, TUP_SHARES1, dstrShares);
			addIDITagValue (idiStr, TUP_SHARES2, dstrShares);
			ADDCONDITIONFROMFILEIDI (CND::WARN_TUP_SHARES, idiStr);
		}

		DString dstrTUPOverSell;

		pTradedUnitPosition->getField (ifds::TUPOversell, dstrTUPOverSell, idDataGroup, false);

		if (dstrTUPOverSell == YES)
		{
			DString idiStr = I_("");
 			DString dstrUnits;
			DString dstrTradeUnits;
			DString dstrShares;
			DString dstrErrNumber;
			DString dstrTransType;

			getField (ifds::TradesTransType, dstrTransType, idDataGroup, false);

			if (DSTCommonFunctions::codeInList (dstrTransType, TUP_REDEMPTIONS))
			{
				dstrErrNumber = IFASTERR::REDEMPTION_TUP_OVERSELL;
			}
			else if (DSTCommonFunctions::codeInList (dstrTransType, TUP_TRANSFERS))
			{
				dstrErrNumber = IFASTERR::TRANSFER_TUP_OVERSELL;
                //for all transfers	if the env level error INSUFFICENT_UNITS_FOR _UC_TRANSFER_TRADES 
		        //do not allow manual trade's even the error configuartion is Warning in for TUP active environment
				addIDITagValue (idiStr, I_("FUNDNAME"),  dstrFundCode);
                addIDITagValue (idiStr, I_("CLASSNAME"), dstrClassCode);
				getErrMsg ( IFASTERR::INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES,
                            CND::ERR_INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES , 
                            CND::WARN_INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES, 
							idDataGroup,
                            idiStr);
			}
			else if (DSTCommonFunctions::codeInList (dstrTransType, TUP_EXCHANGES))
			{
				dstrErrNumber = IFASTERR::EXCHANGE_TUP_OVERSELL;
				//for all UC Trades if the env level error INSUFFICENT_UNITS_FOR _UC_TRANSFER_TRADES 
		        //do not allow manual trade's even the error configuartion is Warning in for TUP active environment
				DString dstrRedCode, dstrDepositType; 		 
				getField (ifds::RedCode, dstrRedCode, idDataGroup, false);
				getField (ifds::DepositType, dstrDepositType, idDataGroup, false);
				if( REDEMPTION_CODE_UC == dstrRedCode && DEPOSIT_CODE_UC == dstrDepositType )  //UC trade
				
				{
				 addIDITagValue (idiStr, I_("FUNDNAME"),  dstrFundCode);
                 addIDITagValue (idiStr, I_("CLASSNAME"), dstrClassCode);
				 getErrMsg ( IFASTERR::INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES,
                            CND::ERR_INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES , 
                            CND::WARN_INSUFFICENT_UNITS_FOR_UC_TRANSFER_TRADES, 
							idDataGroup,
                            idiStr);
				}
			}

			pTradedUnitPosition->getField (ifds::TUPUnits, dstrUnits, idDataGroup);
			pTradedUnitPosition->getField (ifds::TradeEstimatedUnits, dstrTradeUnits, idDataGroup);
			pTradedUnitPosition->getField (ifds::TUPOversellUnits, dstrShares, idDataGroup);

			addIDITagValue (idiStr, TUP_UNITS, dstrUnits);
            getErrMsg (dstrErrNumber,
                       CND::ERR_TRADED_UNIT_POSITION, 
                       CND::WARN_TRADED_UNIT_POSITION, 
                       idDataGroup, idiStr);

		
			idiStr = I_("");
			addIDITagValue (idiStr, ESTIMATED_UNITS, dstrTradeUnits);             
            getErrMsg (dstrErrNumber,
                       CND::ERR_TUP_ESTIMATED_UNITS, 
                       CND::WARN_TUP_ESTIMATED_UNITS, 
                       idDataGroup, idiStr);

			idiStr = I_("");
			addIDITagValue (idiStr, TUP_SHARES1, dstrShares);
			addIDITagValue (idiStr, TUP_SHARES2, dstrShares);

			getErrMsg (dstrErrNumber,
                       CND::ERR_TUP_SHARES, 
                       CND::WARN_TUP_SHARES, 
                       idDataGroup, idiStr);
		}
	}

	return GETCURRENTHIGHESTSEVERITY();
}

//*********************************************************************************
SEVERITY Trade::getTradedUnitPosition (TradedUnitPosition *&pTradedUnitPosition,
                                       const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME,  I_ ("getTradedUnitPosition"));

    pTradedUnitPosition = NULL;

	DString dstrTransNum,
	   dstrAccountNum,
	   dstrFundCode,
	   dstrClassCode,
	   dstrTransType,
	   dstrTradeDate,
	   dstrSettleDate,
	   dstrAmount,
	   dstrAmountType,
	   dstrSettleCurrency,
	   dstrOrderType,
	   dstrTransId,
	   dstrExchRate,
	   dstrAcctTo,
	   dstrRedCode,
	   dstrPriceCode=I_(""),
	   dstrPriceInCode=I_("");
	if (isNew () || isRebook())
		dstrTransNum = I_("");
	else
		getField (ifds::TransNum, dstrTransNum, idDataGroup);

   getField (ifds::AccountNum, dstrAccountNum, idDataGroup);
   getField (ifds::FromFund, dstrFundCode, idDataGroup);
   getField (ifds::FromClass, dstrClassCode, idDataGroup);
   getField (ifds::TradesTransType, dstrTransType, idDataGroup, false);
   getField (ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);
   getField (ifds::SettleDate, dstrSettleDate, idDataGroup, false);
   getField (ifds::Amount, dstrAmount, idDataGroup);
   getField (ifds::AmtType, dstrAmountType, idDataGroup);
   getField (ifds::SettleCurrency, dstrSettleCurrency, idDataGroup, false);
   getField (ifds::OrderType, dstrOrderType, idDataGroup, false);   
   getField (ifds::TransId, dstrTransId, idDataGroup, false);   
   getField (ifds::ExchRate, dstrExchRate, idDataGroup, false);   
   getField (ifds::AccountTo, dstrAcctTo, idDataGroup, false); 
   getField (ifds::RedCode, dstrRedCode, idDataGroup, false); 
   getField (ifds::PricingCode, dstrPriceCode, idDataGroup, false);
   getField (ifds::PriceInCode, dstrPriceInCode, idDataGroup, false);  

	dstrTransType.strip().upperCase();
	dstrTransNum.strip ();
	dstrAccountNum.strip();
	dstrTradeDate.strip();
	dstrFundCode.strip().upperCase();
	dstrClassCode.strip().upperCase();
	dstrAmount.strip();
	dstrAmountType.strip().upperCase();
	dstrSettleDate.strip();
	dstrSettleCurrency.strip();
	dstrOrderType.strip().upperCase();
	dstrTransId.strip ();
	dstrExchRate.strip ();
	dstrAcctTo.stripAll();
	dstrRedCode.stripAll();
	
	DString strKey;

   TradedUnitPosition::buildKey (dstrAccountNum,
                                 dstrFundCode,
                                 dstrClassCode,
                                 dstrAmount,
                                 dstrAmountType,
                                 dstrTransNum,
                                 dstrTransType,
                                 dstrTradeDate,
                                 dstrSettleDate,
                                 dstrSettleCurrency,
                                 dstrOrderType,
                                 dstrTransId,
                                 dstrExchRate,
								 dstrAcctTo,
								 dstrRedCode,
								 dstrPriceCode,
								 dstrPriceInCode,
                                 strKey);

    pTradedUnitPosition = dynamic_cast<TradedUnitPosition *> (BFCBO::getObject (strKey, idDataGroup));

    if (!pTradedUnitPosition)
    {
		pTradedUnitPosition = new TradedUnitPosition (*this);

		if (pTradedUnitPosition->init (dstrAccountNum,
                                     dstrFundCode,
                                     dstrClassCode,
                                     dstrAmount,
                                     dstrAmountType,
                                     dstrTransNum,
                                     dstrTransType,
                                     dstrTradeDate,
                                     dstrSettleDate,
                                     dstrSettleCurrency,
                                     dstrOrderType, 
                                     dstrTransId,
                                     dstrExchRate,
									 dstrAcctTo,
									 dstrRedCode,
									 dstrPriceCode,
									 dstrPriceInCode,
									 idDataGroup) <= WARNING)
		{
            setObject ( pTradedUnitPosition, 
                        strKey, 
                        OBJ_ACTIVITY_NONE, 
                        idDataGroup);
        }
        else
        {
            delete pTradedUnitPosition;
            pTradedUnitPosition = NULL;
		}
    }

	return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isTUPApplicable (const BFDataGroupId &idDataGroup)
{

   bool bTUPActive = false;
   DString dstrTUPActive,
      dstrAmountType,
      dstrTransType;

   getField (ifds::AmtType, dstrAmountType, idDataGroup);
   getField (ifds::TradesTransType, dstrTransType, idDataGroup);
   getWorkSession ().getOption (ifds::TUPActive, dstrTUPActive, idDataGroup, false);

	if (DSTCommonFunctions::codeInList (dstrAmountType, TUP_AMOUNT_TYPES) && 
		 DSTCommonFunctions::codeInList (dstrTransType, TUP_TRANS_TYPES)	&& 
		 dstrTUPActive == YES)
	{
		bTUPActive = true;
	}
	return bTUPActive;
}

//******************************************************************************
bool Trade::isAssociationToOriginalContribAllowed (const BFDataGroupId &idDataGroup)
{
   return false;
}

//******************************************************************************
bool Trade::isRESPTradeAccount (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("isRESPTradeAccount"));
//this will return true if the account from or to (for TRs) are RESP accounts   
   DString taxType (NULL_STRING);   
   MFAccount *pMFAccount (NULL);
   DString accountNum(NULL_STRING);
   
   getAccountNumToPopulateRespBeneficiary (accountNum, idDataGroup);

   if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount ) <= WARNING &&
        pMFAccount)
   {
      pMFAccount->getField( ifds::TaxType, taxType, idDataGroup, false );
      taxType.strip();      
   }

   return DSTCommonFunctions::codeInList (taxType, I_("9,M"));
}

//******************************************************************************
SEVERITY Trade::getRESPBeneficiariesList( DString& strBenefList, 
                                          const DString& strAccountNum, 
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("getRESPBeneficiariesList"));

   strBenefList = I_("0=N/A;");

   //get the account owners vector
   if (!strAccountNum.empty())
   {
      AccountEntityXref *pAccountEntityXref = NULL;
      if ( getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
           pAccountEntityXref)
      {
         
         DString strTradeDate;
         
         getField (ifds::EffectiveDate, strTradeDate, idDataGroup);

         // get benef list format Firstname Lastname
         pAccountEntityXref->getEntityMasterListAsOfDate( strBenefList, 
                                                          RESP_BENEFICIARY_ENTITY_TYPE, 
                                                          idDataGroup, 
                                                          strTradeDate, 
                                                          false, 
                                                          strAccountNum);
      }//account x ref
   }//account num is empty

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateRESPTrade (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateRESPTrade"));

   MFAccount *pMFAccount = NULL;
   DString accountNum;
   getField(ifds::AccountNum, accountNum, idDataGroup, false);

   if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) > WARNING || 
        !pMFAccount )
   {
      return GETCURRENTHIGHESTSEVERITY ();
   }

   DString taxType;
   pMFAccount->getField(ifds::TaxType, taxType, idDataGroup, false);

   if ( !getWorkSession ().isRES2Client() || 
        !DSTCommonFunctions::codeInList (taxType, I_("9,M")))
   {
      return GETCURRENTHIGHESTSEVERITY ();
   }

   DString dstrGoodBad;

   getField (ifds::GoodBad, dstrGoodBad, idDataGroup, false);
   dstrGoodBad.strip().upperCase();

   if (dstrGoodBad == N)
   {
      // no need to call 405 for validation cancelled pending trade 
      return GETCURRENTHIGHESTSEVERITY ();
   }

   DString  transType,
            fundCode,
            classCode,
            depType,
            redCode,
            tradeDate,
            settleDate,
            amountType,
            amount,
            grossOrNet,
            respBenefId,
            fee,
            flatPrcnt (N),
            ocRdmYear,
            respContrDetlTaxYear(0),
            assistedContrAmt(0);

   getField( ifds::AccountNum, accountNum, idDataGroup, false );
   getField( ifds::TradesTransType, transType, idDataGroup, false );
   getField( ifds::FromFund, fundCode, idDataGroup, false );
   getField( ifds::FromClass, classCode, idDataGroup, false );
   getField( ifds::DepositType, depType, idDataGroup, false );
   getField( ifds::RedCode, redCode, idDataGroup, false );
   getField( ifds::EffectiveDate, tradeDate, idDataGroup, false);
   getField( ifds::SettleDate, settleDate, idDataGroup, false);
   getField( ifds::AmtType, amountType, idDataGroup,false);
   getField( ifds::Amount, amount, idDataGroup,false);
   getField( ifds::GrossOrNet, grossOrNet, idDataGroup,false);
   getField( ifds::LinkedEntityId, respBenefId, idDataGroup, false);
   getField( ifds::OCRdmYear, ocRdmYear, idDataGroup, false);
   getField( ifds::RESPContrDetlTaxYear, respContrDetlTaxYear, idDataGroup, false );
   getField( ifds::AssistedContrAmt, assistedContrAmt, idDataGroup, false );

   // get Fee value
   TransFeeList *pTransFeeList = NULL;
   if ( getTransFeeList (pTransFeeList, idDataGroup, false) <= WARNING &&
         pTransFeeList )
   {
      BFObjIter iter ( *pTransFeeList, 
                        idDataGroup, 
                        0, 
                        BFObjIter::ITERTYPE::NON_DELETED );
      
      iter.begin();
      while (!iter.end())
      {
         TransFee *pFee = dynamic_cast <TransFee*> (iter.getObject());
         if (pFee)
         {
            DString feeCode,
                     feeRate = I_("0"),
                     feeType,
                     feeCharge,
                     transType;

            pFee->getField (ifds::TransFeeCode, feeCode, idDataGroup);
            pFee->getField (ifds::FeeRate, feeRate, idDataGroup, false);
            pFee->getField (ifds::FeeType, feeType, idDataGroup, false);
            // get transtype
            //getField(ifds::TradesTransType, transType, idDataGroup, false);

            if ( feeCode == FEES::ACQUISITION ||  //acq fee
                  feeCode == FEES::EXCHANGE ||     //exchange fee, for non split env
                  //feeCode == FEES::XFER_OUT ||     //split comm for trsf/exch, invesco isn't split env
                  feeCode == FEES::REDEMPTION )    //redemption fee
            {
               // maybe we should spilt this condition for each transaction.
               fee = feeRate;
               flatPrcnt = feeType == I_("0") ? Y : N;
            }
         }
         ++iter;
      }
      // call to view 405 
      RESPTradeValidationList *pRESPTradeValidationList = NULL;
      if( getRESPTradeValidation ( pRESPTradeValidationList, 
                                   accountNum, 
                                   transType,
                                   fundCode,
                                   classCode,
                                   depType,
                                   redCode,
                                   tradeDate,
                                   settleDate,
                                   amountType,
                                   amount,
                                   grossOrNet,
                                   respBenefId,
                                   fee,
                                   flatPrcnt, 
                                   ocRdmYear,
                                   respContrDetlTaxYear,
                                   assistedContrAmt,
                                   idDataGroup ) <= WARNING && pRESPTradeValidationList)
      {
         // do iterate through list of result...
         BFObjIter respTradeValidationListIter( *pRESPTradeValidationList, 
                                                idDataGroup, 
                                                true, 
                                                BFObjIter::ITERTYPE::NON_DELETED );

         respTradeValidationListIter.begin();  

         while (!respTradeValidationListIter.end())
         {
            DString  dstrWarnCode,
                     dstrWarnParam1,
                     dstrWarnParam2;

            respTradeValidationListIter.getObject()->getField( ifds::WarnCode, 
               dstrWarnCode, 
               idDataGroup);
            respTradeValidationListIter.getObject()->getField( ifds::WarnParam1, 
               dstrWarnParam1, 
               idDataGroup);
            respTradeValidationListIter.getObject()->getField( ifds::WarnParam2, 
               dstrWarnParam2, 
               idDataGroup);

            dstrWarnCode.strip();
            dstrWarnParam1.strip();
            dstrWarnParam2.strip();
            displayRESPError(dstrWarnCode,dstrWarnParam1,dstrWarnParam2, idDataGroup );

            ++respTradeValidationListIter;
         }
      }
   }
   /*
      PSEEAP Validation, need to move to this because it easy to control the
      condition to display error on message box. In case of user does not invoke PSE 
      screen to enter information, RED X is displayed but error message is not appeared.
      So, it has been moved.
   */
   
   if (isPSEEAPAllowed (idDataGroup) && isTradeOnOrAfterPSEEAPEditDate (idDataGroup))
   {
      DString dstrCourseLen, dstrEduInstPstl;

      getField(ifds::CourseLen, dstrCourseLen, idDataGroup, false);
      getField(ifds::EduInstPstl, dstrEduInstPstl, idDataGroup, false);

      if(dstrCourseLen.empty() || dstrCourseLen == I_("0"))
      {      
         ADDCONDITIONFROMFILE (CND::ERR_ACADEMIC_YEAR_LENGTH_REQUIRED);
      }
      else
      {
         double dec_courselen = DSTCommonFunctions::convertToDouble (dstrCourseLen);

         if  (dec_courselen < 1 || dec_courselen > 52)
         {
            ADDCONDITIONFROMFILE (CND::ERR_COURSE_LEN_BETWEEN_1_AND_52_WEEKS);
         }
      }
      if(dstrEduInstPstl.empty())
      {
         ADDCONDITIONFROMFILE (CND::ERR_EDUCATION_INST_POST_CODE_AND_COUNTRY_NAME_REQUIRED);    
      }

   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::displayRESPError(const DString &dstrWarnCode,
                                 const DString &dstrWarnParam1,
                                 const DString &dstrWarnParam2,
                                 const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("displayRESPError"));

   DString idiStr1 = NULL_STRING,
      benefId;

   getField( ifds::LinkedEntityId, benefId, idDataGroup, false );

   if ( dstrWarnCode == IFASTERR::RESP_PLAN_LIMIT_EXCEEDED )
   {
      //addIDITagValue (idiStr1, BENEF_NAME, m_BenefName);
      addIDITagValue (idiStr1, LIFETIME_LIMIT, dstrWarnParam1);
      addIDITagValue (idiStr1, TO_DATE, dstrWarnParam2);

      getErrMsg (dstrWarnCode,
                 CND::ERR_RESP_PLAN_LIMIT_EXCEEDED, 
                 CND::WARN_RESP_PLAN_LIMIT_EXCEEDED, 
                 idDataGroup,
                 idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::RESP_YEAR_LIMIT_EXCEEDED )
   {
      //addIDITagValue (idiStr1, BENEF_NAME, m_BenefName);
      addIDITagValue (idiStr1, ANNUAL_LIMIT, dstrWarnParam1);
      addIDITagValue (idiStr1, TO_DATE, dstrWarnParam2);

      getErrMsg (dstrWarnCode,
                 CND::ERR_RESP_YEAR_LIMIT_EXCEEDED, 
                 CND::WARN_RESP_YEAR_LIMIT_EXCEEDED, 
                 idDataGroup,
                 idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::RESP_REDEMPTION_EXCEED_CONTRIBUTION )
   {
      if( dstrWarnParam1.empty() || dstrWarnParam2.empty() )
      {
         getErrMsg (dstrWarnCode,
                    CND::ERR_REDEMPTION_EXCEED_REMAINING_CONTRIB, 
                    CND::WARN_REDEMPTION_EXCEED_REMAINING_CONTRIB, 
                    idDataGroup,
                    idiStr1);
      }
      else
      {
         addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
         addIDITagValue (idiStr1, I_("PARAM_2"), dstrWarnParam2);

         getErrMsg (dstrWarnCode,
                    CND::ERR_RESP_REDEMPTION_EXCEED_CONTRIBUTION, 
                    CND::WARN_RESP_REDEMPTION_EXCEED_CONTRIBUTION, 
                    idDataGroup,
                    idiStr1);
      }
   }
   else if( dstrWarnCode == IFASTERR::RESP_REDEMPTION_EXCEED_EARNINGS )
   {
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
      addIDITagValue (idiStr1, I_("PARAM_2"), dstrWarnParam2);

      getErrMsg (dstrWarnCode,
                 CND::ERR_RESP_REDEMPTION_EXCEED_EARNINGS, 
                 CND::WARN_RESP_REDEMPTION_EXCEED_EARNINGS, 
                 idDataGroup,
                 idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::REDEMPTION_EXCEEDS_GRANT_PLUS_EARNINGS)
   {
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
      addIDITagValue (idiStr1, I_("PARAM_2"), dstrWarnParam2);

      getErrMsg (dstrWarnCode,
                 CND::ERR_REDEMPTION_EXCEEDS_GRANT_PLUS_EARNINGS, 
                 CND::WARN_REDEMPTION_EXCEEDS_GRANT_PLUS_EARNINGS, 
                 idDataGroup,
                 idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::CESG_AMOUNT_TO_BE_RETURNED )
   {
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
	  addIDITagValue (idiStr1, I_("PARAM_2"), dstrWarnParam2);
      getErrMsg (dstrWarnCode,
                  CND::ERR_CESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION, 
                  CND::WARN_CESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION, 
                  idDataGroup,
                  idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::YTD_CONTRIBUTION_WILL_BE_NEGATIVE )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_YTD_CONTRIBUTION_WILL_BE_NEGATIVE, 
                 CND::WARN_YTD_CONTRIBUTION_WILL_BE_NEGATIVE, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::EAP_AMOUNT_EXCEEDS_MARKET_VALUE )
   {      
      getErrMsg (dstrWarnCode,
                 CND::ERR_EAP_AMOUNT_EXCEEDS_MARKET_VALUE, 
                 CND::WARN_EAP_AMOUNT_EXCEEDS_MARKET_VALUE, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::NOT_ENOUGH_GRANT_AMT_FOR_RETURN )
   {      
      getErrMsg (dstrWarnCode,
                 CND::ERR_NOT_ENOUGH_GRANT_AMOUNT_FOR_RETURN, 
                 CND::WARN_NOT_ENOUGH_GRANT_AMOUNT_FOR_RETURN, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::INSUFFICIENT_QESI_GRANTS )
   {      
      getErrMsg (dstrWarnCode,
                 CND::ERR_INSUFFICIENT_QESI_GRANTS, 
                 CND::WARN_INSUFFICIENT_QESI_GRANTS, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::LIFETIME_CONTRIB_LIMITS_NOT_SETUP )
   {      
      getErrMsg (dstrWarnCode,
                 CND::ERR_NO_LIFETIME_CONTRIB_LIMIT_SET_UP, 
                 CND::WARN_NO_LIFETIME_CONTRIB_LIMIT_SET_UP, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::QESI_LIFE_TIME_GRANT_LIMIT_EXCEEDED )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_QESI_LIFE_TIME_GRANT_LIMIT_EXCEEDED, 
                 CND::WARN_QESI_LIFE_TIME_GRANT_LIMIT_EXCEEDED, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::REFUND_OF_SPECIAL_TAXES_EXCEED_REDEMPTION )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_REFUND_OF_SPECIAL_TAXES_EXCEED_REDEMPTION, 
                 CND::WARN_REFUND_OF_SPECIAL_TAXES_EXCEED_REDEMPTION, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::BENEFICIARY_NOT_QUEBEC_RESIDENT )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_BENEFICIARY_NOT_QUEBEC_RESIDENT, 
                 CND::WARN_BENEFICIARY_NOT_QUEBEC_RESIDENT, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::BENEFICIARY_IS_OVER_18 )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_BENEFICIARY_IS_OVER_18, 
                 CND::WARN_BENEFICIARY_IS_OVER_18, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::NET_ANNUAL_CONTRIBUTION_IS_ZERO )
   {
      DString dstrRESPContrDetlTaxYear;
      getField(ifds::RESPContrDetlTaxYear, dstrRESPContrDetlTaxYear, idDataGroup, false);
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrRESPContrDetlTaxYear);
      getErrMsg (dstrWarnCode,
                 CND::ERR_NET_ANNUAL_CONTRIBUTION_IS_ZERO, 
                 CND::WARN_NET_ANNUAL_CONTRIBUTION_IS_ZERO, 
                 idDataGroup,
                 idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::QESI_BASIC_LIMIT_EXCEEDED_FOR_YEAR )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_QESI_BASIC_LIMIT_EXCEEDED_FOR_YEAR, 
                 CND::WARN_QESI_BASIC_LIMIT_EXCEEDED_FOR_YEAR, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::QESI_INCREASE_LIMIT_EXCEEDED_FOR_YEAR )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_QESI_INCREASE_LIMIT_EXCEEDED_FOR_YEAR, 
                 CND::WARN_QESI_INCREASE_LIMIT_EXCEEDED_FOR_YEAR, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_BASIC_HAS_EXCEEDED )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_BASIC_HAS_EXCEEDED, 
                 CND::WARN_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_BASIC_HAS_EXCEEDED, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_INCREASE_HAS_EXCEEDED )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_INCREASE_HAS_EXCEEDED, 
                 CND::WARN_REDEMPTION_AMOUNT_FOR_ADJUSTMENT_OF_QESI_INCREASE_HAS_EXCEEDED, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_UNASSISTED_AMOUNT )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_UNASSISTED_AMOUNT, 
                 CND::WARN_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_UNASSISTED_AMOUNT, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_AVAILABLE_ASSISTED_AMOUNT )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_AVAILABLE_ASSISTED_AMOUNT, 
                 CND::WARN_ASSISTED_CONTRIBUTION_AMOUNT_MORE_THAN_AVAILABLE_ASSISTED_AMOUNT, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::BENEFICIARY_NOT_ELIGIBLE_FOR_QESI_INCREASE_NOT_SIBLINGONLY )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_BENEFICIARY_NOT_ELIGIBLE_FOR_QESI_INCREASE_NOT_SIBLINGONLY, 
                 CND::WARN_BENEFICIARY_NOT_ELIGIBLE_FOR_QESI_INCREASE_NOT_SIBLINGONLY, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::QESI_GRANT_REQUEST_NOT_AVAILABLE_FOR_BENEFICIARY )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_QESI_GRANT_REQUEST_NOT_AVAILABLE_FOR_BENEFICIARY, 
                 CND::WARN_QESI_GRANT_REQUEST_NOT_AVAILABLE_FOR_BENEFICIARY, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::QESI_AMOUNT_GREATER_THAN_10_PRCNT_OF_EXISTING_QESI_UNASSISTED_AMOUNT )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_QESI_AMOUNT_GREATER_THAN_10_PRCNT_OF_EXISTING_QESI_UNASSISTED_AMOUNT, 
                 CND::WARN_QESI_AMOUNT_GREATER_THAN_10_PRCNT_OF_EXISTING_QESI_UNASSISTED_AMOUNT, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::QESI_DP_RD_NOT_ALLOWED )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_QESI_DP_RD_NOT_ALLOWED, 
                 CND::WARN_QESI_DP_RD_NOT_ALLOWED, 
                 idDataGroup);
   }
   else if( dstrWarnCode == IFASTERR::SYS_TRIG_AMEND_AND_RECAL_QESI_NOTIONAL_BALANCE )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_SYS_TRIG_AMEND_AND_RECAL_QESI_NOTIONAL_BALANCE, 
                 CND::WARN_SYS_TRIG_AMEND_AND_RECAL_QESI_NOTIONAL_BALANCE, 
                 idDataGroup);
   }
   else if( dstrWarnCode == IFASTERR::REDEMPT_AMT_EXCEEDED_QESI_AMT_RECEIVED )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_REDEMPT_AMT_EXCEEDED_QESI_AMT_RECEIVED, 
                 CND::WARN_REDEMPT_AMT_EXCEEDED_QESI_AMT_RECEIVED, 
                 idDataGroup);
   }
   else if( dstrWarnCode == IFASTERR::EAP_REDEMPT_EXCEEDED_EARNING )
   // If there are DSCs or other fees associated with the EAP trade, and if there is NOT ENOUGH income, 
   // but there is ENOUGH contributions in the account to cover the charges, 
   // a new warning message should be displayed.
   {
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
      addIDITagValue (idiStr1, I_("PARAM_2"), dstrWarnParam2);

      getErrMsg (dstrWarnCode,
                 CND::ERR_EAP_REDEMPT_EXCEEDED_EARNING, 
                 CND::WARN_EAP_REDEMPT_EXCEEDED_EARNING, 
                 idDataGroup,
                 idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::BENEFICIARY_NOT_SASKATCHEWAN_RESIDENT )
   {
      getErrMsg (dstrWarnCode,
                 CND::ERR_BENEFICIARY_NOT_SASKATCHEWAN_RESIDENT, 
                 CND::WARN_BENEFICIARY_NOT_SASKATCHEWAN_RESIDENT, 
                 idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::SAGES_AMOUNT_TO_BE_RETURNED )
   {
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
      getErrMsg (dstrWarnCode,
                  CND::ERR_SAGES_AMOUNT_TO_BE_RETURNED_BECAUSE_REDEMPTION, 
                  CND::WARN_SAGES_AMOUNT_TO_BE_RETURNED_BECAUSE_REDEMPTION, 
                  idDataGroup,
                  idiStr1);
   }
   else if ( dstrWarnCode == IFASTERR::TERMINATION_NOT_ALLOWED_SAGES_BALANCE_GREATER_THAN_ZERO )
   {
      //addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
      getErrMsg (dstrWarnCode,
                  CND::ERR_TERMINATION_NOT_ALLOWED_SAGES_BALANCE_GREATER_THAN_ZERO, 
                  CND::WARN_TERMINATION_NOT_ALLOWED_SAGES_BALANCE_GREATER_THAN_ZERO, 
                  idDataGroup/*,
                  idiStr1*/);
   }
   else if ( dstrWarnCode == IFASTERR::RESP_TRANSACTION_DATE_MUST_BE_GREATER_THAN_PROGRAM_START_DATE )
   {
	   //addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
	   getErrMsg (dstrWarnCode,
					CND::ERR_RESP_TRANSACTION_DATE_MUST_BE_GREATER_THAN_PROGRAM_START_DATE, 
					CND::WARN_RESP_TRANSACTION_DATE_MUST_BE_GREATER_THAN_PROGRAM_START_DATE, 
					idDataGroup/*,
					idiStr1*/);
   }
   else if ( dstrWarnCode == IFASTERR::RESP_RESIDUAL_GRANT_TRANSFER_NOT_ALLOWED )
   {
	   //addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
	   getErrMsg (dstrWarnCode,
					CND::ERR_RESP_RESIDUAL_GRANT_TRANSFER_NOT_ALLOWED, 
					CND::WARN_RESP_RESIDUAL_GRANT_TRANSFER_NOT_ALLOWED, 
					idDataGroup/*,
					idiStr1*/);
   }
   else if(dstrWarnCode ==  IFASTERR::AMOUNT_EXCEEDS_BCTESG_BALANCE) // 1711 
   {
	   getErrMsg(dstrWarnCode,
		   CND::ERR_AMOUNT_EXCEEDS_BCTESG_BALANCE,
		   CND::WARN_AMOUNT_EXCEEDS_BCTESG_BALANCE,
		   idDataGroup);
   }
   else if(dstrWarnCode ==  IFASTERR::BENEFICIARY_NOT_BC_RESIDENT) // 1715 
   {
	   getErrMsg(dstrWarnCode,
		   CND::ERR_BENEFICIARY_NOT_BC_RESIDENT,
		   CND::WARN_BENEFICIARY_NOT_BC_RESIDENT,
		   idDataGroup);
   }
   else if ( dstrWarnCode == IFASTERR::CESG_ADCESG_AMOUNT_TO_BE_RETURNED ) // 1906
   {
      addIDITagValue (idiStr1, I_("PARAM_1"), dstrWarnParam1);
	  addIDITagValue (idiStr1, I_("PARAM_2"), dstrWarnParam2);
      getErrMsg (dstrWarnCode,
                  CND::ERR_CESG_ADCESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION, 
                  CND::WARN_CESG_ADCESG_AMOUNT_BE_RETURNED_BECAUSE_REDEMPTION, 
                  idDataGroup,
                  idiStr1);
   }
   else if (dstrWarnCode == IFASTERR::BENEF_NOT_ELIGIBLE_FOR_CLB) // 718
   {     
      DString dstrEligDateforCLB;
      getWorkSession().getOption( ifds::EligDateforCLB, dstrEligDateforCLB, BF::HOST, true );
      dstrEligDateforCLB.strip();

      addIDITagValue (idiStr1, I_("ELIGDATE"), dstrEligDateforCLB);
	  addIDITagValue (idiStr1, I_("BENNAME"), dstrWarnParam1);
   
      getErrMsg (dstrWarnCode,
                 CND::ERR_BENEF_NOT_ELIGIBLE_FOR_CLB,
                 CND::WARN_BENEF_NOT_ELIGIBLE_FOR_CLB,
                 idDataGroup, idiStr1);   
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getRESPTradeValidation ( RESPTradeValidationList *&pRESPTradeValidationList, 
                                         const DString &accountNum,
                                         const DString &transType,
                                         const DString &fundCode,
                                         const DString &classCode,
                                         const DString &depType,
                                         const DString &redCode,
                                         const DString &tradeDate,
                                         const DString &settleDate,
                                         const DString &amountType,
                                         const DString &amount,
                                         const DString &grossOrNet,
                                         const DString &respBenefId,
                                         const DString &fee,
                                         const DString &flatPrcnt,
                                         const DString &ocRdmYear,
                                         const DString &respContrDetlTaxYear,
                                         const DString &assistedContrAmt,
                                         const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getRESPTradeValidation"));
   DString strKey;

   addIDITagValue( strKey, I_("AccountNum"), accountNum );
   addIDITagValue( strKey, I_("TransType"), transType );
   addIDITagValue( strKey, I_("FundCode"), fundCode );
   addIDITagValue( strKey, I_("ClassCode"), classCode );
   addIDITagValue( strKey, I_("DepositType"), depType );
   addIDITagValue( strKey, I_("RedCode"), redCode );
   addIDITagValue( strKey, I_("EffectiveDate"), tradeDate );
   addIDITagValue( strKey, I_("SettleDate"), settleDate );
   addIDITagValue( strKey, I_("AmtType"), amountType );
   addIDITagValue( strKey, I_("Amount"), amount );
   addIDITagValue( strKey, I_("GrossOrNet"), grossOrNet );
   addIDITagValue( strKey, I_("LinkedEntityId"), respBenefId );
   addIDITagValue( strKey, I_("Fee"), fee );
   addIDITagValue( strKey, I_("FlatPrcnt"), flatPrcnt );
   addIDITagValue( strKey, I_("OCRdmYear"), ocRdmYear );
   addIDITagValue( strKey, I_("RESPContrDetlTaxYear"), respContrDetlTaxYear );
   addIDITagValue( strKey, I_("AssistedContrAmt"), assistedContrAmt );

   pRESPTradeValidationList = 
      dynamic_cast<RESPTradeValidationList*> (getObject (strKey, idDataGroup));

   if (!pRESPTradeValidationList)
   {
      pRESPTradeValidationList = new RESPTradeValidationList (*this);
      if ( pRESPTradeValidationList->init ( accountNum, 
                                            transType,
                                            fundCode,
                                            classCode,
                                            depType,
                                            redCode,
                                            tradeDate,
                                            settleDate,
                                            amountType,
                                            amount,
                                            grossOrNet,
                                            respBenefId,
                                            fee,
                                            flatPrcnt,
                                            ocRdmYear,
                                            respContrDetlTaxYear,
                                            assistedContrAmt,
                                            idDataGroup ) <= WARNING)
      {
         setObject (pRESPTradeValidationList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
      }
      else
      {
         delete pRESPTradeValidationList;
         pRESPTradeValidationList = NULL;
      }
   }

   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::validateSegTrx(const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSegTrx"));

   DString strAccountNum, dstrAcctGuarGuardExists;
   MFAccount *pMFAccount;

   getField(ifds::AccountNum, strAccountNum, idDataGroup, false);

   if( getWorkSession().getMFAccount ( idDataGroup, strAccountNum, pMFAccount) <= WARNING && pMFAccount)
   {
      pMFAccount->getField(ifds::AcctGuarGuardExists, dstrAcctGuarGuardExists, idDataGroup, false);
      dstrAcctGuarGuardExists.strip().upperCase();

      if(dstrAcctGuarGuardExists != YES)
         return GETCURRENTHIGHESTSEVERITY (); 
   }

   DString strFund, strClass, strAccountTo, strFundTo,
           strClassTo, strTransType, strRedCode, strTradeAmount, strDeff,
           strSettleDate, strPUD, strTransNum;

   getField(ifds::FromFund, strFund, idDataGroup, false);
   getField(ifds::FromClass, strClass, idDataGroup, false);
   getField(ifds::AccountTo, strAccountTo, idDataGroup, false);
   getField(ifds::ToFund, strFundTo, idDataGroup, false);

   getField(ifds::ToClass, strClassTo, idDataGroup, false);
   getField(ifds::TradesTransType, strTransType, idDataGroup, false);
   getField(ifds::RedCode, strRedCode, idDataGroup, false);
   getField(ifds::Amount, strTradeAmount, idDataGroup, false);
   getField(ifds::EffectiveDate, strDeff, idDataGroup, false);
 
   getField(ifds::SettleDate, strSettleDate, idDataGroup, false);
   getField(ifds::AmtType, strPUD, idDataGroup, false);
   getField(ifds::TransNum, strTransNum, idDataGroup, false);
   
   if( !hasAllocations(idDataGroup) )
   {
      getSegTrxValidation ( strAccountNum,
                            strFund,
                            strClass,
                            strAccountTo,
                            strFundTo,
                            strClassTo,
                            strTransType,
                            strRedCode,
                            strTradeAmount,
                            strDeff,
                            strSettleDate,
                            strPUD,
                            strTransNum,
                            idDataGroup );
   }
   else
   {
      TradeFundAllocList *pTradeFundAllocList;

      if ( getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING &&
           pTradeFundAllocList
         )
      {
         TradeFundAlloc *pTradeFundAlloc;

         BFObjIter iter ( *pTradeFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);

         while (!iter.end ()) 
         {
            pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());

            pTradeFundAlloc->getField (ifds::FundCode, strFundTo, idDataGroup);
            pTradeFundAlloc->getField (ifds::ClassCode, strClassTo, idDataGroup);
            getSegTrxValidation ( strAccountNum,
                                  strFund,
                                  strClass,
                                  strAccountTo,
                                  strFundTo,
                                  strClassTo,
                                  strTransType,
                                  strRedCode,
                                  strTradeAmount,
                                  strDeff,
                                  strSettleDate,
                                  strPUD,
                                  strTransNum,
                                  idDataGroup );
            ++iter;
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY (); 

}

//******************************************************************************
SEVERITY Trade::getSegTrxValidation ( const DString &strAccountNum,
                                      const DString &strFund,
                                      const DString &strClass,
                                      const DString &strAccountTo,
                                      const DString &strFundTo,
                                      const DString &strClassTo,
                                      const DString &strTransType,
                                      const DString &strRedCode,
                                      const DString &strTradeAmount,
                                      const DString &strDeff,
                                      const DString &strSettleDate,
                                      const DString &strPUD,
                                      const DString &strTransNum,
                                      const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getSegTrxValidation"));
   DString strKey;
   SegTrxValidationList *pSegTrxValidationList = NULL;     

   pSegTrxValidationList = new SegTrxValidationList (*this);
   if ( pSegTrxValidationList->init ( strAccountNum,
                                      strFund,
                                      strClass,
                                      strAccountTo,
                                      strFundTo,
                                      strClassTo,
                                      strTransType,
                                      strRedCode,
                                      strTradeAmount,
                                      strDeff,
                                      strSettleDate,
                                      strPUD,
                                      strTransNum,
                                      idDataGroup ) <= WARNING)
   {
      // do iterate through list of result...
      BFObjIter segTrxValidationListIter( *pSegTrxValidationList, 
                                          idDataGroup, 
                                          true, 
                                          BFObjIter::ITERTYPE::NON_DELETED );

      segTrxValidationListIter.begin();

      while (!segTrxValidationListIter.end())
      {
         DString  dstrWarnCode;

         segTrxValidationListIter.getObject()->getField( ifds::WarnCode, 
                                                         dstrWarnCode, 
                                                         idDataGroup);

         dstrWarnCode.strip();

         if ( dstrWarnCode == IFASTERR::REDEMP_CONTRARY_CLIENT_GUAGUARD_PROTECTION )
         {
            getErrMsg ( dstrWarnCode,
                        CND::ERR_REDEMP_CONTRARY_CLIENT_GUAGUARD_PROTECTION, 
                        CND::WARN_REDEMP_CONTRARY_CLIENT_GUAGUARD_PROTECTION, 
                        idDataGroup );
         }
         if ( dstrWarnCode == IFASTERR::TRANSFER_CONTRARY_CLIENT_GUAGUARD_PROTECTION )
         {
            getErrMsg ( dstrWarnCode,
                        CND::ERR_TRANSFER_CONTRARY_CLIENT_GUAGUARD_PROTECTION, 
                        CND::WARN_TRANSFER_CONTRARY_CLIENT_GUAGUARD_PROTECTION, 
                        idDataGroup );
         }
         if ( dstrWarnCode == IFASTERR::GUAGUARD_NOT_SAME_BETWEEN_TO_TI )
         {
            getErrMsg ( dstrWarnCode,
                        CND::ERR_GUAGUARD_NOT_SAME_BETWEEN_TO_TI, 
                        CND::WARN_GUAGUARD_NOT_SAME_BETWEEN_TO_TI, 
                        idDataGroup );
         }
         ++segTrxValidationListIter;
      }
   }

   delete pSegTrxValidationList;
   pSegTrxValidationList = NULL;

   return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::validateAmtTypeRedCode (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateAmtTypeRedCode"));

   DString amtType,
           redCode;

   getField (ifds::RedCode, redCode, idDataGroup, false);
   getField (ifds::AmtType, amtType, idDataGroup, false);
   
   if (redCode == I_("02") && DSTCommonFunctions::codeInList (amtType, I_("F,T")))
   {
      DString amtTypeDescr,
         redCodeDescr,
         idiStr;

      getField (ifds::RedCode, redCodeDescr, idDataGroup, true);
      getField (ifds::AmtType, amtTypeDescr, idDataGroup, true);
      addIDITagValue (idiStr,I_("REDCODE"), redCodeDescr);
      addIDITagValue (idiStr,I_("AMTYPE"), amtTypeDescr);
      
      ADDCONDITIONFROMFILEIDI (CND::ERR_AMOUNT_TYPE_NOT_VALID_FOR_REDCODE, idiStr);
   }

// validation from PET0165541 QESI Transaction. Section A, 1
   if (isAssociationWithBeneficiaryAllowed (idDataGroup))
   {
      if( DSTCommonFunctions::codeInList (redCode, I_("75,76,78,83,Q1,Q2,Q3,SR,BR,AG,AR,GR,IR")) )
      {              
         if (amtType != I_("D"))
         {
            // raise error...
            // display rejerror 331
            getErrMsg ( IFASTERR::SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED,
                        CND::ERR_SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED,
                        CND::WARN_SETTLING_GRANT_REPAYMENT_BY_UNIT_NOT_ALLOWED,
                        idDataGroup);

         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateAmountRedCode (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateAmountRedCode"));

   DString amount,
         redCode;

   getField (ifds::Amount, amount, idDataGroup, false); 
   getField (ifds::RedCode, redCode, idDataGroup, false);

   double dec_amount = DSTCommonFunctions::convertToDouble (amount);
   
   if (dec_amount < 50000)
   {
      // validation from PET0165541 QESI Transaction. Section A, 18, 19
      DString dstrRedCode;
      getField(ifds::RedCode, dstrRedCode, idDataGroup, false);
      dstrRedCode.strip();

      if ( dstrRedCode == I_("86") )
      {
         ADDCONDITIONFROMFILE( CND::WARN_RESP_TRANSACTION_AMT_EQ_LESS_FIFTHY_THSND );
      }
      else if (DSTCommonFunctions::codeInList (dstrRedCode, I_( "60,62,63,66,67,68,70,71,79,80,B1" )) )
      {
		  bool bIsSAGESClient = getWorkSession().isSAGESClient();

		  if ( !(bIsSAGESClient && isRESPTradeAccount (idDataGroup) && DSTCommonFunctions::codeInList (dstrRedCode, I_("60,68")))) // RESP Redeem Contributions, RESP Redeem Contributions  Close Acct
			  ADDCONDITIONFROMFILE( CND::WARN_RESP_TRANSACTION_MIGHT_TRIGGER_GRANT_REPAYMENT );
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//*********************************************************************************************
SEVERITY Trade::validateLinkedEntity(const DString& strValue, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateLinkedEntity"));

   if ( isAssociationWithBeneficiaryAllowed (idDataGroup) && 
         (strValue.empty() || strValue == I_("0")))
   {
      // display rejerror 239
      getErrMsg ( IFASTERR::NO_RESP_BENEFICIARY_SELECTED,
                  CND::ERR_NO_RESP_BENEFICIARY_SELECTED,
                  CND::WARN_NO_RESP_BENEFICIARY_SELECTED,
                  idDataGroup );
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//**********************************************************************
SEVERITY Trade::initAccountHoldersSubList (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("initAccountHoldersSubList"));

   DString dstrAccountHoldersList;
   DString dstrAccountNum;

   getAccountNumToPopulateRespBeneficiary (dstrAccountNum, idDataGroup);	
   dstrAccountNum.strip();

   if (!dstrAccountNum.empty())
   {
      AccountEntityXref *pAccountEntityXref = NULL;

      if (getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
         pAccountEntityXref)
      {

         DString dstrTradeDate;

         getField (ifds::EffectiveDate, dstrTradeDate, idDataGroup);

         pAccountEntityXref->getEntityMasterListAsOfDate (dstrAccountHoldersList, 
                                                             ACCOUNTHOLDER_ENTITY_TYPE, 
                                                             idDataGroup, 
                                                             dstrTradeDate, 
                                                             false, 
                                                             dstrAccountNum);

         setFieldReadOnly(ifds::LinkedEntityId, idDataGroup, false); 

         if (isNew ())
         {
            setFieldNoValidate (ifds::LinkedEntityId, I_(""), idDataGroup, false, false, true);  
         }

         setFieldAllSubstituteValues (ifds::LinkedEntityId, idDataGroup, dstrAccountHoldersList);

         if (isNew ())
         {
            MFAccount *pMFAccount = NULL;	
            DString dstrPrimaryAcctOwnerId;

            pAccountEntityXref->GetEntityIdForAccountOwnerSequence1 (dstrAccountNum, idDataGroup, dstrPrimaryAcctOwnerId);

            if ( getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING  && pMFAccount) 
            {
               DString dstrAcctType;

               pMFAccount->getField (ifds::AcctType, dstrAcctType, idDataGroup);
               dstrAcctType.strip().upperCase();

               if (dstrAcctType != JOINT_ACCOUNT)
               {
                  setFieldNoValidate (ifds::LinkedEntityId, dstrPrimaryAcctOwnerId, idDataGroup, false, false, true);  
               }
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//**********************************************************************
SEVERITY Trade::initBeneficiarySubList (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("initBeneficiarySubList"));

   DString strBeneList,
           linkEntityId (I_("0")),
           accountNum;

   getAccountNumToPopulateRespBeneficiary (accountNum, idDataGroup);
   setFieldReadOnly(ifds::LinkedEntityId, idDataGroup, false); 

   if ( isAssociationWithBeneficiaryAllowed (idDataGroup) && 
        getRESPBeneficiariesList (strBeneList, accountNum, idDataGroup) <= WARNING)
   {
      setFieldAllSubstituteValues (ifds::LinkedEntityId, idDataGroup, strBeneList);

      // setfield to readonly as well if taxtype is '9'
      DString taxType (NULL_STRING);   
      MFAccount *pMFAccount (NULL);

      // get RESP MFAccount, cover transfer as well 
      // because accountNum come from getAccountNumToPopulateRespBeneficiary.
      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
           pMFAccount )
      {
         pMFAccount->getField( ifds::TaxType, taxType, idDataGroup, false );
         taxType.strip();
// set automatic populating benef is only for taxtype '9', 'M' is set blank.
         if (taxType == I_("9"))
         {
            if (!strBeneList.empty ())
            {
               I_CHAR *temp = const_cast<I_CHAR*> (strBeneList.c_str ());
               int noOfEntities = 0;
               
               do
               {
                  DString entityId,
                     entityName;

                  temp = parseIdiString (temp, entityId, entityName);
                  if (noOfEntities == 1)
                  {
                     linkEntityId = entityId; //to default to the first beneficiary...
                  }
                  noOfEntities++;

               } while (temp && temp != NULL_STRING && *temp);
            }
            setFieldReadOnly(ifds::LinkedEntityId, idDataGroup, true);
         }
      }
   }
   else
   {
      setFieldAllSubstituteValues (ifds::LinkedEntityId, idDataGroup, I_("0=N/A;"));
   }
   if(!_bInitPending)
   {
      setFieldNoValidate (ifds::LinkedEntityId, linkEntityId, idDataGroup, false, false, true);  
      // reset HRDC related code
      setFieldNoValidate(ifds::RESPReportHRDC, NO, idDataGroup, false, false, true);
      setFieldNoValidate (ifds::AssocTransId, I_("0"), idDataGroup, false, false, true);
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//***************************************************************************
SEVERITY Trade::validateRESPTradeResidency(const DString &redcode, 
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateRESPTradeResidency"));

   if (DSTCommonFunctions::codeInList (redcode, I_("61,69,77")))
   {
      DString linkedEntityId;

      getField (ifds::LinkedEntityId, linkedEntityId, idDataGroup, false);
      linkedEntityId.stripLeading ('0');
      Entity *pEntity = NULL;

      if ( !linkedEntityId.empty  () && 
           getWorkSession().getEntity ( idDataGroup, 
                                        linkedEntityId, 
                                        pEntity) <= WARNING && 
            pEntity)
      {
         DString dstrTaxJuris;

         pEntity->getField (ifds::TaxJuris, dstrTaxJuris, idDataGroup, false);
         // get residency field
         DString dstrResidency1, 
            dstrResidency2, 
            dstrResidency3;

         getWorkSession ().getOption ( ifds::Residency1, dstrResidency1, BF::HOST, false);
         getWorkSession ().getOption ( ifds::Residency2, dstrResidency2, BF::HOST, false);
         getWorkSession ().getOption ( ifds::Residency3, dstrResidency3, BF::HOST, false);
         
         if (DSTCommonFunctions::codeInList (redcode, I_("61,69")))
         {
         if ( !DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency1) &&
              !DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency2) &&
              !DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency3))
         {
               // raise rejerror 720.
               getErrMsg ( IFASTERR::REDEMPTION_CODE_IS_INVALID_BENEFICIARY_IS_NON_RESIDENT,
                           CND::ERR_REDEMPTION_CODE_IS_INVALID_BENEFICIARY_IS_NON_RESIDENT,
                           CND::WARN_REDEMPTION_CODE_IS_INVALID_BENEFICIARY_IS_NON_RESIDENT,
                           idDataGroup );
            }
         }
         else if (DSTCommonFunctions::codeInList (redcode, I_("77")))
         {
            if ( DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency1) ||
                 DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency2) ||
                 DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency3) )
            {
               // raise rejerror 723.
               getErrMsg ( IFASTERR::REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES,
                           CND::ERR_REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES,
                           CND::WARN_REDEMPTION_CODE_APPLICABLE_ONLY_FOR_NON_RESIDENT_BENEFICIARIES,
                           idDataGroup );
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}


//***************************************************************************
SEVERITY Trade::validateAIPEntity(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateAIPEntity"));

   if (!isAIPAllowed (idDataGroup))
      return GETCURRENTHIGHESTSEVERITY ();

   DString dstrAIPEntity;

   getField (ifds::LinkedEntityId, dstrAIPEntity, idDataGroup, false);

   dstrAIPEntity.strip ();

   if (dstrAIPEntity.empty ())
      ADDCONDITIONFROMFILE( CND::ERR_ASSOCIATED_ENTITY_NOT_PROVIDED );


   DString dstrAccountNum;

   getAccountNumToPopulateRespBeneficiary (dstrAccountNum, idDataGroup);	
   dstrAccountNum.strip();

   validateAIPEntityTaxJuris (dstrAIPEntity, dstrAccountNum, idDataGroup);

   validateAIPEntityAddress (dstrAIPEntity, dstrAccountNum, idDataGroup);

   return GETCURRENTHIGHESTSEVERITY ();
}

//***************************************************************************
SEVERITY Trade::validateAIPEntityTaxJuris (const DString &dstrAIPEntity, 
                                           const DString &dstrAccountNum,
                                           const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateAIPEntityTaxJuris"));

   DString dstrTaxJuris;

   if (!dstrAccountNum.empty() && !dstrAIPEntity.empty ())
   {
      AccountEntityXref *pAccountEntityXref = NULL;

      if (getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING &&
         pAccountEntityXref)
      {	
         DString dstrSeqNumber;

         pAccountEntityXref->GetEntitySeqNumber (idDataGroup, dstrAccountNum, dstrAIPEntity, dstrSeqNumber);	

         dstrSeqNumber.strip ();

         if (dstrSeqNumber == PRIMARY_ACCT_OWNER_SEQ_NUM)
         {
            // for primary account owner get tax jurisdiction from account level
            MFAccount *pMFAccount = NULL;

            if (getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && pMFAccount)
            {
               DString dstrShrNum;

               pMFAccount->getField (ifds::ShrNum, dstrShrNum, idDataGroup);

               Shareholder *pShareholder = NULL;

               if (getWorkSession ().getShareholder (idDataGroup, dstrShrNum, pShareholder) <= WARNING &&
                  pShareholder) 
               {
                  pShareholder->getField (ifds::TaxJurisCode, dstrTaxJuris, idDataGroup);
               }
            }
         }
         else
         {
            // non-primary shareholder:
            pAccountEntityXref->getEntityTaxJuris (dstrAccountNum, idDataGroup, dstrAIPEntity, dstrTaxJuris);
         }

         dstrTaxJuris.strip ();

         if (dstrTaxJuris.empty ())
         {
            getErrMsg (IFASTERR::TAX_JURIS_NOT_FOUND_FOR_OWNER, 
               CND::ERR_TAX_JURIS_NOT_FOUND_FOR_OWNER, 
               CND::WARN_TAX_JURIS_NOT_FOUND_FOR_OWNER, 
               idDataGroup);
         }
         else
         {
            // check if Canadian resident:

            DString dstrResidency1, dstrResidency2, dstrResidency3;

            getWorkSession().getOption (ifds::Residency1, dstrResidency1, idDataGroup, false);
            getWorkSession().getOption (ifds::Residency2, dstrResidency2, idDataGroup, false);
            getWorkSession().getOption (ifds::Residency3, dstrResidency3, idDataGroup, false);

            if(!( DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency1) ||
                  DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency2) ||
                  DSTCommonFunctions::codeInList (dstrTaxJuris, dstrResidency3) ) ||
                  dstrTaxJuris == UNASSIGNED_TAX_JURIS)
            {
               getErrMsg (IFASTERR::AIP_TO_NONRESIDENT_NOT_ALLOWED, 
                          CND::ERR_AIP_TO_NONRESIDENT_NOT_ALLOWED, 
                          CND::WARN_AIP_TO_NONRESIDENT_NOT_ALLOWED, 
                          idDataGroup); 

            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//***************************************************************************
SEVERITY Trade::validateAIPEntityAddress (const DString &dstrAIPEntity, 
                                          const DString &dstrAccountNum,
                                          const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateAIPEntityAddress"));

   bool bHasAddress = false;

   if (!dstrAccountNum.empty() && !dstrAIPEntity.empty ())
   {
      AccountEntityXref *pAccountEntityXref = NULL;
      DString dstrSeqNumber;

      if (getWorkSession().getAccountEntityXref (idDataGroup, pAccountEntityXref) <= WARNING && pAccountEntityXref)
      {
         pAccountEntityXref->GetEntitySeqNumber (idDataGroup, dstrAccountNum, dstrAIPEntity, dstrSeqNumber);	
      }

      if (dstrSeqNumber == PRIMARY_ACCT_OWNER_SEQ_NUM)
      {
         bHasAddress = true;
      }
      else
      {
         Entity *pEntity = NULL;

         if (getWorkSession().getEntity (idDataGroup, dstrAIPEntity, pEntity) <= WARNING && pEntity)
         {
            AddressEntityList* pAddressList;

            if (pEntity->getAddressEntityList (pAddressList, idDataGroup, true) && pAddressList)
            {
               BFObjIter iterAddressList (*pAddressList, idDataGroup);

               bHasAddress = iterAddressList.getNumberOfItemsInList() > 0 ? true : false;
            }
         }
      }

      if (!bHasAddress)
      {
         getErrMsg (IFASTERR::ENTITY_ADDRESS_IS_MISSING, 
            CND::ERR_ENTITY_ADDRESS_IS_MISSING, 
            CND::WARN_ENTITY_ADDRESS_IS_MISSING, 
            idDataGroup); 
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getAccountNumToPopulateRespBeneficiary (DString &accountNum, 
                                                        const BFDataGroupId &idDataGroup)
{

   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("getAccountNumToPopulateRespBeneficiary"));

   DString dstrAccountNum;

   getField (ifds::AccountNum, dstrAccountNum, idDataGroup, false);
   dstrAccountNum.strip();

   if(!dstrAccountNum.empty())
      accountNum = dstrAccountNum;

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isTradeOnOrAfterPSEEAPEditDate (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("isTradeOnAndAfterPSEWEAPEditDate"));

   DString pseeapEditDate,
      tradeDate;

   getWorkSession ().getOption (ifds::PSE_EAPEditDate, pseeapEditDate, idDataGroup, false);
   getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);

   return DSTCommonFunctions::CompareDates (pseeapEditDate, tradeDate) == DSTCommonFunctions::EQUAL ||
          DSTCommonFunctions::CompareDates (pseeapEditDate, tradeDate) == DSTCommonFunctions::FIRST_EARLIER;
}

//******************************************************************************
SEVERITY Trade::getPSEData (PSEEAPList *&pPSEEAPList, 
                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getPSEData"));

   pPSEEAPList = NULL;
   if (isPSEEAPAllowed (idDataGroup) && !isNew ())
   {
      DString transId,
         strKey;

      getField (ifds::TransId, transId, idDataGroup, false);
      strKey = I_("TransId=") + transId;

      pPSEEAPList = dynamic_cast <PSEEAPList *> (getObject (strKey, idDataGroup));
      
      if (!pPSEEAPList)
      {
         pPSEEAPList = new PSEEAPList (*this);
         
         if (pPSEEAPList->init (transId) <= WARNING)
         {
            setObject (pPSEEAPList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
            DString courseStart,
               courseLen,
               pseProgramLen,
               pseProgramType,
               pseProgramYear,
               eduInstPstl;

            pPSEEAPList->getField (ifds::CourseStart, courseStart, idDataGroup, false);
            pPSEEAPList->getField (ifds::CourseLen, courseLen, idDataGroup, false);
            pPSEEAPList->getField (ifds::PSEProgramLen, pseProgramLen, idDataGroup, false);
            pPSEEAPList->getField (ifds::PSEProgramType, pseProgramType, idDataGroup, false);
            pPSEEAPList->getField (ifds::PSEProgramYear, pseProgramYear, idDataGroup, false);
            pPSEEAPList->getField (ifds::EduInstPstl, eduInstPstl, idDataGroup, false);
            
            setFieldNoValidate  (ifds::CourseStart, courseStart, idDataGroup, false, false, true);
            setFieldNoValidate  (ifds::CourseLen, courseLen, idDataGroup, false, false, true);
            setFieldNoValidate  (ifds::PSEProgramLen, pseProgramLen, idDataGroup, false, false, true);
            setFieldNoValidate  (ifds::PSEProgramType, pseProgramType, idDataGroup, false, false, true);
            setFieldNoValidate  (ifds::PSEProgramYear, pseProgramYear, idDataGroup, false, false, true);
            setFieldNoValidate  (ifds::EduInstPstl, eduInstPstl, idDataGroup, false, false, true);
         }
      }
      else
      {
         delete pPSEEAPList;
         pPSEEAPList = NULL;
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::resetPSE (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("resetPSE"));

   DString courseStart,
      courseLen,
      pseProgramLen,
      pseProgramType,
      pseProgramYear,
      eduInstPstl;

   getFieldBeforeImage (ifds::CourseStart,      courseStart);
   getFieldBeforeImage (ifds::CourseLen,        courseLen);
   getFieldBeforeImage (ifds::PSEProgramLen,    pseProgramLen);
   getFieldBeforeImage (ifds::PSEProgramType,   pseProgramType);
   getFieldBeforeImage (ifds::PSEProgramYear,   pseProgramYear);
   getFieldBeforeImage (ifds::EduInstPstl,      eduInstPstl);
//reset
   setFieldNoValidate  (ifds::CourseStart,      courseStart,      idDataGroup, false, false, true);
   setFieldNoValidate  (ifds::CourseLen,        courseLen,        idDataGroup, false, false, true);
   setFieldNoValidate  (ifds::PSEProgramLen,    pseProgramLen,    idDataGroup, false, false, true);
   setFieldNoValidate  (ifds::PSEProgramType,   pseProgramType,   idDataGroup, false, false, true);
   setFieldNoValidate  (ifds::PSEProgramYear,   pseProgramYear,   idDataGroup, false, false, true);
   setFieldNoValidate  (ifds::EduInstPstl,      eduInstPstl,      idDataGroup, false, false, true);

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getGIFundDefaults ( GIAInvAttribList *&pGIAInvAttribList,
                                    const BFDataGroupId &idDataGroup, bool doSideEffects)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getGIFundDefaults"));
 
   pGIAInvAttribList = NULL;
   if (isGIAAttribAllowed (idDataGroup))
   {
      DString fundCode;
      DString classCode;
      DString effectiveDate;
      DString strKey;
      DString transType;

      getField(ifds::TradesTransType, transType, idDataGroup, false);
      if(transType == TRADETYPE::EXCHANGE ||
         transType == TRADETYPE::INTER_CLASS_SWITCH ||
         transType == TRADETYPE::TRANSFER)
      {
         getField (ifds::ToFund, fundCode, idDataGroup, false);
         getField (ifds::ToClass, classCode, idDataGroup, false);
      }
      else
      {
         getField (ifds::FromFund, fundCode, idDataGroup, false);
         getField (ifds::FromClass, classCode, idDataGroup, false);
      }

      getField (ifds::EffectiveDate, effectiveDate, idDataGroup, false);
      if (!fundCode.empty() && !classCode.empty())
      {
         strKey = I_("GIAInvAttribsList_FundCode=") + fundCode + I_(";")
                + I_("ClassCode=") + classCode + I_(";")
                + I_("TradeDate=") + effectiveDate;

         pGIAInvAttribList = dynamic_cast <GIAInvAttribList*> (getObject (strKey, idDataGroup));

         if (!pGIAInvAttribList)
         {
            pGIAInvAttribList = new GIAInvAttribList (*this);
            
            if (pGIAInvAttribList->init (fundCode, classCode, effectiveDate) <= WARNING)
            {
               setObject (pGIAInvAttribList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
            }
         }
         if (doSideEffects && pGIAInvAttribList)
         {
            DString intCalcMthd (NULL_STRING);
            DString dstrIntCalcMthdSubst (NULL_STRING); 

            BFProperties *pBFPropertiesIntCalcMthd = getFieldProperties (ifds::IntCalcMthd, idDataGroup);
            BFProperties *pBFPropertiesIntCalcMthdOrig = getFieldProperties (ifds::IntCalcMthdList, BF::HOST);
            pBFPropertiesIntCalcMthdOrig->getAllSubstituteValues (dstrIntCalcMthdSubst);

            pGIAInvAttribList->getField (ifds::IntCalcMthd, intCalcMthd, idDataGroup, false);
            if (intCalcMthd == I_("S")) //simple
            {
               DString simpleTermList,
                  simpleCredFreqList;

               assert (pBFPropertiesIntCalcMthd);
               if (pBFPropertiesIntCalcMthd)
               {
                  dstrIntCalcMthdSubst = 
                     removeItemFromSubtList (dstrIntCalcMthdSubst, I_("B"));
                  dstrIntCalcMthdSubst = 
                     removeItemFromSubtList (dstrIntCalcMthdSubst, I_("C"));

                  setFieldAllSubstituteValues (ifds::IntCalcMthd, idDataGroup, dstrIntCalcMthdSubst);
                  pBFPropertiesIntCalcMthd->setSubstituteValues(NULL);

                  if(!_bInitPending)
                  {
                     setFieldNoValidate(ifds::IntCalcMthd, intCalcMthd, idDataGroup, false);
                  }
               }
            }
            else if (intCalcMthd == I_("C")) //compound
            {
               DString compoundTermList,
                  compoundCredFreqList;

               assert (pBFPropertiesIntCalcMthd);
               if (pBFPropertiesIntCalcMthd)
               {
                  dstrIntCalcMthdSubst = 
                     removeItemFromSubtList (dstrIntCalcMthdSubst, I_("B"));
                  dstrIntCalcMthdSubst = 
                     removeItemFromSubtList (dstrIntCalcMthdSubst, I_("S"));

                  setFieldAllSubstituteValues (ifds::IntCalcMthd, idDataGroup, dstrIntCalcMthdSubst);
                  pBFPropertiesIntCalcMthd->setSubstituteValues(NULL);

                  if(!_bInitPending)
                  {
                     setFieldNoValidate(ifds::IntCalcMthd, intCalcMthd, idDataGroup, false);
                  }
               }
            }
            else if (intCalcMthd == I_("B"))
            {
               assert (pBFPropertiesIntCalcMthd);
               if (pBFPropertiesIntCalcMthd)
               {
                  dstrIntCalcMthdSubst = 
                     removeItemFromSubtList (dstrIntCalcMthdSubst, I_("B"));

                  setFieldAllSubstituteValues (ifds::IntCalcMthd, idDataGroup, dstrIntCalcMthdSubst);
                  pBFPropertiesIntCalcMthd->setSubstituteValues(NULL);
               }
            }

            intCalcMthdRelatedChanges(idDataGroup);
            DString nextIntCredDate,
               maturityDate,
               commRedRateList,
               commRedRateListSubSt(NULL_STRING);

            pGIAInvAttribList->getField (ifds::MaturityDate, maturityDate, idDataGroup, false);
            if (!_bInitPending)
            {
               setFieldNoValidate (ifds::GIMaturityDate, maturityDate, idDataGroup, false, false, true);
            }
            setFieldReadOnly (ifds::GIMaturityDate, idDataGroup, true);
            setFieldValid (ifds::GIMaturityDate, idDataGroup, true);
            if (!_bInitPending)
            {
               pGIAInvAttribList->getField (ifds::NextIntCredDate, nextIntCredDate, idDataGroup, false);
               setFieldNoValidate (ifds::NextIntCredDate, nextIntCredDate, idDataGroup, false, false, true);
               setFieldReadOnly (ifds::NextIntCredDate, idDataGroup, true);
               setFieldValid (ifds::NextIntCredDate, idDataGroup, true);
            }

            setCommRedRateSubstitutionSet (idDataGroup);
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::resetGIAAttrib (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("resetGIAAttrib"));
   DString intInvestType,
      intCalcMthd,
      investTerm,
      maturityDate,
      intCredFreq,
      nextIntCredDate,
      commRedRate,
      addlAmt,
      forcedRate, /*intRateType*/
      intRate,
      investStatus,
      isGIFund,
      forcedRateAmt;

   getFieldBeforeImage (ifds::IntInvestType, intInvestType);
   getFieldBeforeImage (ifds::IntCalcMthd, intCalcMthd);
   getFieldBeforeImage (ifds::InvestTerm, investTerm);
   getFieldBeforeImage (ifds::GIMaturityDate, maturityDate);
   getFieldBeforeImage (ifds::IntCredFreq, intCredFreq);
   getFieldBeforeImage (ifds::NextIntCredDate, nextIntCredDate);
   getFieldBeforeImage (ifds::CommRedRate, commRedRate);
   getFieldBeforeImage (ifds::AddlAmt, addlAmt);
   getFieldBeforeImage (ifds::ForcedRate, forcedRate);
   getFieldBeforeImage (ifds::IntRate, intRate);
   getFieldBeforeImage (ifds::ForcedRateAmt, forcedRateAmt);
// getFieldBeforeImage (ifds::InvestStatus, investStatus);

   setFieldNoValidate (ifds::IntInvestType, intInvestType, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::IntCalcMthd, intCalcMthd, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::InvestTerm, investTerm, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::GIMaturityDate, maturityDate, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::IntCredFreq, intCredFreq, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::NextIntCredDate, nextIntCredDate, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::CommRedRate, commRedRate, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::AddlAmt, addlAmt, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::ForcedRate, forcedRate, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::IntRate, intRate, idDataGroup, false, false, true);
   setFieldNoValidate (ifds::ForcedRateAmt, forcedRateAmt, idDataGroup, false, false, true);
// setFieldNoValidate (ifds::InvestStatus, investStatus, idDataGroup, false, false, true);

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::updateNotinalDataWarning (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("updateNotinalDataWarning"));

   if (isRESPTransferAllowed (idDataGroup))
   {
      ADDCONDITIONFROMFILE( CND::WARN_UPDATE_NOTIONAL_DATA );
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validateRESPContrDetlTaxYear(const DString& strValue, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateRESPContrDetlTaxYear"));

   DString depType,
      redCode,
      respContrDetlTaxYear;

   getField (ifds::DepositType, depType, idDataGroup);
   getField (ifds::RedCode, redCode, idDataGroup);
   getField (ifds::RESPContrDetlTaxYear,respContrDetlTaxYear,idDataGroup);

   if (isRESPTradeAccount(idDataGroup) && 
      ( DSTCommonFunctions::codeInList (depType, I_("77,78,79,80,81,94")) ||
      DSTCommonFunctions::codeInList (redCode, I_("78,Q1,Q2,Q3,IR"))))
   {
      int currBusDateYear (0), 
         iTaxYear;
      DString currBusDate(NULL_STRING);

      getWorkSession ().getOption ( ifds::CurrBusDate, 
         currBusDate, 
         BF::HOST, 
         false);
      currBusDateYear = DSTCommonFunctions::getYearFromUnFormattedDate (currBusDate);
      iTaxYear = (int)DSTCommonFunctions::convertToDouble( strValue );
      if (strValue.empty() || strValue == I_("0"))
      {
         ADDCONDITIONFROMFILE (CND::ERR_TAX_YEAR_EMPTY);
      }
      else if (iTaxYear == currBusDateYear)
      {
         if ( !DSTCommonFunctions::codeInList (redCode, I_("78,Q1,Q2,Q3,IR")) )
         {
            DString idiStr;
            addIDITagValue (idiStr, I_("CODE"), I_("Deposit type or red Code"));
            ADDCONDITIONFROMFILEIDI (CND::ERR_DEPTYPE_REDCODE_CAN_NOT_BE_USED_WITH_CURR_YEAR, idiStr);
         }
      }
      else if (iTaxYear > currBusDateYear)
      {
         ADDCONDITIONFROMFILE (CND::ERR_TAX_YEAR_FUTURE_DATED);
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::validatePayInstrOption(const DString& strValue, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validatePayInstrOption"));

   if (strValue == I_("01")) //redirect to pay entity
   {
      TradePayInstructList *pTradePayInstructList (NULL);
      if ( getTradePayInstructList (pTradePayInstructList, idDataGroup, false) <= WARNING &&
            pTradePayInstructList)
      {
         //Incident #829136 -- Check pair is not needed after PET2306 FN02
         //pTradePayInstructList->otherBrokerPaymentForExist (idDataGroup);         
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}
//*******************************************************************************************************
SEVERITY Trade::get10PrcntAcAmt ( DString &dstrAcAmt10Prcnt,
                                  const DString &strAccountNum,
                                  const DString &strRESPContrTaxYear,
                                  const DString &strLinkedEntityId,
                                  const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getRESPTradeConstantInquiry"));

   RESPTradeConstantInquiry *pRESPTradeConstantInquiry = new RESPTradeConstantInquiry (*this);
   if ( pRESPTradeConstantInquiry->init ( strAccountNum,
                                           strRESPContrTaxYear,
                                           strLinkedEntityId,
                                           idDataGroup ) <= WARNING)
   {
      pRESPTradeConstantInquiry->getField(ifds::AcAmt10Prcnt, dstrAcAmt10Prcnt, idDataGroup, false);
      dstrAcAmt10Prcnt.strip();      
   }
 
   delete pRESPTradeConstantInquiry;
   pRESPTradeConstantInquiry = NULL; 

   return GETCURRENTHIGHESTSEVERITY (); 
}
//*******************************************************************************************************
void Trade::setRESP10xAssistedContrAmt( const BFDataGroupId &idDataGroup )
{
   
   if (isRedemption (idDataGroup) || isPurchase (idDataGroup))
   {
      DString transCode(NULL_STRING);
      BFFieldId fieldId = isRedemption(idDataGroup)? ifds::RedCode : ifds::DepositType;
      
      getField(fieldId, transCode, idDataGroup, false);
      
      if ( (isRedemption (idDataGroup) && transCode == I_("Q1")) ||
           (isPurchase (idDataGroup) && transCode == I_("78"))
          )
      {
         DString dstrAmount;
         getField(ifds::Amount, dstrAmount, idDataGroup, false);
         double dAmount = DSTCommonFunctions::convertToDouble(dstrAmount);
         dAmount*=10;
         DString dstr10xAmount = DSTCommonFunctions::doubleToDString (ifds::Amount, dAmount);

         setFieldNoValidate(ifds::AssistedContrAmt, 
                            dstr10xAmount, 
                            idDataGroup, 
                            false,        // format 
                            false,        // valid
                            true);        // side effect
      }
   }
   
}
//*******************************************************************************************************
SEVERITY Trade::setDefaultValueRESPAssistedContrAmt(const DString &dstrRESPContrDetlTaxYear,
                                                    const DString &dstrLinkedEntityId,
                                                    const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setDefaultValueRESPAssistedContrAmt"));
                           
   DString dstrAcAmt10Prcnt = I_("0.00"), dstrAccountNum;

   getField(ifds::AccountNum, dstrAccountNum, idDataGroup, false);
   
   get10PrcntAcAmt( dstrAcAmt10Prcnt, 
                    dstrAccountNum, 
                    dstrRESPContrDetlTaxYear, 
                    dstrLinkedEntityId, 
                    idDataGroup );

   //IN2392349, P0165541FN12- Incorrect amt prepopulated in AC field-Q1 redemption
   //user has modified amount
   DString dstrAmount(NULL_STRING), dstrPreAmount(NULL_STRING);

   getField(ifds::Amount, dstrAmount, idDataGroup, false);
   getField (ifds::Amount, dstrPreAmount, BF::HOST, false);

   double dAmount = DSTCommonFunctions::convertToDouble(dstrAmount);
   double dPreAmount = DSTCommonFunctions::convertToDouble(dstrPreAmount);

   if((dAmount != dPreAmount))
   {
      DString dstr10xAmount = DSTCommonFunctions::doubleToDString (ifds::Amount, (dAmount*10));

      setFieldNoValidate(ifds::AssistedContrAmt, 
                         dstr10xAmount, 
                         idDataGroup, 
                         false,        // format 
                         false,        // valid
                         true);        // side effect

   }
   else //inquiry
   {

      setFieldNoValidate(ifds::AssistedContrAmt, 
                         dstrAcAmt10Prcnt, 
                         idDataGroup, 
                         false,        // format 
                         false,        // valid
                         true);        // side effect
   }
   //End - IN2392349_WO580043                           

   return GETCURRENTHIGHESTSEVERITY (); 
}                                                 

//******************************************************************************
SEVERITY Trade::calculateEstimatedAllocAmount (DString &dstrCaclAmount,
                                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("calculateEstimatedAllocAmount"));

   DString dstrAccountNum;
   DString dstrFundCode; 
   DString dstrClassCode;     
   DString dstrAmtType, dstrAmount;

   getField (ifds::AmtType, dstrAmtType, idDataGroup, false);
   getField (ifds::Amount, dstrAmount, idDataGroup, false);

   if (isPurchaseLike (idDataGroup) ||
      isExchangeLike (idDataGroup) ||
      isTransfer (idDataGroup))
   {
      getField (ifds::AccountNum, dstrAccountNum, idDataGroup, false);
      getField (ifds::FromFund, dstrFundCode, idDataGroup);
      getField (ifds::FromClass, dstrClassCode, idDataGroup);
   }
   else 
   {
      return GETCURRENTHIGHESTSEVERITY();
   }

   double	dAmount = DSTCommonFunctions::convertToDouble (dstrAmount);
   double	dFundNAV = 0.0;

   if (dstrAmtType == I_("D")) //dollar amount
   {
      double dFundBalance = 0;
      dstrCaclAmount = dstrAmount;

      // full exchange/transfer
      DString dstrTmpCalcAmount = dstrAmount;
      if (dstrTmpCalcAmount.strip ('0').empty ())
      {
         dFundBalance = getFundBalance (dstrAccountNum, dstrFundCode, dstrClassCode, idDataGroup);
         dstrCaclAmount = DSTCommonFunctions::doubleToDString(ifds::Amount, dFundBalance);
      }
   }
   else if (dstrAmtType == I_("U")) //units
   {	 
      double dFundNAV = getFundNAV (dstrAccountNum, dstrFundCode, dstrClassCode, idDataGroup);
      //if (getFundNAV (dFundNAV, idDataGroup) <= WARNING)
      //multiply the units stored in the AllocAmount field 
      //with the price per unit
      dstrCaclAmount = DSTCommonFunctions::doubleToDString(ifds::Amount, dAmount * dFundNAV);
   }
   else if (dstrAmtType == I_("P")) //percentage
   {
      double dAvalUnits = 0.0;
      double dFundNAV = getFundNAV (dstrAccountNum, dstrFundCode, dstrClassCode, idDataGroup);

      //find the number of available units and find the NAV, of this fund 
      //then multiple by the number of units and percentage, 
      //and this is the estimated amount
      if (getNumberOfUnits (dAvalUnits, idDataGroup) <= WARNING)
      {
         dstrCaclAmount = DSTCommonFunctions::doubleToDString (ifds::Amount, 
            dAmount / 100 * dAvalUnits * dFundNAV);
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getNumberOfUnits (double &dAvalUnits, const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getNumberOfUnits"));

   MFAccountHoldingList* pHoldingList = NULL;

   dAvalUnits = 0.0;

   DString dstrAccountNum;
   DString dstrFundCode;
   DString dstrClassCode;

   getField (ifds::FromFund, dstrFundCode, idDataGroup);
   getField (ifds::FromClass, dstrClassCode, idDataGroup);
   getField (ifds::AccountNum, dstrAccountNum, idDataGroup);

   dstrAccountNum.stripLeading ('0').strip();

   if (getHoldings (dstrAccountNum, pHoldingList, idDataGroup, dstrFundCode, dstrClassCode) <= WARNING && 
       pHoldingList)
   {
      BFObjIter iter(*pHoldingList, idDataGroup, true, BFObjIter::ITERTYPE::NON_DELETED);
      //walk the list, match the fund and class, 
      //and retrive the number of units
      DString fundCode, classCode;

      getField(ifds::FundCode, fundCode, idDataGroup, false);
      getField(ifds::ClassCode, classCode, idDataGroup, false);

      BFData matchCriteria;

      matchCriteria.setElementValue(ifds::rxFundCode, fundCode, true);
      matchCriteria.setElementValue(ifds::rxClassCode, classCode, true);
      iter.positionOnNextMatch(matchCriteria, idDataGroup);

      if (!iter.end())
      {
         DString units;
         //get the settled and unsettled units
         iter.getObject()->getField(ifds::SettledUnits, units, idDataGroup, false);
         dAvalUnits += DSTCommonFunctions::convertToDouble(units);
         iter.getObject()->getField(ifds::UnsettledUnits, units, idDataGroup, false);
         dAvalUnits += DSTCommonFunctions::convertToDouble(units);
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::getDefaultFundClassPayType (const DString dstrAccountNum, 
                                            DString &payType,
                                            const DString dstrFundCode,
                                            const DString dstrClassCode,
                                            const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("getDefaultFundClassPayType"));
                          
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::readStopAmtTradeFlag ( const DString &transType,
                                       const DString &fundCode,
                                       const DString &classCode,
                                       const DString &accountNum,
                                       bool &bStopAmtTradeFlag, 
                                       bool &bErrorSeverity, 
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("readStopAmtTradeFlag"));
   FundDetail *pFundDetail = NULL;

   if ( getWorkSession().getFundDetail ( fundCode, 
                                         classCode, 
                                         idDataGroup, 
                                         pFundDetail) &&
        pFundDetail)
   {
      FundTransTypeList *pFundTransTypeList = NULL;

      if ( pFundDetail->getFundTransTypeList (pFundTransTypeList) <= WARNING &&
           pFundTransTypeList)
      {
         FundTransType *pFundTransType = NULL;

         if ( pFundTransTypeList->getFundTransType ( transType, 
                                                     pFundTransType, 
                                                     idDataGroup) <= WARNING &&
              pFundTransType)
         {
            DString stopAmtTradeFlag,
               stopSeverityCode;

            if ( pFundTransType->getStopAmtTradeFlag ( getWorkSession(),
                                               accountNum, 
                                               stopAmtTradeFlag, 
                                               stopSeverityCode, 
                                               idDataGroup) <= WARNING)
            {
               bStopAmtTradeFlag = stopAmtTradeFlag == Y && 
                           ( stopSeverityCode == I_("E") ||
                             stopSeverityCode == I_("W"));
               bErrorSeverity = stopSeverityCode == I_("E");
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::ValidateFundAmtType( const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("ValidateFundCodeAmtType"));

   DString transType, fundCode, classCode,accountNum ;

   getField (ifds::TradesTransType, transType, idDataGroup, false);
   getField (ifds::FromFund, fundCode, idDataGroup, false);
   getField (ifds::FromClass, classCode, idDataGroup, false);
   getField (ifds::AccountNum, accountNum, idDataGroup, false);

   bool bStopAmtTradeFlag (false);
   bool bErrorSeverity (true);

   readStopAmtTradeFlag ( transType, 
                          fundCode, 
                          classCode, 
                          accountNum, 
                          bStopAmtTradeFlag, 
                          bErrorSeverity, 
                          idDataGroup);

   if (bStopAmtTradeFlag) //raise error/warning if stop flag is on, and
   {
      DString idiStr;

      addIDITagValue (idiStr, I_("FUND"), fundCode);
      addIDITagValue (idiStr, I_("CLASS"), classCode);
      if (bErrorSeverity)
      {
         ADDCONDITIONFROMFILEIDI (CND::ERR_FUND_CLASS_AMOUNT_TRADE_STOP_FLAG_ON, idiStr);
      }
      else 
      {
         ADDCONDITIONFROMFILEIDI (CND::WARN_FUND_CLASS_AMOUNT_TRADE_STOP_FLAG_ON, idiStr);
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isNetworkRespReqApplicable()
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("isNetworkRespReqApplicable"));
   DString netRespReqApp;
   getWorkSession().getOption ( ifds::NetworkRespReqApplicable,
                                netRespReqApp,
                                BF::HOST,
                                false);

   return ( netRespReqApp == I_("Y"));
}

//******************************************************************************
SEVERITY Trade::setRespRequiredSubstList (const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "setRespRequiredSubstList" ));
   
   BFProperties *pBFPropertiesNetworkRespRequired = getFieldProperties (ifds::NetworkRespRequired, idDataGroup);
   assert (pBFPropertiesNetworkRespRequired);
   if (pBFPropertiesNetworkRespRequired)
   {
      DString NetworkRespReqSubst;
      pBFPropertiesNetworkRespRequired->getAllSubstituteValues (NetworkRespReqSubst);
      NetworkRespReqSubst = removeItemFromSubtList ( NetworkRespReqSubst, 
                                                   I_("2") );
      NetworkRespReqSubst = removeItemFromSubtList ( NetworkRespReqSubst, 
                                                   I_("3") );
      setFieldAllSubstituteValues (ifds::NetworkRespRequired, idDataGroup, NetworkRespReqSubst);
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline bool Trade::isEAPAllowed (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isEAPAllowed"));

   return false;
}

//***************************************************************************
SEVERITY Trade::validateEAPEntityAddress (const BFDataGroupId &idDataGroup)
{ //P0185010.FN02.R02.01 - Delivering EAP written notice and tax info return
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateEAPEntityAddress"));

   if (!isEAPAllowed (idDataGroup))
      return GETCURRENTHIGHESTSEVERITY ();

   DString dstrLinkedEntity;

   getField (ifds::LinkedEntityId, dstrLinkedEntity, idDataGroup, false);

   dstrLinkedEntity.strip ();

   if (dstrLinkedEntity.empty ())
      ADDCONDITIONFROMFILE( CND::ERR_ASSOCIATED_ENTITY_NOT_PROVIDED );


   DString dstrAccountNum;

   getAccountNumToPopulateRespBeneficiary (dstrAccountNum, idDataGroup);	
   dstrAccountNum.strip();
   
   bool bHasAddress = false;

   if (!dstrAccountNum.empty() && !dstrLinkedEntity.empty ())
   {

      Entity *pEntity = NULL;

      if (getWorkSession().getEntity (idDataGroup, dstrLinkedEntity, pEntity) <= WARNING && pEntity)
      {
         AddressEntityList* pAddressList;

         if (pEntity->getAddressEntityList (pAddressList, idDataGroup, true) && pAddressList)
         {
            BFObjIter iterAddressList (*pAddressList, idDataGroup);

            bHasAddress = iterAddressList.getNumberOfItemsInList() > 0 ? true : false;
         }
      }
   }

   if (!bHasAddress)
   {
         getErrMsg (IFASTERR::BENEF_ADDRESS_IS_MISSING, 
         CND::ERR_BENEF_ADDRESS_IS_MISSING, 
         CND::WARN_BENEF_ADDRESS_IS_MISSING, 
         idDataGroup); 
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getFeeParams ( const DString& feeCode,
                               const DString& fundCode,
                               const DString& classCode,
                               const DString& effectiveDate,
                               const DString& accountNum,
                               const DString& broker,
                               const DString& branch,
                               const DString& slsrepCode,
                               FundFeeList *&pFundFeeList, 
                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getFeeParams"));
   if (!feeCode.empty())
   {
      DString strKey = 
         I_("FundFeeList_FeeCode=") + feeCode +
         I_(";FundCode=") + fundCode +
         I_(";ClassCode=") + classCode +
         I_(";EffectiveDate=") + effectiveDate +
         I_(";AccountNum=") + accountNum +
         I_(";Broker=") + broker +
         I_(";Branch=") + branch +
         I_(";SlsrepCode=") + slsrepCode;

      pFundFeeList = 
         dynamic_cast<FundFeeList*> (getObject (strKey, idDataGroup));

      if (!pFundFeeList)
      {
         pFundFeeList = new FundFeeList (*this);
         if ( pFundFeeList->init ( feeCode, 
                                   fundCode,
                                   classCode,
                                   NULL_STRING, //comm group
                                   effectiveDate,
                                   accountNum,
                                   I_("FindRecord"),
                                   NULL_STRING, 
                                   NULL_STRING, 
                                   NULL_STRING,
                                   NULL_STRING,
                                   effectiveDate, //stop date
                                   broker, 
                                   NULL_STRING, 
                                   branch, 
                                   slsrepCode,
                                   NULL_STRING,
                                   NULL_STRING) <= WARNING)
         {
            setObject ( pFundFeeList, 
                        strKey, 
                        OBJ_ACTIVITY_NONE, 
                        idDataGroup);
         }
         else
         {
            int count = CONDITIONCOUNT();
            Condition *c = NULL;
            for (int i = 0; i < count; i++)
            {
               c = GETCONDITION( i );
               int condCode = c->getCode();
               //do not want to promote this condition
               if (condCode == CND::ERR_FEE_PARAMS_NOT_AVAILABLE) 
               {
                  CLEARCONDITION (i);
                  break;
               }
            }         
            delete pFundFeeList;
            pFundFeeList = NULL;
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::isBaseCommissionApplicableAndGetSFACRate ( bool &baseCommApplicable,
                                                           DString &strSFACRate,                                                 
                                                           const BFDataGroupId &idDataGroup, 
                                                           const DString dstrAllocFundCode, 
                                                           const DString dstrAllocClassCode )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isBaseCommissionApplicableAndGetSFACRate"));

   baseCommApplicable = false;
   strSFACRate = NULL_STRING;

   if (SplitCommission::isTypeTWO (getWorkSession()))
   {
      DString dstrBrokerCode,
         dstrFund,
         dstrClass;

      getField (ifds::Broker, dstrBrokerCode, idDataGroup, false);
      if ((isPurchase (idDataGroup) || isExchange (idDataGroup)) || isInterClassSwitch(idDataGroup) && !dstrBrokerCode.empty())
      {
         if(dstrAllocFundCode != NULL_STRING && dstrAllocClassCode != NULL_STRING)
         {
            dstrFund  = dstrAllocFundCode;
            dstrClass = dstrAllocClassCode;
         }
         else if (isPurchase (idDataGroup))
         {
            getField (ifds::FromFund, dstrFund, idDataGroup, false);
            getField (ifds::FromClass, dstrClass, idDataGroup, false);
         }
         else if (isExchange (idDataGroup) || isInterClassSwitch(idDataGroup))
         {
            getField (ifds::ToFund, dstrFund, idDataGroup, false);
            getField (ifds::ToClass, dstrClass, idDataGroup, false);
         }
         Broker *pBroker (NULL);

         if ( getBroker (pBroker, idDataGroup) <= WARNING &&
              pBroker)
         {
            DString fundServBroker;

            pBroker->getField (ifds::FundServBroker, fundServBroker, idDataGroup);
            if (fundServBroker == I_("N"))
            {
               FundDetail *pFundDetail = NULL;

               if ( !dstrFund.empty() &&
                    !dstrClass.empty() &&
                     getWorkSession().
                        getFundDetail (dstrFund, dstrClass, idDataGroup, pFundDetail) && 
                     pFundDetail)
               {
                  DString loadType;

                  pFundDetail->getField (ifds::LoadType, loadType, idDataGroup, false);
                  if (loadType == I_("FEL"))
                  {
                     FundFeeList *pFundFeeList = NULL;

                     DString dstrEffectiveDate,
                        dstrAccountNum,
                        dstrBranchCode,
                        dstrSlsRepCode;

                     getField (ifds::Branch, dstrBranchCode, idDataGroup, false);
                     getField (ifds::SlsrepCode, dstrSlsRepCode, idDataGroup, false);
                     getField (ifds::AccountNum, dstrAccountNum, idDataGroup, false);
                     getField (ifds::EffectiveDate, dstrEffectiveDate, idDataGroup, false);
                     if ( getFeeParams (I_("69"), //SFAC
                                          dstrFund,
                                          dstrClass,
                                          dstrEffectiveDate,
                                          dstrAccountNum,
                                          dstrBrokerCode, 
                                          dstrBranchCode,
                                          dstrSlsRepCode, 
                                          pFundFeeList, 
                                          idDataGroup) <= WARNING &&
                           pFundFeeList)
                     {
                        pFundFeeList->getField (ifds::Rate, strSFACRate, idDataGroup);
                        baseCommApplicable = true;
                     }
                  }
               }
            }
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::updateGIMaturityDate(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("updateGIMaturityDate"));
   
   if (isGIAAttribAllowed (idDataGroup))
   {
      DString dstrTradeDate,
         dstrInvestTerm,
         dstrIntCredFreq,
         dstrLastIntCredDate,
         dstrMaturityDate,
         dstrNextIntCredDate;
      //call view 426

      getField(ifds::EffectiveDate,dstrTradeDate,idDataGroup,false);
      getField(ifds::InvestTerm,dstrInvestTerm,idDataGroup,false);
      getField(ifds::IntCredFreq,dstrIntCredFreq,idDataGroup,false);
      getField(ifds::InvHisLastIntCrdDate,dstrLastIntCredDate,idDataGroup,false);

      if( !dstrInvestTerm.strip().empty() && !dstrIntCredFreq.strip().empty() )
      {
         GIAMaturityDateInq giaMaturityDateInq(*this);
         if( giaMaturityDateInq.init( dstrTradeDate,
                                    dstrInvestTerm, 
                                    dstrIntCredFreq, 
                                    dstrLastIntCredDate ) <= WARNING )
         {
            giaMaturityDateInq.getField(ifds::MaturityDate,dstrMaturityDate,BF::HOST,false);
            giaMaturityDateInq.getField(ifds::NextIntCredDate,dstrNextIntCredDate,BF::HOST,false);

            setFieldNoValidate(ifds::GIMaturityDate,dstrMaturityDate,idDataGroup,false, true, true, false);
            setFieldReadOnly (ifds::GIMaturityDate, idDataGroup, true);
            setFieldValid (ifds::GIMaturityDate, idDataGroup, true);
            setFieldNoValidate(ifds::NextIntCredDate,dstrNextIntCredDate,idDataGroup,false, true, true, false);
            setFieldReadOnly (ifds::NextIntCredDate, idDataGroup, true);
            setFieldValid (ifds::NextIntCredDate, idDataGroup, true);
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::forcedRateRelatedChanges(const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("forcedRateRelatedChanges"));

   DString dstrForcedRate(NULL_STRING),
      dstrAccountType(NULL_STRING);

   getField (ifds::ForcedRate, dstrForcedRate, idDataGroup, false);
   dstrForcedRate.strip().upperCase();
   
   if(dstrForcedRate == FORCED_RATE_FORCED)
   {
      setFieldReadOnly (ifds::ForcedRateAmt, idDataGroup, false);
   }
   else
   {
      setFieldReadOnly (ifds::ForcedRateAmt, idDataGroup, true);
      setFieldNoValidate(ifds::ForcedRateAmt, I_("0.0"), idDataGroup, false, true, true);
   }

   /*setFieldReadOnly (ifds::CommRedRate, idDataGroup, false);*/
   setCommRedRateSubstitutionSet (idDataGroup);
   setFieldValid (ifds::IntRate, idDataGroup, true);

   //display  rate from back end
   DString dstrIntInvestType(NULL_STRING);

   getField (ifds::IntInvestType, dstrIntInvestType, idDataGroup, false);
   dstrIntInvestType.strip().upperCase();

   ProgressiveIntRateList* pProgressiveIntRateList(NULL);
   if( getProgressiveIntRateList(pProgressiveIntRateList, idDataGroup, true) <= WARNING &&
         pProgressiveIntRateList )
   {
      ProgressiveIntRateList* pProgressiveIntRateListDisplay(NULL);
      getProgressiveIntRateListForDisplay(pProgressiveIntRateListDisplay,idDataGroup);

      BFObjIter iterProgIntRate (*pProgressiveIntRateList, idDataGroup);
      iterProgIntRate.begin();

      if(dstrIntInvestType == INVESTMENT_TYPE_FIX) 
      {
         // display estimate rate on IntRate, by calling to view 423;
         DString strFixIntRate;
         pProgressiveIntRateList->getField(ifds::InvHisEstimatedRate,strFixIntRate, idDataGroup, false );
         setFieldNoValidate (ifds::IntRate, strFixIntRate, idDataGroup, false, true, true, false);
      }
      else // progressive
      {
         //show term-rate table by calling to view 423
         //once back end return then load data to table
         //it's supposed to show interest rate from first record only,
         //others records they are just informations to user 
         if(!iterProgIntRate.end()) // get data from the first one
         {
               DString strProgIntRate;
               iterProgIntRate.getObject()->getField( ifds::ProgressiveIntRate, strProgIntRate, idDataGroup, false );
               setFieldNoValidate (ifds::IntRate, strProgIntRate, idDataGroup, false, true, true, false);
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getInvestmentHistoryList(InvestmentHistoryList *&pInvestmentHistoryList,
                                         const BFDataGroupId &idDataGroup,
                                         bool bForceRefresh)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("getInvestmentHistoryList"));

   pInvestmentHistoryList = NULL;
   if (isGIAAttribAllowed (idDataGroup))
   {
      DString accountNum,
         fundCode, 
         classCode,
         transId,
         effectiveDate, 
         strKey;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      getField (ifds::FromFund, fundCode, idDataGroup, false);
      getField (ifds::FromClass, classCode, idDataGroup, false);
      getField (ifds::TransId, transId, idDataGroup,false);

      if (!fundCode.empty() && !classCode.empty())
      {
         strKey = I_("InvestmentHistoryList_AccountNum=") + accountNum + I_(";") 
                + I_("FundCode=") + fundCode + I_(";")
                + I_("ClassCode=") + classCode + I_(";")
                + I_("TransId=") + transId + I_(";");

         pInvestmentHistoryList = dynamic_cast <InvestmentHistoryList*> (getObject (strKey, idDataGroup));

         if (!pInvestmentHistoryList)
         {
            pInvestmentHistoryList = new InvestmentHistoryList (*this);
            
            if (pInvestmentHistoryList->init (accountNum,
                                              transId,
                                              fundCode, 
                                              classCode, 
                                              NULL_STRING,     // InvNum
                                              NULL_STRING,     // InvStatus
                                              I_("TRANSID"),   // SearchBy
                                              idDataGroup) <= WARNING)
            {
               setObject (pInvestmentHistoryList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
            }
            else
            {
               delete pInvestmentHistoryList;
               pInvestmentHistoryList = NULL;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getProgressiveIntRateList(ProgressiveIntRateList *&pProgressiveIntRateList,
                                          const BFDataGroupId &idDataGroup,
                                          bool bForceRefresh)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("getProgressiveIntRateList"));
   
   pProgressiveIntRateList = NULL;
   if (isGIAAttribAllowed (idDataGroup))
   {
      DString accountNum,
         fundCode, 
         classCode,
         strKey,
         investType,
         calcMethod,
         investTerm,
         tradeAmount,
         additionalAmount,
         interestDate,
         commRedRate,
         transType,
         forcedRate,
         forcedRateAmt;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      //getField (ifds::FromFund, fundCode, idDataGroup, false);
      //getField (ifds::FromClass, classCode, idDataGroup, false);
      getField(ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::Amount, tradeAmount, idDataGroup, false);

      if(transType == TRADETYPE::EXCHANGE ||
         transType == TRADETYPE::INTER_CLASS_SWITCH || 
         transType == TRADETYPE::TRANSFER)
      {
         getField (ifds::ToFund, fundCode, idDataGroup, false);
         getField (ifds::ToClass, classCode, idDataGroup, false);

         /* 
         if transtype, transfer or exchanges and trade amount is zero,
         that means it is full redemption to GI fund, get the MKV of from fund to
         send to v423 calculate the interest rate.
         */

         DString dstrFromFund, dstrFromClass;
         getField (ifds::FromFund, dstrFromFund, idDataGroup, false);
         getField (ifds::FromClass, dstrFromClass, idDataGroup, false);

         BigDecimal bdTradeAmount = DSTCommonFunctions::convertToBigDecimal(tradeAmount);
         if (bdTradeAmount == 0)
         {
            // get MKV from view 20
            MFAccountHoldingList *pMFAccountHoldings = NULL;

            if ( getAccountHoldings (pMFAccountHoldings, idDataGroup, dstrFromFund, dstrFromClass) <= WARNING &&
               pMFAccountHoldings)
            {
               BFObjIter bfIter (*pMFAccountHoldings, idDataGroup);
               /* should have only one */
               if (!bfIter.end())
               {
                  DString dstrMKV;
                  bfIter.getObject()->getField (ifds::SettledValue, dstrMKV, idDataGroup);
                  // override the MKV
                  tradeAmount = dstrMKV;
               }
            }
         }
      }
      else
      {
         getField (ifds::FromFund, fundCode, idDataGroup, false);
         getField (ifds::FromClass, classCode, idDataGroup, false);
      }
      getField (ifds::IntInvestType, investType, idDataGroup, false);
      getField (ifds::IntCalcMthd, calcMethod, idDataGroup, false);
      getField (ifds::InvestTerm, investTerm, idDataGroup, false);
      getField (ifds::AddlAmt, additionalAmount, idDataGroup, false);
      getField (ifds::EffectiveDate, interestDate, idDataGroup, false);
      getField (ifds::CommRedRate, commRedRate, idDataGroup, false);
      getField (ifds::ForcedRate, forcedRate, idDataGroup, false);
      getField (ifds::ForcedRateAmt, forcedRateAmt, idDataGroup, false);

      if (!fundCode.empty() && !classCode.empty())
      {
         // they are the require fields to fill in the view to populated the value
         // from common module.
         if( investType.empty() ||
             calcMethod.empty() ||
             investTerm.empty())
            return GETCURRENTHIGHESTSEVERITY();
            
         strKey = I_("ProgressiveIntRateList_InvestType=") + investType + I_(";")
                + I_("AccountNum=") + accountNum + I_(";") 
                + I_("FundCode=") + fundCode + I_(";")
                + I_("ClassCode=") + classCode + I_(";")
                + I_("CalcMethod=") + calcMethod + I_(";")
                + I_("InvestTerm=") + investTerm + I_(";")
                + I_("TradeAmount=") + tradeAmount + I_(";")
                + I_("AddlAmt=") + additionalAmount + I_(";")
                + I_("CommRedRate=") + commRedRate + I_(";")
                + I_("ForcedRate=") + forcedRate + I_(";")
                + I_("ForcedRateAmt=") + forcedRateAmt + I_(";");

         pProgressiveIntRateList = dynamic_cast <ProgressiveIntRateList*> (getObject (strKey, idDataGroup));

         if (!pProgressiveIntRateList || bForceRefresh)
         {
            pProgressiveIntRateList = new ProgressiveIntRateList (*this);

            if (pProgressiveIntRateList->initForTrade (accountNum,
                                                       fundCode, 
                                                       classCode,
                                                       I_("INIT"),
                                                       NULL_STRING,
                                                       investType,
                                                       calcMethod,
                                                       investTerm,
                                                       interestDate,
                                                       tradeAmount,
                                                       additionalAmount,
                                                       commRedRate,
                                                       forcedRate,
                                                       forcedRateAmt) <= WARNING)
            {
               setObject (pProgressiveIntRateList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
            }
            else
            {
               delete pProgressiveIntRateList;
               pProgressiveIntRateList = NULL;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getProgressiveIntRateListForDisplay(ProgressiveIntRateList *&pProgressiveIntRateList,
                                                    const BFDataGroupId &idDataGroup,
                                                    bool bForceRefresh )
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("getProgressiveIntRateList"));

   pProgressiveIntRateList = NULL;
   if (isGIAAttribAllowed (idDataGroup))
   {
      DString accountNum,
         fundCode, 
         classCode,
         strKey,
         investType,
         transType,
         calcMethod,
         investTerm,
         tradeAmount,
         additionalAmount,
         interestDate,
         commRedRate,
         forcedRate,
         forcedRateAmt;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      getField(ifds::TradesTransType, transType, idDataGroup, false);
      if(transType == TRADETYPE::EXCHANGE ||
         transType == TRADETYPE::INTER_CLASS_SWITCH ||
         transType == TRADETYPE::TRANSFER)
      {
         getField (ifds::ToFund, fundCode, idDataGroup, false);
         getField (ifds::ToClass, classCode, idDataGroup, false);
      }
      else
      {
         getField (ifds::FromFund, fundCode, idDataGroup, false);
         getField (ifds::FromClass, classCode, idDataGroup, false);
      }

      getField (ifds::IntCalcMthd, calcMethod, idDataGroup, false);
      getField (ifds::InvestTerm, investTerm, idDataGroup, false);
      getField (ifds::Amount, tradeAmount, idDataGroup, false);
      getField (ifds::AddlAmt, additionalAmount, idDataGroup, false);
      getField (ifds::EffectiveDate, interestDate, idDataGroup, false);
      getField (ifds::CommRedRate, commRedRate, idDataGroup, false);
      getField (ifds::IntInvestType, investType, idDataGroup, false);
      getField (ifds::ForcedRate, forcedRate, idDataGroup, false);
      getField (ifds::ForcedRateAmt, forcedRateAmt, idDataGroup, false);

      if (!fundCode.empty() && !classCode.empty())
      {
         strKey =  I_("ProgressiveIntRateList_Display_");
         strKey += I_("InvestType=") + investType + I_(";");
         strKey += I_("AccountNum=") + accountNum + I_(";");
         strKey += I_("TransType=") + transType + I_(";");
         strKey += I_("FundCode=") + fundCode + I_(";");
         strKey += I_("ClassCode=") + classCode + I_(";");
         strKey += I_("ForcedRate=") + forcedRate + I_(";");
         strKey += I_("ForcedRateAmt=") + forcedRateAmt + I_(";");
         
         pProgressiveIntRateList = dynamic_cast <ProgressiveIntRateList*> (getObject (strKey, idDataGroup));

         if (!pProgressiveIntRateList || bForceRefresh)
         {
            pProgressiveIntRateList = new ProgressiveIntRateList (*this);

            if (pProgressiveIntRateList->initForTrade (accountNum,
                                                       fundCode, 
                                                       classCode,
                                                       I_("INIT"),
                                                       NULL_STRING,
                                                       investType,
                                                       calcMethod,
                                                       investTerm,
                                                       interestDate,
                                                       tradeAmount,
                                                       additionalAmount,
                                                       commRedRate,
                                                       forcedRate,
                                                       forcedRateAmt) <= WARNING)
            {
               setObject (pProgressiveIntRateList, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
            }
            else
            {
               delete pProgressiveIntRateList;
               pProgressiveIntRateList = NULL;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::investTypeRelatedChanges(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("investTypeRelatedChanges"));

   if (isGIAAttribAllowed (idDataGroup))
   {
      DString dstrForcedRate(NULL_STRING);

      getField (ifds::ForcedRate, dstrForcedRate, idDataGroup, false);
      dstrForcedRate.strip().upperCase();

      //display  rate from back end
      DString dstrIntInvestType(NULL_STRING);

      getField (ifds::IntInvestType, dstrIntInvestType, idDataGroup, false);
      dstrIntInvestType.strip().upperCase();

      ProgressiveIntRateList* pProgressiveIntRateList(NULL);
      if( getProgressiveIntRateList(pProgressiveIntRateList, idDataGroup, true) <= WARNING &&
            pProgressiveIntRateList )
      {
         BFObjIter iterProgIntRate (*pProgressiveIntRateList, idDataGroup);
         iterProgIntRate.begin();

         if(dstrIntInvestType == INVESTMENT_TYPE_FIX || dstrForcedRate == FORCED_RATE_FORCED) 
         {
            // display estimate rate on IntRate, by calling to view 423;
            DString strFixIntRate;
            pProgressiveIntRateList->getField(ifds::InvHisEstimatedRate,strFixIntRate, idDataGroup, false );
            setFieldNoValidate (ifds::IntRate, strFixIntRate, idDataGroup, false, true, true, false);
         }
         else // progressive
         {
            //show term-rate table by calling to view 423
            //once back end return then load data to table
            //it's supposed to show interest rest from first record only,
            //others records they are just informations to user 
            if(!iterProgIntRate.end()) // get data from the first one
            {
               DString strProgIntRate;
               iterProgIntRate.getObject()->getField( ifds::ProgressiveIntRate, strProgIntRate, idDataGroup, false );
               setFieldNoValidate (ifds::IntRate, strProgIntRate, idDataGroup, false, true, true, false);
            }
         }
      }
   
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::intCalcMthdRelatedChanges(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("intCalcMthdRelatedChanges"));
   
   if (isGIAAttribAllowed (idDataGroup))
   {   
      DString dstrIntCalcMthd;
      
      getField(ifds::IntCalcMthd, dstrIntCalcMthd, idDataGroup, false);
      
      GIAInvAttribList* pGIAInvAttribList = NULL;
      if ( getGIFundDefaults (pGIAInvAttribList, idDataGroup, false) <= WARNING &&
           pGIAInvAttribList)
      {
         if(dstrIntCalcMthd == I_("S"))
         {
            DString dstrSimpleTermList,
               dstrSimpleCredFreqList;
               
            pGIAInvAttribList->getField(ifds::SimpleTermList, dstrSimpleTermList, idDataGroup, false );
            pGIAInvAttribList->getField(ifds::SimpleCredFreqList, dstrSimpleCredFreqList, idDataGroup, false );
            dstrSimpleTermList.strip();
            dstrSimpleCredFreqList.strip();
            
            if(!dstrSimpleTermList.empty())
            {
               DString::size_type pos = 0;
               DString dstrItem_,
                  investTermListSubSt;

               do
               {
                  EXTRACT_VALUE(dstrSimpleTermList, dstrItem_);
                  investTermListSubSt  += dstrItem_ + I_("=") + dstrItem_ + I_(";");

                  CHOP_STRING (dstrSimpleTermList);
               }
               while (dstrSimpleTermList != NULL_STRING);
               
               BFProperties *pBFPropertiesInvestTerm = 
                  getFieldProperties (ifds::InvestTerm, idDataGroup);

               assert (pBFPropertiesInvestTerm);
               if (pBFPropertiesInvestTerm)
               {
                  setFieldAllSubstituteValues (ifds::InvestTerm, idDataGroup, investTermListSubSt);            
                  pBFPropertiesInvestTerm->setSubstituteValues(NULL);

                  if (!_bInitPending)
                  {
                     setFieldNoValidate ( ifds::InvestTerm, NULL_STRING, idDataGroup, false, 
                                          false, 
                                          true, //notify
                                          false); //no related changes
                  }
                  else
                  {
                     DString dstrCommReduction;
                     getField (ifds::CommRedRate, dstrCommReduction, idDataGroup, false);
                     int pos = dstrCommReduction.find ( I_(".") ); 

                     if (pos > 0)
                     {
                        dstrCommReduction.stripTrailing(I_CHAR('0'));
                        setFieldNoValidate (ifds::CommRedRate, dstrCommReduction, idDataGroup, false, true, true, false); 
                     }
                  }

                  setFieldValid (ifds::InvestTerm, idDataGroup, false);
                  setFieldRequired (ifds::InvestTerm, idDataGroup, true);
               }
            }

            loadSubstitutionList (ifds::IntCredFreq, idDataGroup, dstrSimpleCredFreqList);

            if (!_bInitPending)
            {
               setFieldNoValidate ( ifds::IntCredFreq, NULL_STRING, idDataGroup, false, 
                                    false, 
                                    true, //notify
                                    false); //no related changes
            }

            setFieldValid (ifds::IntCredFreq, idDataGroup, false);
            setFieldRequired (ifds::IntCredFreq, idDataGroup, true);
         }
         else if (dstrIntCalcMthd == I_("C"))
         {
            DString dstrCompoundTermList,
               dstrCompoundCredFreqList;
                     
            pGIAInvAttribList->getField(ifds::CompoundTermList, dstrCompoundTermList, idDataGroup, false );
            pGIAInvAttribList->getField(ifds::CompoundCredFreqList, dstrCompoundCredFreqList, idDataGroup, false );
            dstrCompoundTermList.strip();
            dstrCompoundCredFreqList.strip();
            
            if(!dstrCompoundTermList.empty())
            {
               DString::size_type pos = 0;
               DString dstrItem_,
                  investTermListSubSt;

               do
               {
                  EXTRACT_VALUE(dstrCompoundTermList, dstrItem_);
                  investTermListSubSt  += dstrItem_ + I_("=") + dstrItem_ + I_(";");

                  CHOP_STRING (dstrCompoundTermList);
               }
               while (dstrCompoundTermList != NULL_STRING);
               
               BFProperties *pBFPropertiesInvestTerm = 
                  getFieldProperties (ifds::InvestTerm, idDataGroup);

               assert (pBFPropertiesInvestTerm);
               if (pBFPropertiesInvestTerm)
               {
                  setFieldAllSubstituteValues (ifds::InvestTerm, idDataGroup, investTermListSubSt);            
                  pBFPropertiesInvestTerm->setSubstituteValues(NULL);
                  
                  if (!_bInitPending)
                  {
                     setFieldNoValidate ( ifds::InvestTerm, NULL_STRING, idDataGroup, false, 
                                          false, 
                                          true, //notify
                                          false); //no related changes
                  }

                  setFieldValid (ifds::InvestTerm, idDataGroup, false);
                  setFieldRequired (ifds::InvestTerm, idDataGroup, true);
               }
            }

            loadSubstitutionList (ifds::IntCredFreq, idDataGroup, dstrCompoundCredFreqList);

            if (!_bInitPending)
            {
               setFieldNoValidate ( ifds::IntCredFreq, NULL_STRING, idDataGroup, false, 
                                    false, 
                                    true, //notify
                                    false); //no related changes
            }

            setFieldValid (ifds::IntCredFreq, idDataGroup, false);
            setFieldRequired (ifds::IntCredFreq, idDataGroup, true);
         }
      }
   }   
   
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::setCommRedRateSubstitutionSet(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("setCommRedRateSubstitutionSet"));
   
   DString commRedRateList;   
   GIAInvAttribList* pGIAInvAttribList = NULL;
   if ( getGIFundDefaults (pGIAInvAttribList, idDataGroup, false) <= WARNING &&
        pGIAInvAttribList)
   {   
      pGIAInvAttribList->getField (ifds::CommRedRateList, commRedRateList, idDataGroup, false);

      if(!commRedRateList.empty())
      {
         DString::size_type pos = 0;
         DString dstrItem_;

         DString commRedRateListSubSt(NULL_STRING);
         do
         {
            EXTRACT_VALUE(commRedRateList, dstrItem_);
            commRedRateListSubSt  += dstrItem_ + I_("=") + dstrItem_ + I_(";");

            CHOP_STRING (commRedRateList);
         }
         while (commRedRateList != NULL_STRING);

         BFProperties *pBFPropertiesCommRedRate = 
            getFieldProperties (ifds::CommRedRate, idDataGroup);

         assert (pBFPropertiesCommRedRate);
         if (pBFPropertiesCommRedRate)
         {
            int pos = commRedRateListSubSt.find ( I_("0=0;") ); 
            if(pos < 0)
               commRedRateListSubSt = I_("0=0;") + commRedRateListSubSt;
            setFieldAllSubstituteValues (ifds::CommRedRate, idDataGroup, commRedRateListSubSt);
            pBFPropertiesCommRedRate->setSubstituteValues(NULL);
         }
      }
   }
   
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::editCheckOnMMF ( const DString &transType, bool bFullExchPrntToPrnt, const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("editCheckOnMMF"));

   DString fundCode, classCode;
   getField (ifds::FromFund, fundCode, idDataGroup, false);
   getField (ifds::FromClass, classCode, idDataGroup, false);
   
   if (!fundCode.empty() && !classCode.empty())
   {
      DString tradeDate, exchRate, depositType,orderType,amtType,amount, currency, 
         broker, branch, slsrep,accountNum ;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      getField (ifds::AmtType, amtType, idDataGroup, false);
      getField (ifds::Amount, amount, idDataGroup, false);
      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      getField (ifds::SettleCurrency, currency, idDataGroup);
      getField (ifds::Broker, broker, idDataGroup, false);
      getField (ifds::Branch, branch, idDataGroup, false);
      getField (ifds::SlsrepCode, slsrep, idDataGroup, false);
      getField (ifds::ExchRate, exchRate, idDataGroup, false);
      getField (ifds::DepositType, depositType, idDataGroup); 
      getField (ifds::OrderType, orderType, idDataGroup);

      TradeMinAmtCheck *pTradeMinAmtCheck = NULL;
      DString strKey = 
         I_("TradeMinAmtCheck_Account=")  + accountNum +
         I_(";TransType=")    + transType +
         I_(";FundCode=")     + fundCode  +
         I_(";ClassCode=")    + classCode +
         I_(";AmtType=")      + amtType   +
         I_(";Amount=")       + amount    +
         I_(";Currency=")     + currency  +
         I_(";Broker=")       + broker    +
         I_("Branch=")        + branch    +
         I_("SlsRep=")        + slsrep    +
         I_("TradeDate=")     + tradeDate +
         I_("DepositType=")   + depositType +
         I_("OrderType=")     + orderType +
         I_(";FullExchPrntToPrnt=")  + (bFullExchPrntToPrnt ? Y:N); 

      pTradeMinAmtCheck = 
            dynamic_cast<TradeMinAmtCheck*> (getObject (strKey, idDataGroup));

      if (!pTradeMinAmtCheck)
      {
         pTradeMinAmtCheck = new TradeMinAmtCheck (*this);
         if ( pTradeMinAmtCheck->init ( accountNum, 
                                        fundCode, 
                                        classCode, 
                                        transType, 
                                        amtType,
                                        amount, 
                                        tradeDate, 
                                        currency, 
                                        exchRate,
                                        broker,
                                        branch,
                                        slsrep,
                                        NULL_STRING, 
                                        NULL_STRING, 
                                        depositType, 
                                        orderType )  
                                         <= WARNING)
         {
            setObject (pTradeMinAmtCheck, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
         }
         else
         {
            delete pTradeMinAmtCheck;
            pTradeMinAmtCheck = NULL;
         }
      }
      if (pTradeMinAmtCheck)
      {
         pTradeMinAmtCheck->addConditions ();
      }
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isMoneyMarketFund (const DString &fundCode)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isMoneyMarketFund"));
   bool isMoneyMarketFund = false;

   FundMasterList *pFundMasterList = NULL;

   if ( !fundCode.empty() && 
      getMgmtCo().getFundMasterList (pFundMasterList) && 
      NULL != pFundMasterList )
   {
      if (pFundMasterList->isMoneyMarketFund(fundCode))
      {
         isMoneyMarketFund = true;
      }
   }

   return isMoneyMarketFund;
}

//******************************************************************************
SEVERITY Trade::validateMoneyMktFund (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateMoneyMktFund"));

// imple ment in Redemption/ Transfer and Exchange
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getGIInvestmentDetails ( GIInvestmentDetailsList *&pGIInvestmentDetailsList, 
                                            const BFDataGroupId &idDataGroup, 
                                            bool bCreate) /*= true*/
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("getGIInvestmentDetails"));
   
   pGIInvestmentDetailsList = NULL;
   DString strKey = I_("GIInvestmentDetailsList|");

   DString dstrFundFrom;
   DString dstrClassFrom;
   DString dstrAmountType;

   getField (ifds::FromFund,     dstrFundFrom,     idDataGroup, false);
   getField (ifds::FromClass,    dstrClassFrom,    idDataGroup, false);
   getField (ifds::AmtType,      dstrAmountType,   idDataGroup, false);
   if(I_("") != dstrFundFrom && I_("") != dstrClassFrom)
   {
      strKey += dstrFundFrom;
      strKey += I_("|");
      strKey += dstrClassFrom;
      strKey += I_("|"); 
      strKey += dstrAmountType;

      pGIInvestmentDetailsList = 
            dynamic_cast <GIInvestmentDetailsList *> ( getObject ( strKey, 
                                                            idDataGroup));
      if (!pGIInvestmentDetailsList && bCreate)
      {
         DString dstrAccountNum;
         DString dstrTransId;
         DString dstrInvNum;
         DString dstrInvStatus;
         DString dstrSearchBy;
         DString dstrEffDate;
         DString dstrTradeAmt;
         DString dstrGrossNet;

         getField (ifds::AccountNum,    dstrAccountNum,  idDataGroup, false);
         getField (ifds::TransNum,      dstrTransId,     idDataGroup, false);
         getField (ifds::EffectiveDate, dstrEffDate,     idDataGroup, false);

         getField (ifds::Amount,        dstrTradeAmt,    idDataGroup, false);
         getField (ifds::GrossOrNet,    dstrGrossNet,    idDataGroup, false);

         if(I_("") != dstrAccountNum && I_("") != dstrFundFrom && I_("") != dstrClassFrom)
         {
            DString dstrSuppressMVA;
            DString dstrSuppressAdmin;
            TransFeeList* pTransFeeList = NULL;
            getTransFeeList (pTransFeeList, idDataGroup, false); 
            if(pTransFeeList)
            {
               TransFee *pMVATransFee = NULL;
               TransFee *pGIAdminTransFee = NULL;
               if(pTransFeeList)
               {
                  pTransFeeList->getTransFee ( FEES::MVA,      pMVATransFee, idDataGroup);
                  pTransFeeList->getTransFee ( FEES::GIADMIN,  pGIAdminTransFee, idDataGroup);    

                  if(pMVATransFee)
                  {
                     DString dstrFeeCharge;
                     pMVATransFee->getField(ifds::FeeCharge, dstrFeeCharge, idDataGroup);
                     dstrSuppressMVA = dstrFeeCharge == I_("N") ? I_("Y") : I_("N");
                  }
                  
                  if(pGIAdminTransFee)
                  {
                     DString dstrFeeCharge;
                     pGIAdminTransFee->getField(ifds::FeeCharge, dstrFeeCharge, idDataGroup);
                     dstrSuppressAdmin = dstrFeeCharge == I_("N") ? I_("Y") : I_("N");
                  }
               }
            }


            pGIInvestmentDetailsList = new GIInvestmentDetailsList(*this);
            SEVERITY severity = pGIInvestmentDetailsList->init (dstrAccountNum, 
                                                                dstrTransId, 
                                                                dstrFundFrom,
                                                                dstrClassFrom,
                                                                dstrInvNum,
                                                                dstrInvStatus,
                                                                I_("ALL"),
                                                                dstrEffDate,
                                                                dstrAmountType,
                                                                isNew(),
                                                                idDataGroup,
                                                                dstrSuppressMVA,
                                                                dstrSuppressAdmin,
                                                                dstrTradeAmt,
                                                                dstrGrossNet);

            if (severity <= WARNING)
            {
               setObject ( pGIInvestmentDetailsList, strKey, OBJ_ACTIVITY_ADDED, idDataGroup); 
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getGIInvestmentTotals ( GIInvestmentDetailsList *&pGIInvestmentDetailsList, 
                                        const BFDataGroupId &idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("getGIInvestmentTotals"));

   DString strKey = I_("GIInvestmentTotals");

   pGIInvestmentDetailsList = dynamic_cast <GIInvestmentDetailsList *> ( getObject ( strKey, idDataGroup));
   if (!pGIInvestmentDetailsList)
   {
      pGIInvestmentDetailsList = new GIInvestmentDetailsList(*this);
      GIInvestmentDetails* pGIInvestmentDetails = new GIInvestmentDetails(*pGIInvestmentDetailsList);
      pGIInvestmentDetailsList->setIsTotalsCBO(true);
      pGIInvestmentDetailsList->setObject(pGIInvestmentDetails, I_("elem"), OBJ_ACTIVITY_NONE, idDataGroup); 

      setObject ( pGIInvestmentDetailsList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
   }
   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************shashi
inline bool Trade::isValueDatePriorToTradeDate(const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "isValueDatePriorToTradeDate" ));
   DString tradeDate, valueDate;
   getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
   getField (ifds::ValueDate, valueDate, idDataGroup, false);

   return (DSTCommonFunctions::CompareDates (valueDate, tradeDate) == DSTCommonFunctions::FIRST_EARLIER);    
   //return true;
}

//******************************************************************************
inline void Trade::PaymentStatusRelatedChanges(const BFDataGroupId& idDataGroup)
{
   setFieldReadOnly (ifds::PaymentInfo, idDataGroup, !isValueDatePriorToTradeDate(idDataGroup));
   setFieldNoValidate (ifds::PaymentInfo, NULL_STRING, idDataGroup, false);
}

//******************************************************************************
SEVERITY Trade::loadPaymentStatusSubstList (const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "loadPaymentStatusSubstList" ));

   BFProperties *pBFPropertiesPaymentInfo = getFieldProperties (ifds::PaymentInfo, idDataGroup);
   assert (pBFPropertiesPaymentInfo);
   if (pBFPropertiesPaymentInfo)
   {
      DString PaymentInfoSubst;
      pBFPropertiesPaymentInfo->getAllSubstituteValues (PaymentInfoSubst);

      PaymentInfoSubst = removeItemFromSubtList ( PaymentInfoSubst,I_("N") );
      PaymentInfoSubst = removeItemFromSubtList ( PaymentInfoSubst,I_("P") );
      PaymentInfoSubst = removeItemFromSubtList ( PaymentInfoSubst,I_("I") );

      setFieldAllSubstituteValues (ifds::PaymentInfo, idDataGroup, PaymentInfoSubst);
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
inline void Trade::ResetPendTrdContract (const BFDataGroupId& idDataGroup) 
{
   setFieldReadOnly (ifds::PendTrdContract, idDataGroup, true);
   setFieldNoValidate (ifds::PendTrdContract, I_("00"), idDataGroup, false);   
}

//******************************************************************************
inline void Trade::PendTrdContractRelatedChanges (const BFDataGroupId& idDataGroup) 
{
   if (isPendTrdContrApplic (idDataGroup) ) 
   {
      loadPendTrdContrSubtList(idDataGroup);
   }
}

//******************************************************************************
bool Trade::isPendTrdContrApplic (const BFDataGroupId& idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "isPendTrdContrApplic" ));
   
   ResetPendTrdContract(idDataGroup);

   bool bPendTrdContrApplic = false;
   DString pendTrdContrTransList = NULL_STRING;   

   DString fundCode;
   getField (ifds::FromFund, fundCode, idDataGroup, false);
   FundMasterList *pFundMasterList = NULL; 
   if ( !fundCode.empty() && 
         getMgmtCo().getFundMasterList (pFundMasterList) && 
         NULL != pFundMasterList )
   {	  
      pendTrdContrTransList = pFundMasterList->getPendTrdContractList (fundCode);
      pendTrdContrTransList.strip ();
   }
   if (pendTrdContrTransList == I_("*"))
   {
      bPendTrdContrApplic = true;
   }
   else
   {
      DString tradesTransType;
      getField (ifds::TradesTransType, tradesTransType, idDataGroup, false);

      if( DSTCommonFunctions::codeInList (tradesTransType, TRADETYPE::PTC_PURCHASE) )
         tradesTransType = I_("ED");
      else if( DSTCommonFunctions::codeInList (tradesTransType, TRADETYPE::PTC_REDEMPTION) )
         tradesTransType = I_("PW");
      else if( DSTCommonFunctions::codeInList (tradesTransType, TRADETYPE::PTC_TRANSFER) )
         tradesTransType = I_("TR");
      else if( DSTCommonFunctions::codeInList (tradesTransType, TRADETYPE::PTC_AF) )
         tradesTransType = I_("AF");
      else if( DSTCommonFunctions::codeInList (tradesTransType, TRADETYPE::PTC_AW) )
         tradesTransType = I_("AW");

      bPendTrdContrApplic = DSTCommonFunctions::codeInList (tradesTransType, pendTrdContrTransList);
   }   
   return bPendTrdContrApplic;
}

//******************************************************************************
SEVERITY Trade::loadPendTrdContrSubtList (const BFDataGroupId& idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_( "loadPendTrdContrSubtList" ));   

   setFieldReadOnly (ifds::PendTrdContract, idDataGroup, false);

   DString PendTrdContractSubst;   
   loadSubstitutionList (ifds::PendTrdContract, idDataGroup, PEND_TRD_CONTRACT_SUB_LIST);

   BFProperties *pBFPropertiesPendTrdContract = getFieldProperties (ifds::PendTrdContract, idDataGroup);
   assert (pBFPropertiesPendTrdContract);
   if (pBFPropertiesPendTrdContract)
   {
      pBFPropertiesPendTrdContract->getAllSubstituteValues (PendTrdContractSubst);    
   }
   
   if (!_bPtcForPending || _bRebook)
   {
      PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("04") );	
      PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("05") );
      PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("06") );	
      setFieldNoValidate (ifds::PendTrdContract, I_("01"), idDataGroup, true,true,false,true);
   }
   else
   {
      DString dstrGoodBad;
      getField (ifds::GoodBad, dstrGoodBad, idDataGroup, false); 
      if( dstrGoodBad == I_("N"))
      {
         PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("01") );
         PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("04") );
         PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("06") );
         setFieldNoValidate (ifds::PendTrdContract, I_("05"), idDataGroup, true,true,false,true);
      }
      else
      {
         PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("01") );	
         PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("05") );
         setFieldNoValidate (ifds::PendTrdContract, I_("04"), idDataGroup, true,true,false,true);
      }
   }
   PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("03") );
   PendTrdContractSubst = removeItemFromSubtList ( PendTrdContractSubst,I_("00") );   
   setFieldAllSubstituteValues (ifds::PendTrdContract, idDataGroup, PendTrdContractSubst);
  
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isFundERISAProhibited ( const DString &fundCode, 
                               const DString &classCode, 
                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("isFundERISAProhibited"));
   FundDetail *pFundDetail = NULL;
   bool bIsFundERISAProhibited = false;

   if ( getWorkSession().getFundDetail ( fundCode,classCode,idDataGroup,pFundDetail) &&
        pFundDetail)
   {
      bIsFundERISAProhibited = pFundDetail->isFundERISAProhibited (idDataGroup);
   }
   return bIsFundERISAProhibited;
}

//******************************************************************************
SEVERITY Trade::validateFundForERISAAccount ( const DString &fundCode, 
                               const DString &classCode, 
                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFundForERISAAccount"));
 
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::enablePFCrystalisationFlag (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("enablePFCrystalisationFlag"));  

   DString dstrFromFund = NULL_STRING, 
      dstrToFund	= NULL_STRING, 
      dstrFromClass= NULL_STRING,
      dstrToClass	= NULL_STRING;

   getField (ifds::FromFund, dstrFromFund, idDataGroup, false);
   getField (ifds::FromClass, dstrFromClass, idDataGroup, false);
   getField (ifds::ToFund, dstrToFund, idDataGroup, false);
   getField (ifds::ToClass, dstrToClass, idDataGroup, false);

   bool bFromIsPF = getWorkSession ().isPerfFeeFund(dstrFromFund,dstrFromClass,idDataGroup);
   bool bToIsPF   = getWorkSession ().isPerfFeeFund(dstrToFund,dstrToClass,idDataGroup);
   bool bEnable   = bFromIsPF && bToIsPF;

   setFieldReadOnly (ifds::PFCrystalisation, idDataGroup, !bEnable);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isGIAFund (const DString &fundCode)
{
   MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isGIAFund"));
   bool bIsGIAFund = false;

   FundMasterList *pFundMasterList = NULL;

   if ( !fundCode.empty() && 
        getMgmtCo().getFundMasterList (pFundMasterList) && 
        NULL != pFundMasterList )
   {
      if (pFundMasterList->isGIAFund(fundCode))			
      {
         bIsGIAFund = true;
      }
   }

   return bIsGIAFund;
}

//*******************************************************************************
bool Trade::isDIFFund ( const DString& fundCode)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "isDIFFund" ) );
   bool bIsDIFFund = false;
   FundMasterList *pFundMasterList = NULL;

   if ( !fundCode.empty() && 
         getMgmtCo().getFundMasterList (pFundMasterList) && 
         NULL != pFundMasterList )
   {
      if (pFundMasterList->isDIFFund(fundCode))
      {
         bIsDIFFund = true;
      }
   }

   return bIsDIFFund;
}
/*******************************************************************************
Input:BFDataGroupID,AcctUseCodeforBank
OutPut:BankInstructions
Return:SEVERITY
Functionality:Retrives the Reg Agent Banking Instructions for the AcctUseCode .If 
              Nothing is avilable for AcctUseCode,function returns the Default bank
              Instr if avilable.
/*******************************************************************************/
SEVERITY Trade::getRegAgentBankInstructions ( BankInstructions *&pBankInstructions, 
                                              const DString &bankAcctUseCode,
                                              //const DString &RegAgentCode,
                                              const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("RegAgentBankInstructions"));
   DString accountNum,dstrVerifyStatus;
   BankInstructions *pRegAgentDefaultAcctUsageBankInstructions= NULL;    
   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   accountNum.stripLeading ('0').strip();
   if (!accountNum.empty())
   {
      MFAccount *pMFAccount = NULL;
      if ( getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&
           pMFAccount)
      {
         DString dstrRegAgentCode,dstrTaxType;  
		  if(pMFAccount->bIsTaxTypeRelatedtoRegAgent(idDataGroup))
			{
			   pMFAccount->getField( ifds::RegAgentCode, dstrRegAgentCode, idDataGroup, false );	
			   dstrRegAgentCode.stripAll();
			   dstrRegAgentCode.upperCase();
			   if (!dstrRegAgentCode.empty())
			   {
			  	AgentBankInstructionsListRepository  *pAgentBankInstructionsListRepository = NULL;
				if ( getWorkSession().getAgentBankInstructionsListRepository (pAgentBankInstructionsListRepository) <= WARNING && 
					pAgentBankInstructionsListRepository)
				 {
					
				  RegAgentBankInstructionsList  *pRegAgentBankInstructionsList = NULL;
				  if ( pAgentBankInstructionsListRepository->
					   getRegAgentBankInstructionsList ( dstrRegAgentCode, 
														 pRegAgentBankInstructionsList, 
														 idDataGroup) <= WARNING && pRegAgentBankInstructionsList)
					{  
					  DString currency,tradeDate;

					  getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
					  BFObjIter iter ( *pRegAgentBankInstructionsList,idDataGroup);
					  getField (ifds::SettleCurrency, currency, idDataGroup, false);
					  if (!currency.empty())
					  {
					   while (!iter.end())
						{
						  DString bankAcctCurrency,bankAcctUseCode_,bankEffectiveDate,bankStopDate;
						  iter.getObject()->getField (ifds::BankAcctCurrency, bankAcctCurrency, idDataGroup, false);
						  iter.getObject()->getField (ifds::AcctUseCode, bankAcctUseCode_, idDataGroup, false);
						  iter.getObject()->getField (ifds::EffectiveDate, bankEffectiveDate, idDataGroup, false);
						  iter.getObject()->getField (ifds::StopDate, bankStopDate, idDataGroup, false);
						  if ( bankAcctCurrency == currency && bankAcctUseCode_ == bankAcctUseCode &&
						       DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
						  {
							//pick the first one...
							pBankInstructions = dynamic_cast <BankInstructions*> (iter.getObject());
							pBankInstructions->getField (ifds::VerifyStat,dstrVerifyStatus,idDataGroup, false);
							break;
						  }
						  else if ( bankAcctCurrency == currency && bankAcctUseCode_ == AcctUseCode::DEFAULT &&
								    DSTCommonFunctions::IsDateBetween (bankEffectiveDate, bankStopDate, tradeDate))
						 {
							//hang on to the 'Default' account usage bank instructions
							//in case the correct account usage is not found
							 pRegAgentDefaultAcctUsageBankInstructions = 
									dynamic_cast <BankInstructions*> (iter.getObject());
							 pRegAgentDefaultAcctUsageBankInstructions->getField (ifds::VerifyStat,dstrVerifyStatus,idDataGroup, false);
						  }
						++iter;
						}//end while
						if (!pBankInstructions) 
						{
						//if bank instructions not found use the default bank instructions if avilable                    
						pBankInstructions = pRegAgentDefaultAcctUsageBankInstructions;
						}
					  }//currency empty
					}//getRegAgentBankInstructionsList
				 }//getAgentBankInstructionsListRepository
			   }//regagentcode empty
			   else 
			   ADDCONDITIONFROMFILE (CND::ERR_REG_AGENT_NOT_ASSOCIATED);	
			}//tax type 
		}             		
	}//bank account empty return empty bankinstructions list
	return GETCURRENTHIGHESTSEVERITY();
}

//*******************************************************************************
bool Trade::isSEGFund ( const DString& fundCode)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "isSEGFund" ) );
   bool bIsSEGFund = false;
   FundMasterList *pFundMasterList = NULL;

   if ( !fundCode.empty() && 
         getMgmtCo().getFundMasterList (pFundMasterList) && 
         NULL != pFundMasterList )
   {
      if (pFundMasterList->isSEGFund(fundCode))
      {
         bIsSEGFund = true;
      }
   }

   return bIsSEGFund;
}

//******************************************************************************
SEVERITY Trade::validateFromSegTradeEntryCheck(const DString& accountNum,
                                               const DString& fundCode,
                                               const DString& classCode,
                                               const DString& tradeDate,
                                               const DString& transType,
                                               const DString& transId,
                                               const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFromSegTradeEntryCheck"));

   if( isSEGFund (fundCode))
   {
      SEGTradeEntryValidation validationObj(*this);

      if( validationObj.init(accountNum,
                             fundCode,
                             classCode,
                             NULL_STRING, // account to
                             NULL_STRING, // fund to
                             NULL_STRING, // class to
                             tradeDate,
                             I_("TradeDate"),
                             transType,
                             transId) <= WARNING )
      {
         DString strErrorCode;
         validationObj.getField(ifds::WarnCode, strErrorCode, idDataGroup, false);
         strErrorCode.strip().upperCase();

         switch( strErrorCode.asInteger())
         {
            case 1214:
            {
               DString strIDI,
                  strDateFormat,
                  strWarnValue1,
                  strWarnValue2;
               validationObj.getField(ifds::WarnValue1, strWarnValue1, idDataGroup, false);
               validationObj.getField(ifds::WarnValue2, strWarnValue2, idDataGroup, false);
               strWarnValue2.lowerCase();
               DSTCommonFunctions::FormatDateByString (strWarnValue1, strWarnValue2);
               addIDITagValue( strIDI, I_( "TRADE_DATE" ), strWarnValue1 );
               getErrMsg ( IFASTERR::TRADE_NOT_ALLOWED_TO_CANCEL,
                           CND::ERR_TRADE_NOT_ALLOWED_TO_CANCEL, 
                           CND::WARN_TRADE_NOT_ALLOWED_TO_CANCEL, 
                           idDataGroup,
                           strIDI);
            }
               break;
            case 1215:
            {
               getErrMsg ( IFASTERR::BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE,
                           CND::ERR_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE, 
                           CND::WARN_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE, 
                           idDataGroup);
            }
               break;
            case 1216:
            {
               getErrMsg ( IFASTERR::BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA,
                           CND::ERR_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA, 
                           CND::WARN_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA, 
                           idDataGroup);
            }
               break;
            case 1289:
            {
               getErrMsg ( IFASTERR::FIRST_TRADE_MUST_BE_TRANSFER,
                           CND::ERR_FIRST_TRADE_MUST_BE_TRANSFER, 
                           CND::WARN_FIRST_TRADE_MUST_BE_TRANSFER, 
                           idDataGroup);
            }
               break;
            default:
               break;
         }
      }

      if( validationObj.init(accountNum,
                             fundCode,
                             classCode,
                             NULL_STRING, // account to
                             NULL_STRING, // fund to
                             NULL_STRING, // class to
                             tradeDate,
                             I_("Fund"),
                             transType,
                             transId) <= WARNING )
      {
         DString strErrorCode;
         validationObj.getField(ifds::WarnCode, strErrorCode, idDataGroup, false);
         strErrorCode.strip().upperCase();

         switch( strErrorCode.asInteger())
         {
            case 1213:
            {
               DString strIDI,
                  strWarnValue1,
                  strWarnValue2;
               validationObj.getField(ifds::WarnValue1, strWarnValue1, idDataGroup, false);
               validationObj.getField(ifds::WarnValue2, strWarnValue2, idDataGroup, false);
               addIDITagValue( strIDI, I_( "CONTRACT_TYPE" ), strWarnValue1 );
               addIDITagValue( strIDI, I_( "CONTRACT_VERSION" ), strWarnValue2 );
               getErrMsg ( IFASTERR::CONTRACT_TYPE_AND_VERSION_REQUIRED,
                           CND::ERR_CONTRACT_TYPE_AND_VERSION_REQUIRED, 
                           CND::WARN_CONTRACT_TYPE_AND_VERSION_REQUIRED, 
                           idDataGroup,
                           strIDI);
            }
               break;
            case 1221:
            {
               getErrMsg ( IFASTERR::FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT,
                           CND::ERR_FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT, 
                           CND::WARN_FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT, 
                           idDataGroup);
            }
               break;
            case 1252:
            {
               getErrMsg ( IFASTERR::VARIABLE_DSC_FEE_AMOUNT,
                           CND::ERR_VARIABLE_DSC_FEE_AMOUNT, 
                           CND::WARN_VARIABLE_DSC_FEE_AMOUNT, 
                           idDataGroup);
            }
               break;
            default:
               break;
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateFromToSegTradeEntryCheck(const DString& accountNum,
                                                 const DString& fundCode,
                                                 const DString& classCode,
                                                 const DString& accountTo,
                                                 const DString& fundTo,
                                                 const DString& classTo,
                                                 const DString& tradeDate,
                                                 const DString& transType,
                                                 const DString& transId,
                                                 const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateFromToSegTradeEntryCheck"));

   if( isSEGFund (fundCode) || isSEGFund (fundTo))
   {
      SEGTradeEntryValidation validationObj(*this);

      if( validationObj.init(accountNum,
                             fundCode,
                             classCode,
                             accountTo, // account to
                             fundTo, // fund to
                             classTo, // class to
                             tradeDate,
                             I_("TradeDate"),
                             transType,
                             transId) <= WARNING )
      {
         DString strErrorCode;
         validationObj.getField(ifds::WarnCode, strErrorCode, idDataGroup, false);
         strErrorCode.strip().upperCase();

         switch( strErrorCode.asInteger())
         {
            case 1214:
            {
               DString strIDI,
                  strDateFormat,
                  strWarnValue1,
                  strWarnValue2;
               validationObj.getField(ifds::WarnValue1, strWarnValue1, idDataGroup, false);
               validationObj.getField(ifds::WarnValue2, strWarnValue2, idDataGroup, false);
               strWarnValue2.lowerCase();
               DSTCommonFunctions::FormatDateByString (strWarnValue1, strWarnValue2);
               addIDITagValue( strIDI, I_( "TRADE_DATE" ), strWarnValue1 );
               getErrMsg ( IFASTERR::TRADE_NOT_ALLOWED_TO_CANCEL,
                           CND::ERR_TRADE_NOT_ALLOWED_TO_CANCEL, 
                           CND::WARN_TRADE_NOT_ALLOWED_TO_CANCEL, 
                           idDataGroup,
                           strIDI);
            }
               break;
            case 1215:
            {
               getErrMsg ( IFASTERR::BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE,
                           CND::ERR_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE, 
                           CND::WARN_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LE, 
                           idDataGroup);
            }
               break;
            case 1216:
            {
               getErrMsg ( IFASTERR::BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA,
                           CND::ERR_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA, 
                           CND::WARN_BACK_DATE_TRADE_NOT_ALLOWED_BEFORE_LWA, 
                           idDataGroup);
            }
               break;
            case 1229:
            {
               getErrMsg ( IFASTERR::LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE,
                           CND::ERR_LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE, 
                           CND::WARN_LWA_ELECTION_DATE_LATER_THAN_TRANSFER_DATE, 
                           idDataGroup);
            }
               break;
            case 1289:
            {
               getErrMsg ( IFASTERR::FIRST_TRADE_MUST_BE_TRANSFER,
                           CND::ERR_FIRST_TRADE_MUST_BE_TRANSFER, 
                           CND::WARN_FIRST_TRADE_MUST_BE_TRANSFER, 
                           idDataGroup);
            }
               break;
            default:
               break;
         }
      }

      if( validationObj.init(accountNum,
                             fundCode,
                             classCode,
                             accountTo, // account to
                             fundTo, // fund to
                             classTo, // class to
                             tradeDate,
                             I_("Fund"),
                             transType,
                             transId) <= WARNING )
      {
         DString strErrorCode;
         validationObj.getField(ifds::WarnCode, strErrorCode, idDataGroup, false);
         strErrorCode.strip().upperCase();

         switch( strErrorCode.asInteger())
         {
            case 1213:
            {
               DString strIDI,
                  strWarnValue1,
                  strWarnValue2;
               validationObj.getField(ifds::WarnValue1, strWarnValue1, idDataGroup, false);
               validationObj.getField(ifds::WarnValue2, strWarnValue2, idDataGroup, false);
               addIDITagValue( strIDI, I_( "CONTRACT_TYPE" ), strWarnValue1 );
               addIDITagValue( strIDI, I_( "CONTRACT_VERSION" ), strWarnValue2 );
               getErrMsg ( IFASTERR::CONTRACT_TYPE_AND_VERSION_REQUIRED,
                           CND::ERR_CONTRACT_TYPE_AND_VERSION_REQUIRED, 
                           CND::WARN_CONTRACT_TYPE_AND_VERSION_REQUIRED, 
                           idDataGroup,
                           strIDI);
            }
               break;
            case 1221:
            {
               getErrMsg ( IFASTERR::FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT,
                           CND::ERR_FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT, 
                           CND::WARN_FUND_CLASS_NOT_ALLOWED_UNDER_ACCOUNT, 
                           idDataGroup);
            }
               break;
            default:
               break;
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateAllSegTransfer(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateAllSegTransfer"));

   DString dstrGuaranteeCalcByRules;
   getWorkSession().getOption (ifds::GuaranteeCalcByRules, 
                               dstrGuaranteeCalcByRules, 
                               idDataGroup, 
                               false);

   if( dstrGuaranteeCalcByRules.strip().upperCase() == I_("Y") /*&&
       isGuaranteeFeeOverrideAllowed(idDataGroup)*/)
   {
      DString fundCode, toFundCode, classCode, toClassCode, transType, transId;
      DString accountNum, toAccountNum, tradeDate;

      getField (ifds::AccountNum, accountNum, idDataGroup, false);
      getField (ifds::FromFund, fundCode, idDataGroup, false );
      getField (ifds::FromClass, classCode, idDataGroup, false);
      getField (ifds::TradesTransType, transType, idDataGroup, false);
      getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
      getField (ifds::TransId, transId, idDataGroup, false );
      fundCode.strip().upperCase();
      classCode.strip().upperCase();
      transType.strip().upperCase();
      accountNum.strip().upperCase();
      tradeDate.strip().upperCase();
      transId.strip().upperCase();

      SEGTradeEntryValidation validationObj(*this);

      if (hasAllocations (idDataGroup))
      {
         TradeFundAllocList *pTradeFundAllocList = NULL;

         if (getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING &&pTradeFundAllocList)
         {
            TradeFundAlloc *pTradeFundAlloc = NULL;

            BFObjIter iter (*pTradeFundAllocList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

            while (!iter.end ()) 
            {
               pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());

               if (pTradeFundAlloc)
               {
                  pTradeFundAlloc->getField (ifds::FundCode, fundCode, idDataGroup);
                  pTradeFundAlloc->getField (ifds::ClassCode, classCode, idDataGroup);
                  fundCode.strip().upperCase();
                  classCode.strip().upperCase();

                  if( validationObj.init(accountNum,
                                         fundCode,
                                         classCode,
                                         NULL_STRING, // account to
                                         NULL_STRING, // fund to
                                         NULL_STRING, // class to
                                         tradeDate,
                                         I_("All"),
                                         transType,
                                         transId) <= WARNING )
                  {
                     DString strErrorCode;
                     validationObj.getField(ifds::WarnCode, strErrorCode, idDataGroup, false);
                     strErrorCode.strip().upperCase();

                     switch( strErrorCode.asInteger())
                     {
                        case 1019:
                        {
                           getErrMsg ( IFASTERR::LWA_OPTION_NOT_MATCH,
                                       CND::ERR_LWA_OPTION_NOT_MATCH, 
                                       CND::WARN_LWA_OPTION_NOT_MATCH, 
                                       idDataGroup);
                        }
                           break;
                        case 1086:
                        {
                           getErrMsg ( IFASTERR::ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME,
                                       CND::ERR_ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME, 
                                       CND::WARN_ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME, 
                                       idDataGroup);
                        }
                           break;
                        case 1224:
                        {
                           getErrMsg ( IFASTERR::TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED,
                                       CND::ERR_TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED, 
                                       CND::WARN_TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED, 
                                       idDataGroup);
                        }
                           break;
                        case 1225:
                        {
                           getErrMsg ( IFASTERR::LWA_AGE_RATE_IS_NOT_APPLICABLE,
                                       CND::ERR_LWA_AGE_RATE_IS_NOT_APPLICABLE, 
                                       CND::WARN_LWA_AGE_RATE_IS_NOT_APPLICABLE, 
                                       idDataGroup);
                        }
                           break;
                        case 1230:
                        {
                           getErrMsg ( IFASTERR::USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM,
                                       CND::ERR_USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM, 
                                       CND::WARN_USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM, 
                                       idDataGroup);
                        }
                           break;
						case 1904:
						{
							getErrMsg ( IFASTERR::SEG_EVENT_DURING_CREATE_TRADE,
										CND::ERR_SEG_EVENT_DURING_CREATE_TRADE,
										CND::WARN_SEG_EVENT_DURING_CREATE_TRADE,
										idDataGroup);
						}
					       break;
                        default:
                           break;
                     }
                  }

               }
               ++iter;
            }
         }
      }
      else
      {
         if( validationObj.init(accountNum,
                                fundCode,
                                classCode,
                                NULL_STRING, // account to
                                NULL_STRING, // fund to
                                NULL_STRING, // class to
                                tradeDate,
                                I_("All"),
                                transType,
                                transId) <= WARNING )
         {
            DString strErrorCode;
            validationObj.getField(ifds::WarnCode, strErrorCode, idDataGroup, false);
            strErrorCode.strip().upperCase();

            switch( strErrorCode.asInteger())
            {
               case 1019:
               {
                  getErrMsg ( IFASTERR::LWA_OPTION_NOT_MATCH,
                              CND::ERR_LWA_OPTION_NOT_MATCH, 
                              CND::WARN_LWA_OPTION_NOT_MATCH, 
                              idDataGroup);
               }
                  break;
               case 1086:
               {
                  getErrMsg ( IFASTERR::ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME,
                              CND::ERR_ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME, 
                              CND::WARN_ELECTION_LWA_AGE_RATE_ALLOWED_ONLY_LWA_RATES_ARE_THE_SAME, 
                              idDataGroup);
               }
                  break;
               case 1224:
               {
                  getErrMsg ( IFASTERR::TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED,
                              CND::ERR_TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED, 
                              CND::WARN_TRX_TIERED_AND_NON_TIERED_ACCOUNT_NOT_ALLOWED, 
                              idDataGroup);
               }
                  break;
               case 1225:
               {
                  getErrMsg ( IFASTERR::LWA_AGE_RATE_IS_NOT_APPLICABLE,
                              CND::ERR_LWA_AGE_RATE_IS_NOT_APPLICABLE, 
                              CND::WARN_LWA_AGE_RATE_IS_NOT_APPLICABLE, 
                              idDataGroup);
               }
                  break;
               case 1230:
               {
                  getErrMsg ( IFASTERR::USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM,
                              CND::ERR_USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM, 
                              CND::WARN_USER_DEFINED_MATURITY_DATE_LESS_THAN_MIN_TERM, 
                              idDataGroup);
               }
                  break;
               case 1904:
               {
                  getErrMsg ( IFASTERR::SEG_EVENT_DURING_CREATE_TRADE,
                              CND::ERR_SEG_EVENT_DURING_CREATE_TRADE,
                              CND::WARN_SEG_EVENT_DURING_CREATE_TRADE,
                              idDataGroup);
               }
                  break;
               default:
                  break;
            }
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::validateSlsRepIA(const BFDataGroupId &idDataGroup)
{  //P0186486FN09 - Employee and Agent Account Gap#8A
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
                          CLASSNAME, 
                          I_("validateSlsRepIA"));

   MFAccount *pMFAccount = NULL;
   DString accountNum;

   getField (ifds::AccountNum, accountNum, idDataGroup, false);
   if (getWorkSession().getMFAccount (idDataGroup, accountNum, pMFAccount) <= WARNING &&		    
	   pMFAccount)
   {
	   Shareholder *pShareholder = NULL;
	   DString shrNum;

	   pMFAccount->getField (ifds::ShrNum, shrNum, idDataGroup);
	   if (getWorkSession ().getShareholder (idDataGroup, shrNum, pShareholder) <= WARNING &&
		   pShareholder) 
	   {
		   DString acctDesignation,
			   slsrepcode,
			   slsrepcodePre,
			   fundRelCodePre;

		   pShareholder->getField (ifds::FundRelnCode, fundRelCodePre, idDataGroup);
		   fundRelCodePre.strip();

		   pMFAccount->getField (ifds::AcctDesignation, acctDesignation, idDataGroup);
		   pMFAccount->getField ( ifds::Slsrep, slsrepcodePre, idDataGroup );
		   getField (ifds::SlsrepCode, slsrepcode, idDataGroup, false);
		   
		   slsrepcode.strip().upperCase();
		   slsrepcodePre.strip().upperCase();

		   if(slsrepcode != slsrepcodePre )
		   {
			   if(acctDesignation == CLIENT && 
				   (fundRelCodePre == EMPLOYEE || fundRelCodePre == AGENT))
			   {
				   DString strIDI;
				   if(fundRelCodePre == EMPLOYEE)
				   {
					   addIDITagValue( strIDI, I_("ACCOUNT_TYPE"), I_("Employee") );
				   }
				   else
				   {
					   addIDITagValue( strIDI, I_("ACCOUNT_TYPE"), I_("Agent") );
				   }

				   getErrMsg ( IFASTERR::CHANGE_REPS_IS_NOT_APPLICABLE,
					   CND::ERR_CHANGE_REPS_IS_NOT_APPLICABLE, 
					   CND::WARN_CHANGE_REPS_IS_NOT_APPLICABLE, 
					   idDataGroup,
					   strIDI);
			   }
		   }

	   }

   }

   
   return GETCURRENTHIGHESTSEVERITY();
}

//*******************************************************************************
void Trade::getFundCategory ( const DString& fundCode, DString& fundCategory)
{//P0186486FN09 - Employee and Agent Account Gap#8A  
  fundCategory = NULL_STRING;
   FundMasterList *pFundMasterList = NULL;

   if ( !fundCode.empty() && 
         getMgmtCo().getFundMasterList (pFundMasterList) && 
         NULL != pFundMasterList )
   {
      fundCategory = pFundMasterList->getFundCategory(fundCode);
   }
}

//******************************************************************************
bool Trade::isGuaranteeFeeOverrideAllowed (const BFDataGroupId &idDataGroup)
{
//overriden in Transfers
   return false;
}

//******************************************************************************
SEVERITY Trade::updateGuaranteeFeeOverride (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("updateGuaranteeFeeOverride"));

   bool bIsGuaranteeFeeOverrideAllowed  = isGuaranteeFeeOverrideAllowed (idDataGroup);

   if (!_bInitPending)
   {
      setFieldNoValidate (ifds::GuaranteesOverride, NULL_STRING, idDataGroup, false);
   }
   
   setFieldReadOnly (ifds::GuaranteesOverride, idDataGroup, !bIsGuaranteeFeeOverrideAllowed);
   setFieldValid (ifds::GuaranteesOverride, idDataGroup, !bIsGuaranteeFeeOverrideAllowed);
   setFieldRequired (ifds::GuaranteesOverride, idDataGroup, bIsGuaranteeFeeOverrideAllowed);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
void Trade::ValidateSourceOfAcct(const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "ValidateSourceOfAcct" ) );

   //P0186486_FN15_The Source of Funds
   DString srcOfFund;
   getField(ifds::SrcOfFund, srcOfFund, idDataGroup, false); 
   srcOfFund.stripAll().upperCase();

   if(!srcOfFund.empty())
   {
      //if not read-only it shouldn't be blank
      BFProperties * pBFProperties = NULL;
      pBFProperties = getFieldProperties( ifds::BankSrcAcct, idDataGroup );
      if( pBFProperties )
      {
         if( !pBFProperties->isReadOnly() )
         {
            if(getWorkSession ().isSrcOfFundRequired(srcOfFund, idDataGroup))
            {
               DString srcOfAccount;
               getField(ifds::SrcOfAccount, srcOfAccount, idDataGroup, false); 
               if(srcOfAccount.empty())
               {
                  getErrMsg (IFASTERR::REFERENCE_NO_IS_MANDATORY_FOR_SOURCE_OF_FUND, 
                             CND::ERR_REFERENCE_NO_IS_MANDATORY_FOR_SOURCE_OF_FUND, 
                             CND::WARN_REFERENCE_NO_IS_MANDATORY_FOR_SOURCE_OF_FUND, 
                             idDataGroup);
               }
            }

         }
      }
   }
}

//******************************************************************************
void Trade::loadRDRAdviceSubstList(const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "loadRDRAdviceSubstList" ) );
   
   DString RDRAdviceSubstList;
   BFProperties *pBFProperties = 
      getFieldProperties (ifds::RDRAdvice, idDataGroup);

   assert (pBFProperties);
   if (pBFProperties)
   {
      pBFProperties->getAllSubstituteValues (RDRAdviceSubstList);
      RDRAdviceSubstList = removeItemFromSubtList ( RDRAdviceSubstList, I_("00"));
   }
   setFieldAllSubstituteValues (ifds::RDRAdvice, idDataGroup, RDRAdviceSubstList);  
}

//******************************************************************************
DString Trade::getRDRAdviceFlag(const DString &transType, const DString &account,const DString &fundCode,
                                const DString &classCode,const DString &tradeDate,const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "getRDRAdviceFlag" ) );

   DString dstrRDRAdviceFlag = NULL_STRING,
      dstrRDRApplic	 = NULL_STRING,
      dstrRDRDefault    = NULL_STRING;

   if (!fundCode.empty() && !classCode.empty())
   {
      DString broker, branch, slsrep,accountNum;

      //getField (ifds::AccountNum, accountNum, idDataGroup, false);
      getField (ifds::Broker, broker, idDataGroup, false);
      getField (ifds::Branch, branch, idDataGroup, false);
      getField (ifds::SlsrepCode, slsrep, idDataGroup, false);

      RDRAdvice rdrAdvice(*this);
      SEVERITY sevRtn = rdrAdvice.init(account, 
                                       fundCode, 
                                       classCode, 
                                       transType, 
                                       tradeDate, 
                                       broker, 
                                       branch,
                                       slsrep);

      if( sevRtn <= WARNING )
      {
         rdrAdvice.getField(ifds::RDRApplic, dstrRDRApplic, idDataGroup, false);
         rdrAdvice.getField(ifds::RDRDefault,dstrRDRDefault,idDataGroup, false);
      }
      if( dstrRDRApplic == I_("00") || dstrRDRApplic == I_("01") )
      {
         dstrRDRAdviceFlag = I_("00"); // N/A
      }
      else if ( dstrRDRApplic == I_("02") && dstrRDRDefault == I_("02"))
      {
         dstrRDRAdviceFlag = I_("02"); // Provided
      }
      else if ( dstrRDRApplic == I_("02") && dstrRDRDefault == I_("01"))
      {
         dstrRDRAdviceFlag = I_("01"); //Not provided
      }
   }
   return dstrRDRAdviceFlag;   
}

//******************************************************************************
SEVERITY Trade::setRDRAdviceFlag(const DString &transType, const DString &account,const DString &fundCode,
                                 const DString &classCode,const DString &tradeDate,const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "setRDRAdviceFlag" ) );
   
   DString dstrRDREnv = NULL_STRING;

   getWorkSession().getOption ( ifds::RDREnv,dstrRDREnv,idDataGroup,false);
   if( dstrRDREnv == I_("Y") )
   {
      _strRDRAdviceFlag = getRDRAdviceFlag(transType,
                                           account,
                                           fundCode,
                                           classCode,
										   tradeDate,
                                           idDataGroup);
      if( !_strRDRAdviceFlag.empty())
      {
         setFieldNoValidate (ifds::RDRAdvice, _strRDRAdviceFlag, idDataGroup, false); 
         setFieldReadOnly (ifds::RDRAdvice, idDataGroup,_strRDRAdviceFlag == I_("00"));
         if( _strRDRAdviceFlag != I_("00") )
         {
            loadRDRAdviceSubstList(idDataGroup);	
         }
      }
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::RDRAdviceRelatedChanges (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("RDRAdviceRelatedChanges"));
   
   //Overridden in Purchase/Transfer/Exchange
   
   return GETCURRENTHIGHESTSEVERITY();
}

/******************************************************************************
Input:DataGroupID
OutPut:DString with traderoutingtype list
Return:Severity
Functionality:Returns the valid list for tradelevel routing over-ride
******************************************************************************/
SEVERITY Trade::buildPaymentRoutingSet(const BFDataGroupId &idDataGroup,DString &outdstrpymtLevelRoutingSet)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("buildPaymentRoutingSet"));

   DString dstrTradelevelOveride,dstrPymtRoutingMthd,dstrPymtRoutingMthdSet;
   getWorkSession ().getOption (ifds::TradelevelOveride, dstrTradelevelOveride, BF::HOST, false); 
   getWorkSession ().getOption (ifds::PymtRoutingMthd, dstrPymtRoutingMthd, BF::HOST, false); 
   BFProperties *pBFProperties=
      getFieldProperties (ifds::PymtRoutingMthd, idDataGroup); 
    assert (pBFProperties);
    if (pBFProperties)
    {
      pBFProperties->getAllSubstituteValues (dstrPymtRoutingMthdSet);
    } 
    outdstrpymtLevelRoutingSet.stripAll();
    dstrPymtRoutingMthdSet.stripAll();
    if(	dstrTradelevelOveride != YES || 
       dstrPymtRoutingMthd.empty()  ||
       dstrPymtRoutingMthdSet.empty() )
    {
       outdstrpymtLevelRoutingSet = NULL_STRING;
       outdstrpymtLevelRoutingSet.stripAll();
       return GETCURRENTHIGHESTSEVERITY();
    }
    I_CHAR *temp = const_cast<I_CHAR*> (dstrPymtRoutingMthdSet.c_str ());
    do
    {
       DString dstrPymtRoutingMthdSetCode,dstrPymtRoutingMthdSetDescr;   
       temp = parseIdiString (temp, dstrPymtRoutingMthdSetCode, dstrPymtRoutingMthdSetDescr);
       if (isCodeInList (dstrPymtRoutingMthdSetCode,dstrPymtRoutingMthd))
       {
          outdstrpymtLevelRoutingSet += dstrPymtRoutingMthdSetCode + I_("=") + 
                                        dstrPymtRoutingMthdSetDescr + I_(";");
       }
    } while (temp && temp != NULL_STRING && *temp);

    return GETCURRENTHIGHESTSEVERITY();
}

/******************************************************************************
Input:DataGroupID
OutPut:None
Return:Severity
Functionality:Sets the default value for the TradeLevelRouting
******************************************************************************/
SEVERITY Trade::setPaymentRoutingSetDefault( const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION,CLASSNAME, I_("setPaymentRoutingSetDefault"));
   DString dstrAccountNum; 
   getField (ifds::AccountNum, dstrAccountNum, idDataGroup);
   MFAccount *pMFAccount = NULL; 
   if ( getWorkSession ().getMFAccount ( idDataGroup, dstrAccountNum, 
                                          pMFAccount ) <= WARNING && NULL != pMFAccount)
   {
      DString dstrAcctType; 
      AcctCategoryList *pAcctCategoryList = NULL;
      if ( pMFAccount->getAcctCategoryList( pAcctCategoryList, 
         idDataGroup ) <= WARNING &&
         NULL != pAcctCategoryList )
      {
         DString dstrDefaultPymtRoutingMthd = NULL_STRING;
         BFObjIter iter (*pAcctCategoryList, idDataGroup);
         while (!iter.end ())
         {
            DString acctCategory;                     
            iter.getObject ()->getField (ifds::AcctCategory, acctCategory, idDataGroup, false);
            if (acctCategory == SWIFT_PAYMENT_METHOD)
            {
               iter.getObject ()->getField(ifds::CatValue, dstrDefaultPymtRoutingMthd, idDataGroup, false) ;
               break;
            }
            ++iter;
         }
         dstrDefaultPymtRoutingMthd.stripAll();
         if(dstrDefaultPymtRoutingMthd.empty())
         {
            pMFAccount->getField(ifds::AcctType, dstrAcctType, idDataGroup, false) ;

            if (isCodeInList(dstrAcctType,ACCOUNT_TYPE::INDIVIDUAL_ACCT_LIKE))
            {
               dstrDefaultPymtRoutingMthd = PAYMENT_ROUTING::MT103;
            }
            else if (isCodeInList(dstrAcctType,ACCOUNT_TYPE::CORPORATE_ACCT_LIKE))
            {
               dstrDefaultPymtRoutingMthd = PAYMENT_ROUTING::MT202;
            }
            else
            {
               //what other acount types do we have?
               assert (0);
            }
         }
         setFieldNoValidate (ifds::PymtRoutingMthd, dstrDefaultPymtRoutingMthd, 
            idDataGroup, false, true, true);
      }

   }
   return GETCURRENTHIGHESTSEVERITY(); 
}

//******************************************************************************
SEVERITY Trade::setGIDIFTradePayType (const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setGIDIFTradePayType"));

   //Overridden in Redemption

   return GETCURRENTHIGHESTSEVERITY();
}

/******************************************************************************
 Input: idDataGroup
 OutPut:None
 Return:bool
 Functionality:returns true if EventReceiptDate & EventReciptTime is Applicable. 
 ******************************************************************************/
bool Trade::bIsEventReceiptDateTimeAppl(const BFDataGroupId &idDataGroup)
{
   DString dstrTransType,dstrUCITSEnv;
   bool bEventReceiptDateTimeAppl   = false;
   getWorkSession().getOption(ifds::UCITFlag, dstrUCITSEnv, idDataGroup, false );
   getField(ifds::TransType, dstrTransType, idDataGroup, false);
   dstrTransType.strip().upperCase();
   bEventReceiptDateTimeAppl =  (( dstrUCITSEnv == YES) && 
                                 ( isPurchaseLike  (idDataGroup) || 
                                 isRedemptionLike(idDataGroup) ||
                                 isExchangeLike  (idDataGroup) ));
   return   bEventReceiptDateTimeAppl;
}

//******************************************************************************
bool Trade::isSEGPortfolio (const BFDataGroupId &idDataGroup)
{
   bool bIsSEGPortfolio  = false;

   DString accountNum;
   MFAccount *pMFAccount = NULL;

   getField (ifds::AccountNum, accountNum, idDataGroup, false );

   
   if(getWorkSession().getMFAccount ( idDataGroup, 
                                      accountNum, 
                                      pMFAccount ) <= WARNING && 
      pMFAccount)
   {
      bIsSEGPortfolio = pMFAccount->hasSegFundsWithinPortfolio(idDataGroup);
   }

   if(!bIsSEGPortfolio && !isOneSideTrade(idDataGroup))
   {
      getField (ifds::AccountTo, accountNum, idDataGroup, false );
      accountNum.strip().stripLeading ('0');

      if(getWorkSession().getMFAccount ( idDataGroup, 
                                         accountNum, 
                                         pMFAccount ) <= WARNING && 
         pMFAccount)
      {
         bIsSEGPortfolio = pMFAccount->hasSegFundsWithinPortfolio(idDataGroup);
      }
   }

   return bIsSEGPortfolio;
}
/******************************************************************************
InPut :	BFDataGroupId &idDataGroup
Out :   None
Return:Severity 
Functionality: Check if the Deposit code and Redemption code for Unit conversionTrade 
			   is valid
******************************************************************************/
SEVERITY Trade::validateRedCodeDepTypeUCTrade(const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateRedCodeDepTypeUCTrade"));
	DString dstrRedCode, dstrDepositType; 		 
	getField (ifds::RedCode, dstrRedCode, idDataGroup, false);
	getField (ifds::DepositType, dstrDepositType, idDataGroup, false);
	if( REDEMPTION_CODE_UC == dstrRedCode  || DEPOSIT_CODE_UC == dstrDepositType )
	{
		DString idiStr;
        addIDITagValue (idiStr, I_("DEP_CODE"), dstrDepositType);
		addIDITagValue (idiStr, I_("RED_CODE"), dstrRedCode);
	    ADDCONDITIONFROMFILEIDI (CND::ERR_REDEMPTION_DEPOSIT_CODE_NOT_VALID,idiStr);
	}
	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::getContractTypeAndVersion ( const BFDataGroupId &idDataGroup,
										const DString &dstrAccountNum,	
										DString &dstrContractType, 
										DString &dstrContractVer)
{	
	//overriden in Transfers
	return (false);
}

//******************************************************************************
SEVERITY Trade::applyTransFeeRateToAllocation(const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("applyTransFeeRateToAllocation"));

   TransFeeList* pTransFeeList = NULL;

   getTransFeeList (pTransFeeList, BF::HOST); 
   if(pTransFeeList)
      pTransFeeList->applyTransFeeRateToAllocation(idDataGroup);

   return GETCURRENTHIGHESTSEVERITY();
}
/******************************************************************************
Input:Field ID ,DataGroupID
OutPut:Empty
Return:Severity
Functionality:Default all the field values with the configurtion matrix
******************************************************************************/
void Trade::populateFieldsWithDefaultValues(const BFDataGroupId &idDataGroup, const long &lMod)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("populateFieldsWithDefaultValues"));

   DefaultSysConfigDetailList* pDefaultSysConfigDetailList = NULL;
   getMgmtCo().getDefaultSysConfigDetailList(pDefaultSysConfigDetailList); 
   if(pDefaultSysConfigDetailList)
   {
	 //BFFieldId idField = ifds::NullFieldId;
	 bool bformattedReturn = false ; 
	 DString dstrDefValue; 
	 for (int i = 0; i<_numFieldDefaultRule; i++)
	 {
	    DString dstrKeyField1, dstrKeyField2, dstrKeyField3, dstrKeyField4, dstrKeyField5;
		//get the default from the matrix and set it
		getField(m_FieldDefaultRule[i]._KeyFld1, dstrKeyField1, idDataGroup, false);
		getField(m_FieldDefaultRule[i]._KeyFld2, dstrKeyField2, idDataGroup, false);
		getField(m_FieldDefaultRule[i]._KeyFld3, dstrKeyField3, idDataGroup, false);
		getField(m_FieldDefaultRule[i]._KeyFld4, dstrKeyField4, idDataGroup, false);
		getField(m_FieldDefaultRule[i]._KeyFld5, dstrKeyField5, idDataGroup, false);

		if( m_FieldDefaultRule[i].getModAppl(lMod))
		{
			pDefaultSysConfigDetailList->getFieldDefaultValue( m_FieldDefaultRule[i]._FieldID , idDataGroup, dstrDefValue, bformattedReturn,
															   dstrKeyField1, dstrKeyField2, dstrKeyField3, dstrKeyField4, dstrKeyField5);
		    setFieldNoValidate(m_FieldDefaultRule[i]._FieldID, dstrDefValue, idDataGroup, bformattedReturn, false, true);
			
		} 
	 }
   }
}
/******************************************************************************
Input:Field ID ,DataGroupID
OutPut:Empty
Return:Severity
Functionality:Default the field values with the configurtion matrix
******************************************************************************/
void Trade::setFieldWithDefaultValue(const BFFieldId &idField,const BFDataGroupId &idDataGroup )
{
  MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("setFieldWithDefaultValue"));
   bool bformattedReturn = false ; 
   DString dstrDefValue;
   DefaultSysConfigDetailList* pDefaultSysConfigDetailList = NULL;
   getMgmtCo().getDefaultSysConfigDetailList(pDefaultSysConfigDetailList); 
   if(pDefaultSysConfigDetailList)
   {
	 for (int i = 0; i<_numFieldDefaultRule; i++)
	 {
		//get the default from the matrix and set it
		 if(m_FieldDefaultRule[i]._FieldID == idField )
		 {
			DString dstrKeyField1, dstrKeyField2, dstrKeyField3, dstrKeyField4, dstrKeyField5;
			getField(m_FieldDefaultRule[i]._KeyFld1, dstrKeyField1, idDataGroup, false);
			getField(m_FieldDefaultRule[i]._KeyFld2, dstrKeyField2, idDataGroup, false);
			getField(m_FieldDefaultRule[i]._KeyFld3, dstrKeyField3, idDataGroup, false);
			getField(m_FieldDefaultRule[i]._KeyFld4, dstrKeyField4, idDataGroup, false);
			getField(m_FieldDefaultRule[i]._KeyFld5, dstrKeyField5, idDataGroup, false);

			pDefaultSysConfigDetailList->getFieldDefaultValue( m_FieldDefaultRule[i]._FieldID , idDataGroup, dstrDefValue, bformattedReturn,
															   dstrKeyField1, dstrKeyField2, dstrKeyField3, dstrKeyField4, dstrKeyField5);
		    setFieldNoValidate(m_FieldDefaultRule[i]._FieldID, dstrDefValue, idDataGroup, bformattedReturn, false, true);
			break;
		}
	 }
   }	 
}

/******************************************************************************
Input:Field ID ,DataGroupID
OutPut:
Return:Severity
Functionality:Append a blank value to sub list
******************************************************************************/
SEVERITY Trade::addBlankToSubSet(const BFFieldId &idField ,const BFDataGroupId &idDataGroup, bool dstrUseNotApplicableAsDesc /*= false */ )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("addBlankToSubSet"));

   DString  dstrCurrSubList,dstrSubList;
   BFProperties *pBFProperties = getFieldProperties (idField, idDataGroup); 
   assert (pBFProperties);
   if (pBFProperties) 
   {
    pBFProperties->getAllSubstituteValues (dstrCurrSubList);
    DString dstrNotApplicableLangDesc;
    BFProperties *pBFPropertiesNotApplicable = getFieldProperties (ifds::NotApplicable, idDataGroup);
    pBFPropertiesNotApplicable->getDefaultValue(dstrNotApplicableLangDesc);
    pBFPropertiesNotApplicable->formatValue( ifds::NotApplicable,dstrNotApplicableLangDesc, true );
    dstrNotApplicableLangDesc = dstrUseNotApplicableAsDesc ? ( I_(" =") + dstrNotApplicableLangDesc + I_(";")): BLANK_SUBSTITUTION_VALUE;
    
    I_CHAR *temp = const_cast<I_CHAR*> (dstrCurrSubList.c_str ());
    bool blankNotAdded = true;
    do
    {
      DString dstrCode, dstrDescr;
      temp = parseIdiString (temp, dstrCode, dstrDescr );
      //if alreday in do not add again..
      if (dstrCode == I_(" "))
       {
           blankNotAdded = false;
           break;
       }
    }while (temp && temp != NULL_STRING && *temp);
    if(blankNotAdded)
    {
        dstrSubList = dstrNotApplicableLangDesc  + dstrCurrSubList;
        pBFProperties->setAllSubstituteValues( dstrSubList ); 
    }   
   }      
   return GETCURRENTHIGHESTSEVERITY();
}

/******************************************************************************
 Input: Fund,Class,TransType,dataGroup
 OutPut:FundLmtOverrideList
 Return:SEVERITY
 Functionality:Get a pointer to FundLmtOverrideList 
 ******************************************************************************/
SEVERITY Trade::getFundLmtOverrideList ( FundLmtOverrideList *&pFundLmtOverrideList,
										 const DString& dstrTransType,
										 const DString& dstrFundCode,
										 const DString& dstrClassCode,
										 const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
							CLASSNAME, 
							I_("getFundLmtOverrideList"));

	pFundLmtOverrideList = NULL;

	DString strKey;

	strKey = I_("FundLmtOverrideList");
	strKey += I_(";TransType=");
	strKey += dstrTransType;
	strKey += I_(";FundCode=");
	strKey += dstrFundCode;   
	strKey += I_(";ClassCode=");
	strKey += dstrClassCode;   
	pFundLmtOverrideList = 
		dynamic_cast<FundLmtOverrideList *>(BFCBO::getObject(strKey, idDataGroup));
   	if (!pFundLmtOverrideList && 
		!dstrFundCode.empty() && !dstrClassCode.empty())
	{
	  pFundLmtOverrideList = new FundLmtOverrideList (*this);
	  if (pFundLmtOverrideList->init (dstrFundCode, dstrClassCode, dstrTransType) <= WARNING)
		setObject (pFundLmtOverrideList, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
	   else
	   {
	     delete pFundLmtOverrideList;
		 pFundLmtOverrideList = NULL;
	   }
	}
	return GETCURRENTHIGHESTSEVERITY();
}
/******************************************************************************
 Input: dataGroup
 OutPut:None
 Return:SEVERITY
 Functionality:Base Functionality to handle the delivery Network chnages for all 
               trade.
               Populate
 ******************************************************************************/
SEVERITY Trade::deliveryNetworkRelatedChanges(const BFDataGroupId &idDataGroup)
{
    MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
							CLASSNAME, 
							I_("deliveryNetworkRelatedChanges"));

    DString dstrNetworkID;
    getField(ifds::NetworkID, dstrNetworkID, idDataGroup, false);
    setFieldReadOnly (ifds::DeliveryNetwork, idDataGroup, dstrNetworkID.stripAll().empty());
    if(dstrNetworkID.stripAll().empty())
       return GETCURRENTHIGHESTSEVERITY();
    NetworkConfigDetailList* pNetworkConfigDetailList = NULL;
    if( getMgmtCo().getNetworkConfigDetailList(pNetworkConfigDetailList)<= WARNING &&
        pNetworkConfigDetailList )
    {
      NetworkConfigDetail* pNetworkConfigDetail = NULL;
      DString dstrApplDeliveryNetworkList, dstrDefaultDeliveryNetwork;
      if(pNetworkConfigDetailList->getNetworkConfigDetail(dstrNetworkID, NETWORK_CONFIG_TYPE::DeliveryNetworkIDs,
                                                          pNetworkConfigDetail) && pNetworkConfigDetail)
      {
         pNetworkConfigDetail->getField(ifds::NetworkConfigValue, dstrApplDeliveryNetworkList, idDataGroup, false);
      }
      dstrApplDeliveryNetworkList.stripAll();
      setFieldReadOnly (ifds::DeliveryNetwork, idDataGroup, dstrApplDeliveryNetworkList.empty());
      setFieldRequired (ifds::DeliveryNetwork, idDataGroup, !dstrApplDeliveryNetworkList.empty());
      if(!_bRebook && !_bInitPending && isCodeInList( dstrNetworkID, dstrApplDeliveryNetworkList))
      {
        if( dstrApplDeliveryNetworkList.find(I_(",")) == DString::npos )
         setFieldNoValidate(ifds::DeliveryNetwork, dstrApplDeliveryNetworkList.stripAll(), idDataGroup, false);         
        else
         setFieldNoValidate(ifds::DeliveryNetwork, dstrNetworkID,idDataGroup,false);          
      } 
      loadSubstitutionList (ifds::DeliveryNetwork, idDataGroup, dstrApplDeliveryNetworkList);
    }
    setOtherConfirmTypeDefaultValues (idDataGroup);//this is now dependednt on the Delivery Network and not the network ID
    return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::getAdjustTransactionList( TransactionList* &pTransactionList, 
                                          const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE(CLASSNAME, I_("getAdjustTransactionList"));

   pTransactionList = dynamic_cast<TransactionList*>(getObject(I_("AdjustTransactionList"), idDataGroup));
   if(pTransactionList != nullptr) return GETCURRENTHIGHESTSEVERITY();

   DString dstrAdjTransNum;
   getField(ifds::AdjTransNum, dstrAdjTransNum, idDataGroup, false);

   dstrAdjTransNum.stripLeading(I_('0')).stripAll();

   if (dstrAdjTransNum.empty()) 
   {
      pTransactionList = nullptr;
      return GETCURRENTHIGHESTSEVERITY();
   }

   TradeSearchCriteria *pTradeSearchCriteria = new TradeSearchCriteria(*this);

   pTradeSearchCriteria->init();
   pTradeSearchCriteria->setField(ifds::TransNum, dstrAdjTransNum, idDataGroup);
   pTradeSearchCriteria->getTransactionList(pTransactionList, idDataGroup);

   if(pTransactionList) setObject(pTransactionList, I_("AdjustTransactionList"));

   return  GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY  Trade::validateSettleTypeSettleNetworkXEdit(const BFDataGroupId& idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE(CLASSNAME, I_("validateSettleTypeSettleNetworkXEdit"));

   DString dstrIsNetworkSettleEligible;
   DilutionAllocList *pDilutionAllocList = NULL;

   if(getDilutionAllocList(pDilutionAllocList, idDataGroup) <= WARNING &&
      pDilutionAllocList != NULL) 
   {
      pDilutionAllocList->refreshNSMEligibility(ifds::IsNetworkSettleEligible, idDataGroup);
      pDilutionAllocList->getField(ifds::IsNetworkSettleEligible, dstrIsNetworkSettleEligible, idDataGroup);
   }

   if(dstrIsNetworkSettleEligible != I_("Y")) return GETCURRENTHIGHESTSEVERITY();

   DString dstrSettleType, dstrSettleNetwork;
	getField(ifds::SettleType, dstrSettleType, idDataGroup);
	getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup);

	if(dstrSettleNetwork == I_("FSRV") && dstrSettleType == I_("I"))
	{
		getErrMsg (
			IFASTERR::SETTLE_TYPE_INDIVIDUAL_NOT_ALLOW_THROUGH_FUNDSERV, 
			CND::ERR_SETTLE_TYPE_INDIVIDUAL_NOT_ALLOW_THROUGH_FUNDSERV, 
			CND::WARN_SETTLE_TYPE_INDIVIDUAL_NOT_ALLOW_THROUGH_FUNDSERV, 
			idDataGroup);
	}
   else if(dstrSettleNetwork.empty() && dstrSettleType == I_("B"))
   {
      getErrMsg (
			IFASTERR::SETTLE_TYPE_BLOCK_NOT_ALLOW_NOT_THROUGH_FUNDSERV, 
			CND::ERR_SETTLE_TYPE_BLOCK_NOT_ALLOW_NOT_THROUGH_FUNDSERV, 
			CND::WARN_SETTLE_TYPE_BLOCK_NOT_ALLOW_NOT_THROUGH_FUNDSERV, 
			idDataGroup);
   }
	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateSettleSourceSettleNetworkXEdit(const BFDataGroupId& idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE(CLASSNAME, I_("validateSettleSrouceSettleNetworkXEdit"));

	TransactionList *pAdjTransactionList;
	  if(getAdjustTransactionList(pAdjTransactionList, idDataGroup)<=WARNING &&
		  pAdjTransactionList != NULL)
	  {
		  BFObjIter iter(*pAdjTransactionList, idDataGroup, BFObjIter::NON_DELETED);
		  
		  DString tradeDate, adjTradeDate;
		  getField(ifds::EffectiveDate, tradeDate, idDataGroup);
		  iter.getObject()->getField(ifds::EffectiveDate, adjTradeDate, idDataGroup);
		  if(tradeDate == adjTradeDate)
		  {
			  DString dstrSettleNetwork;
			  getField(ifds::SettleNetwork, dstrSettleNetwork, idDataGroup);
			  if(dstrSettleNetwork.stripAll().empty())
			  {
					getErrMsg (
						IFASTERR::SETTLE_NETWORK_APPLIED_TO_CANCELLATION_AND_REBOOK, 
						CND::ERR_SETTLE_NETWORK_APPLIED_TO_CANCELLATION_AND_REBOOK, 
						CND::WARN_SETTLE_NETWORK_APPLIED_TO_CANCELLATION_AND_REBOOK, 
						idDataGroup);
			  }
		  }
	  }

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getPurchasedUnits(DString& dstrUnits, const BFDataGroupId& idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE(CLASSNAME, I_("getPurchasedUnits"));

	DString dstrTransID;
	TransactionDetails *_pTransDetails = new TransactionDetails( *this );
	getField(ifds::TransId, dstrTransID, idDataGroup);

	if( WARNING >= _pTransDetails->getDetails(dstrTransID) )
	{
		_pTransDetails->getField(ifds::Units, dstrUnits, idDataGroup);
	}

	if(_pTransDetails)
		delete _pTransDetails;

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
DString Trade::getDivChqAddr(const BFDataGroupId &idDataGroup)
{
    DString dstrAccountNum, dstrDivChqAddr(I_("01"));

    getField(ifds::AccountNum, dstrAccountNum, idDataGroup, false);
    dstrAccountNum.stripLeading ('0').strip();

    if (!dstrAccountNum.empty())
    {
        MFAccount *pMFAccount = NULL;

        if (getWorkSession().getMFAccount(idDataGroup, dstrAccountNum, pMFAccount) <= WARNING && pMFAccount)
        {
            DString dstrShrNum;
            Shareholder *pShareholder = NULL;
            AccountMailingList *pAccountMailingList = NULL;

            pMFAccount->getField(ifds::ShrNum, dstrShrNum, idDataGroup, false);

            if (getWorkSession().getShareholder(idDataGroup, dstrShrNum, pShareholder) <= WARNING && pShareholder &&
                pShareholder->getAccountMailingList(pAccountMailingList, idDataGroup) <= WARNING && pAccountMailingList)
            {
                DString strKey;
                BFObjIter iter (*pAccountMailingList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

                pAccountMailingList->buildKey (strKey, dstrAccountNum);

                if (iter.positionByKey(strKey))
                {
                    iter.getObject()->getField(ifds::DivChqAddr, dstrDivChqAddr, idDataGroup, false);
                }             
            }
        }
    }

    return dstrDivChqAddr;
}
/******************************************************************************
 Input: Worksession, idataGroup
 OutPut:None
 Return:Bool
 Functionality:Return true if the StopOverrideRule function Control is active
               and the transtype is a valid one to make a call for the 462 view 
 ******************************************************************************/
bool Trade::isTradeLevelOverrideRuleApplicable( const DString dstrTransType, const BFDataGroupId &idDataGroup)
{
  DString dstrStopOverrideRule;
  bool bTransTypeApplicable = false;
  if ( isPurchaseLike(idDataGroup)   ||
       isRedemptionLike(idDataGroup) ||
       dstrTransType == TRADETYPE::EXCHANGE_IN  || dstrTransType == TRADETYPE::EXCHANGE_OUT ||
       dstrTransType == TRADETYPE::INTER_CLASS_SWITCH_IN  || dstrTransType == TRADETYPE::INTER_CLASS_SWITCH_OUT ||
       dstrTransType == TRADETYPE::TRANSFER_IN  || dstrTransType == TRADETYPE::TRANSFER_OUT )
  {
       bTransTypeApplicable = true;
  }
  if(bTransTypeApplicable)
  {
   getWorkSession().getOption(ifds::StopOverrideRule, dstrStopOverrideRule, idDataGroup, false );
  }      
  return ( bTransTypeApplicable &&
           YES == dstrStopOverrideRule );
}

//******************************************************************************
SEVERITY Trade::loadDilution(const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE(CLASSNAME, I_("loadDilution"));

   DilutionAllocList *pDilutionAllocList = nullptr;

   getDilutionAllocList (pDilutionAllocList, idDataGroup, true);
   //backdate reason, accountability field
   accountableBackdatedRelatedChanges (idDataGroup);

   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::hasNMCRContract( MFAccount *pMFAccount, 
							 DString &fundCode, 
							 DString &classCode, 
							 DString &dstrContractType,
							 DString &dstrContractVer,
							 const BFDataGroupId &idDataGroup)
{
	DString contractType, dstrNMCRContract; 
	bool bNMCRContract = false;

	FundDetail *pFundDetailFrom = NULL;
	if ( getWorkSession ().getFundDetail (fundCode, classCode, idDataGroup, pFundDetailFrom) && pFundDetailFrom )
	{
		pFundDetailFrom->getField (ifds::ContractType, contractType, idDataGroup, false);
		contractType.stripAll().upperCase();
	}

	ContractInfoList* pContractInfoList = NULL;   
	if( !contractType.empty() && pMFAccount->getContractInfoList(pContractInfoList, idDataGroup) && pContractInfoList )
	{		
		BFObjIter iterContractList( *pContractInfoList, idDataGroup );
		iterContractList.begin();
		while( !iterContractList.end() )
		{
			ContractInfo *pContractInfo = dynamic_cast< ContractInfo* >( iterContractList.getObject() );
			if ( pContractInfo != NULL ) 
			{			
				pContractInfo->getContractTypeAndVersion (dstrContractType, dstrContractVer, idDataGroup);
				if (dstrContractType == contractType) 
				{
					pContractInfo->getNMCRContract (dstrNMCRContract, idDataGroup);
					if (dstrNMCRContract == YES) 
						bNMCRContract = true;											
					break;
				}
			}
			++iterContractList;
		}               			
	}

	return bNMCRContract;
}

//******************************************************************************
SEVERITY Trade::validateNMCRContract( MFAccount *pMFAccount, 
									  DString& fundCode, 
									  DString& classCode, 
									  DString &contractType, 
									  DString &contractVer, 
									  const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
						   CLASSNAME, 
						   I_( "validateNMCRContract" ) );

	// check for blank annuitant gender to stop the user from placing an applicable trade if the following conditions are met: 
	// - purchase/exchange to NMCR account/contract/version
	// - transfer to NMCR contract from another NMCR contract

	if ( !fundCode.stripAll().empty() && !classCode.stripAll().empty() )
	{
		if ( hasNMCRContract( pMFAccount, fundCode, classCode, contractType, contractVer, idDataGroup) )
		{
			getErrMsg ( IFASTERR::INVALID_OR_MISSING_ANNUITANT_SEX,
						CND::ERR_INVALID_OR_MISSING_ANNUITANT_SEX,
						CND::WARN_INVALID_OR_MISSING_ANNUITANT_SEX,
						idDataGroup,
						NULL_STRING);	
		}
	}

	return GETCURRENTHIGHESTSEVERITY();}

//******************************************************************************
SEVERITY Trade::validateAnnuitantGender (const BFDataGroupId& idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
						   CLASSNAME, 
						   I_( "validateAnnuitantGender" ) );

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateAnnuitantGender (const BFDataGroupId& idDataGroup, DString& dstrAccount)
{
	MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, 
						   CLASSNAME, 
						   I_( "validateAnnuitantGender" ) );

	DString fundCode, classCode, contractType, contractVer;
	MFAccount *pMFAccount = NULL;

	if ( getWorkSession().getMFAccount (idDataGroup, dstrAccount, pMFAccount) <= WARNING )
	{ 		
		TradeFundAllocList *pTradeFundAllocList = NULL;
		if ( pMFAccount->hasBlankAnnuitantGender(idDataGroup) && 
			 getFundAllocationList (pTradeFundAllocList, idDataGroup, false) <= WARNING && pTradeFundAllocList )
		{
			TradeFundAlloc *pTradeFundAlloc = NULL;
			BFObjIter iter (*pTradeFundAllocList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);
			while (!iter.end ()) 
			{
				iter.getObject()->getField (ifds::FundCode, fundCode, idDataGroup);
				iter.getObject()->getField (ifds::ClassCode, classCode, idDataGroup);
				if ( validateNMCRContract( pMFAccount, fundCode, classCode, contractType, contractVer, idDataGroup) > WARNING )
					break;
				++iter;
			}
		}
	}

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateSegExch(const BFDataGroupId &idDataGroup )
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateSegExch"));

   DString strAccountNum, strFund, strClass, strAccountTo, strFundTo,
           strClassTo, strTransType, strDeff, strTransId;

   getField(ifds::AccountNum, strAccountNum, idDataGroup, false);
   getField(ifds::AccountTo, strAccountTo, idDataGroup, false);
   getField(ifds::TradesTransType, strTransType, idDataGroup, false);
   getField(ifds::EffectiveDate, strDeff, idDataGroup, false);
   getField (ifds::TransId, strTransId, idDataGroup,false);
   
   if( hasAllocations(idDataGroup) )
   
   {
      TradeFundAllocList *pTradeFundAllocList;

      if ( getFundAllocationList (pTradeFundAllocList, idDataGroup) <= WARNING &&
           pTradeFundAllocList
         )
      {
         TradeFundAlloc *pTradeFundAlloc;

         BFObjIter iter ( *pTradeFundAllocList, 
                          idDataGroup, 
                          false, 
                          BFObjIter::ITERTYPE::NON_DELETED);

         while (!iter.end ()) 
         {
            pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());
            pTradeFundAlloc->getField (ifds::FundCode, strFund, idDataGroup);
            pTradeFundAlloc->getField (ifds::ClassCode, strClass, idDataGroup);

            pTradeFundAlloc->getField (ifds::FundCode, strFundTo, idDataGroup);
            pTradeFundAlloc->getField (ifds::ClassCode, strClassTo, idDataGroup);
             validateFromToSegTradeEntryCheck(strAccountNum,
                                          strFund,
                                          strClass,
                                          strAccountTo,
                                          strFundTo,
                                          strClassTo,
                                          strDeff,
                                          strTransType,
                                          strTransId,
                                          idDataGroup);
            ++iter;
         }
      }
   }

   return GETCURRENTHIGHESTSEVERITY (); 

}

//*****************************************************************************
SEVERITY Trade::setAccountNumbersFromSystemLevel(  bool bFrom, const BFDataGroupId& idDataGroup )
{
    MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "setAccountNumbersFromSystemLevel" ) );

    if( !isSettleLocAllowed (idDataGroup) ) //dont set this for not allowed trades
    {
        return(GETCURRENTHIGHESTSEVERITY());
    }
    // get the Settlement Accoutn and iNternal settl account form the system level setup and assign it to tarde
    //these fields update flags should not be set true as they are not send to data base
    SysLvlSettlementInstrList *pSysLvlSettlementInstrList = NULL;
    if ( getWorkSession().getSettlementLocationSysLvlList( pSysLvlSettlementInstrList, idDataGroup, true ) <= WARNING &&
    NULL != pSysLvlSettlementInstrList )
    {
       SysLvlSettlementInstr *pSysLvlSettlementInstr = NULL;
       DString dstrSettleLocCode;
       if(bFrom)
          getField( ifds::FrSettlLocCode,        dstrSettleLocCode,        idDataGroup );
       else
          getField( ifds::ToSettlLocCode,        dstrSettleLocCode,        idDataGroup );

	   if ( pSysLvlSettlementInstrList->getSysLvlSettlementInstr( dstrSettleLocCode, pSysLvlSettlementInstr, 
																  idDataGroup ) <= WARNING &&	 NULL != pSysLvlSettlementInstr)
       {
            DString dstrSettleAccountNum, dstrIntSettleAccountNum;
            pSysLvlSettlementInstr-> getField( ifds::SettleAccountNum, dstrSettleAccountNum, idDataGroup );
            pSysLvlSettlementInstr-> getField( ifds::InternalSettlementAccount, dstrIntSettleAccountNum, idDataGroup );
            if(bFrom)
            {
                setFieldNoValidate( ifds::FrSettlementAccount, dstrSettleAccountNum, idDataGroup); 
                setFieldNoValidate( ifds::FrInternalSettlementAccount, dstrIntSettleAccountNum, idDataGroup); 
                setFieldUpdated(ifds::FrSettlementAccount, idDataGroup, false);
                setFieldUpdated(ifds::FrInternalSettlementAccount, idDataGroup, false);
            }
            else
            {
                setFieldNoValidate( ifds::ToSettlementAccount, dstrSettleAccountNum, idDataGroup); 
                setFieldNoValidate( ifds::ToInternalSettlementAccount, dstrIntSettleAccountNum, idDataGroup); 
                setFieldUpdated(ifds::ToSettlementAccount, idDataGroup, false);
                setFieldUpdated(ifds::ToInternalSettlementAccount, idDataGroup, false);
            }
       }
    }
    return(GETCURRENTHIGHESTSEVERITY());
}

/******************************************************************************
 Input: idataGroup
 OutPut:None
 Return:Bool
 Functionality:Return true if G1G2is applicable for the transcation or not. 
 ******************************************************************************/
bool Trade::isG1G2ApplicableTrade(const BFDataGroupId &idDataGroup)
{
    MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "isG1G2ApplicableTrade" ) );
    return(false);
}

/******************************************************************************
 Input: idataGroup
 OutPut:None
 Return:None
 Functionality:Sets the TransType substitution based on the MiscInfo 
 ******************************************************************************/
SEVERITY Trade::setTransTypeListFromMiscInfo( const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "setTransTypeListFromMiscInfo" ) );

   DString dstrSysLvlTransTypeList, dstrSysLvlTransTypeSubSet;
   TradeTransTypeSetFromMiscInfoList *pTradeTransTypeSetFromMiscInfoList;
   if ( getMgmtCo().getTradeTransTypeSetFromMiscInfoList(pTradeTransTypeSetFromMiscInfoList)<= WARNING &&
        pTradeTransTypeSetFromMiscInfoList )
   { 
       DString dstrFilteredListOfTransType;
       BFProperties *pBFPropertiesAllTradesTransType = getFieldProperties (ifds::TradesTransType, idDataGroup);
       if(pBFPropertiesAllTradesTransType)
       {
           pTradeTransTypeSetFromMiscInfoList->getFilteredString( dstrFilteredListOfTransType ); 

           if(!dstrFilteredListOfTransType.empty())  
           {
             pBFPropertiesAllTradesTransType->setAllSubstituteValues(dstrFilteredListOfTransType);
             return(GETCURRENTHIGHESTSEVERITY());
           }

           pTradeTransTypeSetFromMiscInfoList->getSysLevelTransTypeList(dstrSysLvlTransTypeList);

           if( dstrSysLvlTransTypeList.empty() )
               return(GETCURRENTHIGHESTSEVERITY());       

             DString dstrTransTypeSubst, dstrTranTypeCode;
             pBFPropertiesAllTradesTransType->getAllSubstituteValues (dstrTransTypeSubst);
             if( dstrTransTypeSubst.empty() )
                 return(GETCURRENTHIGHESTSEVERITY());

             I_CHAR *temp = const_cast<I_CHAR*> (dstrTransTypeSubst.c_str ());
             do
             {
               DString dstrTransCode, dstrTransDescr;
               temp = parseIdiString (temp, dstrTransCode, dstrTransDescr );
               bool bFilterForTransTypeBasedOnMiscInfo = false;
               bFilterForTransTypeBasedOnMiscInfo = isCodeInList( dstrTransCode, 
                                                                  TRANS_TYPE_TO_BE_FILTERED_BASED_ON_MISC_INFO );
               if( bFilterForTransTypeBasedOnMiscInfo )
               {
                  if( isCodeInList( dstrTransCode, dstrSysLvlTransTypeList ))
                    {
                       dstrSysLvlTransTypeSubSet += dstrTransCode + I_("=")+ dstrTransDescr + I_(";");
                    }
               }
               else
               {
                  dstrSysLvlTransTypeSubSet += dstrTransCode + I_("=")+ dstrTransDescr + I_(";"); 
               }

               //TO BE WORKED ON LATER ONCE THE ENTIRE TRANSTYPE IS TO BE BASED ON THE MISC-INFO

               //bool bDefaultTransTypes = false;   
               //bDefaultTransTypes = isCodeInList(dstrTransCode, BASIC_TARNS_TYPE)  ?  true : false;                  
               // if( bDefaultTransTypes )  
               //    dstrSysLvlTransTypeSubSet += dstrTransCode + I_("=")+ dstrTransDescr + I_(";");               
               // else
               //{
               //   if( isCodeInList( dstrTransCode, dstrSysLvlTransTypeList ))
               //      dstrSysLvlTransTypeSubSet += dstrTransCode + I_("=")+ dstrTransDescr + I_(";");
               //}
           
             }while (temp && temp != NULL_STRING && *temp);  
             pBFPropertiesAllTradesTransType->setAllSubstituteValues(dstrSysLvlTransTypeSubSet);
             pTradeTransTypeSetFromMiscInfoList->setFilteredString(dstrSysLvlTransTypeSubSet);
      }
   }
   return(GETCURRENTHIGHESTSEVERITY());
}

/******************************************************************************
 Input: idataGroup, from to trade side, Regulation for specfic case
 OutPut:None
 Return:SEVERITY
 Functionality:Triggers a call to the 469 view to do regulatory validations
                and display the errors.
 ******************************************************************************/
SEVERITY Trade::doRegulatoryValidations(const BFDataGroupId &idDataGroup, const DString& dstrSide , const DString& dstrRegulation /* = NULL_STRING*/ )
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "doRegulatoryValidations" ) );
     
   DString  dstrTradeDate, dstrTransType, dstrAcctNum , dstrFund ;
   
   if( FROM_TO::FROM == dstrSide )
   {
     getField(ifds::AccountNum, dstrAcctNum, idDataGroup, false);
	 getField(ifds::FromFund, dstrFund, idDataGroup, false);
	 getField(ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);
   }
   else if( FROM_TO::TO == dstrSide )
   {
     getField(ifds::AccountTo, dstrAcctNum, idDataGroup, false);
     getField(ifds::ToFund, dstrFund, idDataGroup, false);
	 getField(ifds::TradeInDate, dstrTradeDate, idDataGroup, false);
   }
   getField(ifds::TradesTransType, dstrTransType, idDataGroup, false);
  
   if( dstrTransType.empty() || dstrTradeDate.empty () || dstrAcctNum.empty() || dstrFund.empty () )
       return(GETCURRENTHIGHESTSEVERITY());

   RegulatoryValidationErrorList regulatoryValidationErrorList(*this);  
   
   regulatoryValidationErrorList.doRegulatoryValidations( dstrAcctNum, dstrFund, dstrTradeDate, idDataGroup, dstrTransType, dstrRegulation ); 
   
   return(GETCURRENTHIGHESTSEVERITY());
 }

/******************************************************************************
 Input: idataGroup, from to trade side
 OutPut:None
 Return:SEVERITY
 Functionality:does special handeling for SIF Regulatory validations
               1. Validation of a regulation during money-out is not trival.SIF needs it as per BRD.
               2. Rebook trades needs to be excluded from validation for what ever achnages on the trade
               3. Any filed on trade or trade attributes changed ,during pending ,need to be revalidated for SIF.
 ******************************************************************************/
SEVERITY Trade::doSIFRegulationSpecificValidations(const BFDataGroupId &idDataGroup, const DString& dstrSide )
{
   MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "doSIFRegulationSpecificValidations" ) );
   
   //check if the 
   TranslationTable* pTranslationTable = NULL;
   DString dstrCodeList;
   if (getMgmtCo ().getTranslationTable (ENT_REGULATION, pTranslationTable) <= WARNING && pTranslationTable)
       pTranslationTable->getCodeList(dstrCodeList); 
        
   DString dstrGoodBad;
   getField(ifds::GoodBad, dstrGoodBad, idDataGroup, false);  

   
   if(!isCodeInList(REGULATION::SIF, dstrCodeList) || isRebook() || NO == dstrGoodBad )//Rebook-trades and Pending trades marked as bad are excluded 
       return(GETCURRENTHIGHESTSEVERITY());

   doRegulatoryValidations(idDataGroup, dstrSide, REGULATION::SIF);    
   return(GETCURRENTHIGHESTSEVERITY());
}

//******************************************************************************
SEVERITY Trade::validatePSEInformation (const BFDataGroupId &idDataGroup, Frame *pFrame)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("validatePSEInformation"));
	
	DString redCode;
	getField (ifds::RedCode, redCode, idDataGroup, false);
	bool bPSEError = false;

	if (isPSEEAPAllowed (idDataGroup) && redCode == I_("EP"))
	{
		int count = pFrame->getCount();
		for (int i = 0; i < count; i++)
		{
			Condition *c = pFrame->getCondition(i);
			int condCode = c->getCode();

			if( condCode == CND::ERR_COURSE_START_DATE_MANDATORY ||
				condCode == CND::ERR_ACADEMIC_DAY_MUST_BE_01 || 
				condCode == CND::ERR_EDUCATION_INST_POST_CODE_AND_COUNTRY_NAME_REQUIRED ||
				condCode == CND::ERR_ACADEMIC_YEAR_LENGTH_REQUIRED ||
				condCode ==	CND::ERR_COURSE_LEN_BETWEEN_1_AND_52_WEEKS || 
				condCode ==	CND::ERR_PSE_LEN_INVALID ||
				condCode ==	CND::ERR_PSE_TYPE_INVALID ||
				condCode == CND::ERR_PSE_YEAR_INVALID)
			{
				bPSEError = true;
				break;
			}
		}
		
		if (bPSEError)
		{
			// PSE Information is required for EP redemptions.
			getErrMsg (IFASTERR::PSE_INFORMATION_REQUIRED,
					   CND::ERR_PSE_INFORMATION_REQUIRED,
					   CND::WARN_PSE_INFORMATION_REQUIRED,
					   idDataGroup );	
		}
	}

	return(GETCURRENTHIGHESTSEVERITY());
}

//******************************************************************************
SEVERITY Trade::validateParentFundAgainstAmtType(const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateParentFundAgainstAmtType"));

   DString dstrFundCode, dstrClassCode, dstrAcctNum;
   MFAccount *pMFAccount = nullptr;
   FundDetail *pFundDetail = nullptr;

   getField(ifds::AccountNum, dstrAcctNum, idDataGroup, false);
   getField(ifds::FromFund, dstrFundCode, idDataGroup);
   getField(ifds::FromClass, dstrClassCode, idDataGroup);

   if (getWorkSession().getMFAccount(idDataGroup, dstrAcctNum, pMFAccount) <= WARNING && pMFAccount &&
       pMFAccount->isAMSAccount(idDataGroup) &&
       getWorkSession().getFundDetail(dstrFundCode, dstrClassCode, idDataGroup, pFundDetail) && pFundDetail &&
       pFundDetail->isAMSParentFund(idDataGroup))
   {
      DString stopFlagSeverityCode;

      getStopFlagSeverityFromFundLimitationRule(dstrFundCode,
                                                dstrClassCode,
                                                UNIT_TRADE_NOT_ALLOWED,
                                                stopFlagSeverityCode,
                                                idDataGroup);

      // look like view 236 doesn't support rule type 37 with purchase yet
      // so this would be commented until back end logic suport these conditions.

      //if ( stopFlagSeverityCode.strip().upperCase() == I_("E") || 
      //     stopFlagSeverityCode.strip().upperCase() == I_("W"))
      {
         CND::CIFast_IFast_ifastcbo_warn_unit_trading_not_allowed warnCond;
         CND::CIFast_IFast_ifastcbo_err_unit_trading_not_allowed errCond;

         MFCanBFCbo::getErrMsg (IFASTERR::UNIT_TRADING_NOT_ALLOWED, // 982
                                errCond,
                                warnCond,
                                idDataGroup);
      }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
SEVERITY Trade::getStopFlagSeverityFromFundLimitationRule(const DString &fundCode,
                                                          const DString &classCode,
                                                          const DString &limitationRule,
                                                          DString &dstrStopFlagSeverity,
                                                          const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateParentFundAgainstAmtType"));

   DString dstrAcctNum, dstrTransType;
   getField(ifds::AccountNum, dstrAcctNum, idDataGroup, false);
   getField( ifds::TradesTransType, dstrTransType, idDataGroup, false );

   FundLmtOverrideList *pFundLmtOverrideList = nullptr;

   getFundLmtOverrideList(pFundLmtOverrideList,
                          dstrTransType,
                          fundCode,
                          classCode,
                          idDataGroup);

   FundLmtOverride *pFundLmtOverride = nullptr;
   if ( pFundLmtOverrideList != nullptr &&
         pFundLmtOverrideList->getFundLmtOverride ( getWorkSession(), 
                                                    dstrAcctNum, 
                                                    limitationRule, 
                                                    pFundLmtOverride, 
                                                    idDataGroup) <= WARNING && 
         pFundLmtOverride)
   {
      DString stopFlagSeverityCode;
      pFundLmtOverride->getField (ifds::StopFlagSeverityCode, stopFlagSeverityCode, idDataGroup, false);
   }

   return GETCURRENTHIGHESTSEVERITY ();
}

//******************************************************************************
bool Trade::isExternalInstitutionTrackingEnable(const BFDataGroupId& idDataGroup)
{
   // overridden in purchase\redemtion CBO

   return false;
}

//******************************************************************************
SEVERITY Trade::getExternalInstitutionList(ExternalInstitutionList*& pExternalInstitutionList, 
                                          const BFDataGroupId& idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("getExternalInstitutionList")); 

   DString strKey = I_("ExternalInstitutionList");

   pExternalInstitutionList = nullptr;

   ExternalInstitutionList* _pExternalInstitutionList = 
      dynamic_cast<ExternalInstitutionList*> (BFCBO::getObject (strKey, idDataGroup));

   if( !_pExternalInstitutionList )
   {
      _pExternalInstitutionList = new ExternalInstitutionList(*this);

      if( _pExternalInstitutionList->init(idDataGroup) > WARNING )
      {
         delete _pExternalInstitutionList;
         _pExternalInstitutionList = nullptr;
      }

      if (_pExternalInstitutionList)
      {
         setObject ( _pExternalInstitutionList, 
                     strKey, 
                     OBJ_ACTIVITY_NONE, 
                     idDataGroup);
      }
   }

   pExternalInstitutionList = _pExternalInstitutionList;

   return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::validateCashDateMandatory (const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateCashDateMandatory")); 

	// Default condition
	SEVERITY sevRtn = NO_CONDITION;

	DString tradeDate, fundCode, classCode, cashDateOverride, lastValDate, dstrCashdate, dstrCashDateOverriden;

	getField( ifds::EffectiveDate, tradeDate,idDataGroup, false);
	getField (ifds::FromFund, fundCode,  idDataGroup);
	getField (ifds::FromClass, classCode, idDataGroup);
	
	getWorkSession().getOption (ifds::OrderUserOverride, cashDateOverride, BF::HOST, false); // OrdEntryUserOverride attribute in PendingTradeCashDate function control: 01-no override, 02-override backdated trades, 03-override all	

	if (!fundCode.strip ().empty () && !classCode.strip ().empty ())
	{
		getField (ifds::EffectiveDate, tradeDate, idDataGroup);
		getField (ifds::CashDate, dstrCashdate, idDataGroup, false);
		getField (ifds::CashDateOverriden, dstrCashDateOverriden, idDataGroup, false);

		bool bIsCashDateOverriden = dstrCashDateOverriden.strip().upperCase() == Y;		

		// Check if transaction is backdated
		if ( (cashDateOverride != I_("03") &&
			  getFundField ( fundCode, 
							classCode, 
							ifds::LastValDate, 
							lastValDate) <= WARNING &&
							 DSTCommonFunctions::CompareDates (tradeDate, lastValDate) == DSTCommonFunctions::FIRST_EARLIER ) ||
			 (cashDateOverride == I_("03") &&
			  getFundField ( fundCode, 
							 classCode, 
							 ifds::LastValDate, 
							 lastValDate) <= WARNING &&
							 (DSTCommonFunctions::CompareDates (tradeDate, lastValDate) == DSTCommonFunctions::FIRST_EARLIER || 
							  DSTCommonFunctions::CompareDates (tradeDate, lastValDate) == DSTCommonFunctions::EQUAL)) )													
		{
			FundMasterList *pFundMasterList = NULL;
			if ( getMgmtCo ().getFundMasterList (pFundMasterList) <= WARNING && pFundMasterList)
			{
				FundMaster *pFundMaster = NULL;
				if ( pFundMasterList->getFundMaster (fundCode, idDataGroup, pFundMaster) &&
					pFundMaster  &&
					isCashDateUpdatable (pFundMaster, idDataGroup))
				{
					DString emptyDate, dstrCashDateOverriden;
					getWorkSession().getDateInHostFormat (emptyDate, DSTCWorkSession::DATE_TYPE::DAY12319999, idDataGroup);

					if(dstrCashdate.compare(emptyDate)== 0)
					{
						// 1941 - Cash Date is mandatory for Backdated Trades.
						getErrMsg(IFASTERR::CASH_DATE_MANDATORY,
							CND::ERR_CASH_DATE_MANDATORY,
							CND::WARN_CASH_DATE_MANDATORY,
							idDataGroup);
					}
				}
			}
		}

		if (bIsCashDateOverriden)
		{
			if (DSTCommonFunctions::CompareDates (dstrCashdate, tradeDate) == DSTCommonFunctions::FIRST_EARLIER)
			{				
				// 2241 - Overridden cash date should be greater than or equal to trade date.
				getErrMsg (IFASTERR::CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE,
						   CND::ERR_CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE,
						   CND::WARN_CASH_DATE_MUST_BE_GREATER_THAN_TRADE_DATE,
						   idDataGroup);
			}
			else
			{
			// 2242 - Please note cash date will remain as assigned.
			getErrMsg (IFASTERR::CASH_DATE_WILL_REMAIN_AS_ASSIGNED,
					   CND::ERR_CASH_DATE_WILL_REMAIN_AS_ASSIGNED,
					   CND::WARN_CASH_DATE_WILL_REMAIN_AS_ASSIGNED,
					   idDataGroup);
	}
	}
	}

return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::getAcctUnitsPrecision (	DString &unitsPrecision,
									    const BFDataGroupId& idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("getAcctUnitsPrecision")); 

	MFAccount *pMFAccount = NULL;
	DString accountNum;         
	getField (ifds::AccountNum, accountNum, idDataGroup);  

	// get account level rounding rule
	if ( getWorkSession().getMFAccount ( idDataGroup, accountNum, pMFAccount ) <= WARNING && pMFAccount != NULL)
	{
		AcctRoundingRuleList *pAcctRoundingRuleList = NULL;
		if ( pMFAccount->getAcctRoundingRuleList( pAcctRoundingRuleList, idDataGroup, true ) <= WARNING && pAcctRoundingRuleList )
		{
			BFObjIter iter ( *pAcctRoundingRuleList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

			AcctRoundingRule* pAcctRoundingRule = NULL;
			while (!iter.end ()) 
			{
				pAcctRoundingRule = dynamic_cast <AcctRoundingRule*> (iter.getObject ());

				pAcctRoundingRule->getField (ifds::UnitsPrecisionAcct, unitsPrecision, idDataGroup);
				unitsPrecision.strip();
				if (!unitsPrecision.empty())										
					break;				
				else				
					++iter;
			}
		}
	}	

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::validateUnusualTrading (const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateUnusualTrading"));

	DString dstrAccountNum,
			dstrFundCode,
			dstrClassCode,
			dstrTransType,
			dstrAmount,
			dstrAmtType,
			dstrEffectiveDate,
			dstrSettleCurrency,
			dstrExchRate,
			dstrBrokerCode,
			dstrBranchCode,
			dstrSalesRepcode,
			dstrDepositType,
			dstrTradeDate,
			dstrCurrency,
			dstrOrderType;
	
	getField (ifds::AccountNum,dstrAccountNum, idDataGroup);
	getField (ifds::TradesTransType, dstrTransType, idDataGroup);
	getField (ifds::FromFund, dstrFundCode, idDataGroup);
	getField (ifds::FromClass, dstrClassCode, idDataGroup);
	getField (ifds::AmtType, dstrAmtType, idDataGroup);
	getField (ifds::Amount, dstrAmount, idDataGroup);
	getField (ifds::SettleCurrency, dstrCurrency, idDataGroup, false);
	getField (ifds::Broker, dstrBrokerCode, idDataGroup); 
	getField (ifds::Branch, dstrBranchCode, idDataGroup);
	getField (ifds::SlsrepCode, dstrSalesRepcode, idDataGroup);
	getField (ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);
	getField (ifds::OrderType, dstrOrderType, idDataGroup );
	getField (ifds::DepositType, dstrDepositType, idDataGroup);
	getField (ifds::ExchRate, dstrExchRate, idDataGroup, false);


	UnusualTradingValidation *pUnusualTradingValidation = NULL;
	DString strKey = 
		I_("Account=")       + dstrAccountNum +
		I_(";TransType=")    + dstrTransType +
		I_(";FundCode=")     + dstrFundCode  +
		I_(";ClassCode=")    + dstrClassCode +
		I_(";AmtType=")      + dstrAmtType   +
		I_(";Amount=")       + dstrAmount    +
		I_(";Currency=")     + dstrCurrency  +
		I_(";Broker=")       + dstrBrokerCode +
		I_(";Branch=")       + dstrBranchCode +
		I_(";SlsRep=")       + dstrSalesRepcode +
		I_(";TradeDate=")    + dstrTradeDate +
		I_(";DepositType=")  + dstrDepositType +
		I_(";OrderType=")    + dstrOrderType ;

      pUnusualTradingValidation = 
            dynamic_cast<UnusualTradingValidation*> (getObject (strKey, idDataGroup));

      if (!pUnusualTradingValidation)
      {
         pUnusualTradingValidation = new UnusualTradingValidation (*this);
         if ( pUnusualTradingValidation->init ( dstrAccountNum, 
                                        dstrFundCode, 
                                        dstrClassCode, 
                                        dstrTransType, 
                                        dstrAmtType,
                                        dstrAmount, 
                                        dstrTradeDate, 
                                        dstrCurrency, 
                                        dstrExchRate,
                                        dstrBrokerCode,
                                        dstrBranchCode,
                                        dstrSalesRepcode,
										NULL_STRING,
										NULL_STRING,
										dstrDepositType,
										dstrOrderType ) <= WARNING)
         {
            setObject (pUnusualTradingValidation, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
         }
         else
         {
            delete pUnusualTradingValidation;
            pUnusualTradingValidation = NULL;
         }
      }
      if (pUnusualTradingValidation)
      {
         pUnusualTradingValidation->addConditions ();
      }

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isFundTRDTKT (DString dstrFundCode,
						  DString dstrClassCode,
						  const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("isFundTRDTKT"));

	bool bFundFound(false);
	if (!dstrFundCode.empty() && !dstrClassCode.empty())
	{
		FundGroupTypeList *pFundGroupTypeList = NULL;

		if ( getMgmtCo().getFundGroupTypeList( pFundGroupTypeList, I_( "TRDTKT" ) ) <= WARNING && 
			NULL != pFundGroupTypeList )
		{
			BFObjIter iter( *pFundGroupTypeList, idDataGroup, true , BFObjIter::ITERTYPE::NON_DELETED );
			iter.begin();
			while ( !iter.end() )
			{
				BFCBO *pFundGroupType = dynamic_cast<BFCBO*>(iter.getObject());
				if( NULL != pFundGroupType )
				{
					DString dstrCurrentFund, dstrCurrentClass,dstrClassRequired;
					pFundGroupType->getField( ifds::FundCode,  dstrCurrentFund,  idDataGroup );
					pFundGroupType->getField( ifds::ClassCode, dstrCurrentClass, idDataGroup );

					if (dstrCurrentFund == dstrFundCode && dstrCurrentClass == dstrClassCode)
					{
						bFundFound = true;
						break;
					}
				}
				++iter;
			}
		}
	}
	return bFundFound;
}
//******************************************************************************************
 SEVERITY Trade::getDefaultOrderRouting (bool & bAccountRuleAvailable, 
										const BFDataGroupId &idDataGroup)
 {
	 MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("getDefaultOrderRouting"));

	 bAccountRuleAvailable = false;
	 MFAccount *pMFAccount = NULL;
	 MFAccount *pMFAccountTo = NULL;
	 DString dstrAccountNum = NULL_STRING,
			  dstrAccountTo  = NULL_STRING,
			 dstrAcctOrderRoutingRuleAvailable = NULL_STRING,
			 dstrAcctOrderRoutingRuleAvailableTo = NULL_STRING,
			 dstrTradeDate = NULL_STRING;


	 getField (ifds::AccountNum, dstrAccountNum,idDataGroup,false );
	 getField (ifds::AccountTo, dstrAccountTo,idDataGroup,false );
	 getField (ifds::EffectiveDate,dstrTradeDate,idDataGroup,false );

	 if( !dstrAccountNum.empty() && dstrAccountTo.empty())
	 {
		 if( getWorkSession ().getMFAccount (idDataGroup, 
											 dstrAccountNum, 
											 pMFAccount) <= WARNING && 
											 pMFAccount )
		 {
			 if (pMFAccount->getDefaultOrderRoutingInfo (dstrAcctOrderRoutingRuleAvailable,
														 dstrTradeDate,
														 idDataGroup ) <= WARNING )
			 {
				 dstrAcctOrderRoutingRuleAvailable.strip().upperCase();
				 bAccountRuleAvailable = dstrAcctOrderRoutingRuleAvailable == I_("Y");
			 }
		 }
	 }
	 else if (!dstrAccountNum.empty() && !dstrAccountTo.empty())
	 {
		 if( getWorkSession ().getMFAccount (idDataGroup, 
											 dstrAccountNum, 
											 pMFAccount) <= WARNING && 
											 pMFAccount &&
			 getWorkSession ().getMFAccount (idDataGroup, 
											 dstrAccountTo, 
											 pMFAccountTo) <= WARNING && 
											 pMFAccountTo )
		 {
			 if (pMFAccount->getDefaultOrderRoutingInfo (dstrAcctOrderRoutingRuleAvailable,
														 dstrTradeDate,
														 idDataGroup ) <= WARNING &&
			   pMFAccountTo->getDefaultOrderRoutingInfo (dstrAcctOrderRoutingRuleAvailableTo,
														 dstrTradeDate,
														 idDataGroup ) <= WARNING )
			 {
				 dstrAcctOrderRoutingRuleAvailable.strip().upperCase();
				 dstrAcctOrderRoutingRuleAvailableTo.strip().upperCase();

				 bAccountRuleAvailable = dstrAcctOrderRoutingRuleAvailable == I_("Y")  && dstrAcctOrderRoutingRuleAvailableTo == I_("Y");
			 }			 														 
		 }
	 }

	 return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
SEVERITY Trade::orderRoutingRelatedChanges (const BFDataGroupId &idDataGroup) 
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("orderRoutingRelatedChanges"));

   bool bAccountRuleAvailable = false;
   bool bReadOnly = false;

   DString OrderRouting (NULL_STRING);
   DString drstFromFund(NULL_STRING),dstrFromClass(NULL_STRING), 
		   dstrToFund(NULL_STRING), dstrToClass(NULL_STRING);

   if (getDefaultOrderRouting (bAccountRuleAvailable, idDataGroup) <= WARNING)
   {
	 if( !bAccountRuleAvailable )
	 {
		 OrderRouting = I_("Include");
	 }
	 else
	 {
		 OrderRouting = I_("Exclude");
	 } 
   } 
	setFieldNoValidate (ifds::OrderRouting,OrderRouting,idDataGroup,false, true, false, false);

	getField (ifds::FromFund,drstFromFund, idDataGroup, false );
	getField (ifds::FromClass,dstrFromClass, idDataGroup, false );

	getField (ifds::ToFund,dstrToFund, idDataGroup, false );
	getField (ifds::ToClass,dstrToClass, idDataGroup, false );

	bReadOnly = !isFundTRDTKT (drstFromFund, dstrFromClass, idDataGroup)  && !isFundTRDTKT (dstrToFund, dstrToClass, idDataGroup);
	if(bReadOnly)
	{
		setFieldNoValidate (ifds::OrderRouting,I_(" "),idDataGroup,false, true);
	}
	setFieldReadOnly (ifds::OrderRouting,idDataGroup,bReadOnly);

	return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::validateTradeInDate ( const DString &dstrTradeInDate, 
                                       const BFDataGroupId &idDataGroup)
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
                           I_("validateTradeInDate"));

   DString dstrTradeDate;

   getField(ifds::EffectiveDate, dstrTradeDate, idDataGroup, false);
       
   if (DSTCommonFunctions::CompareDates (dstrTradeInDate, dstrTradeDate) == DSTCommonFunctions::FIRST_EARLIER)
    {
      ADDCONDITIONFROMFILE (CND::ERR_INVALID_TRADEINDATE);
    }
   else if( validateDate ( DATE_VALIDATION::TRADE_DATE,  ifds::TradeInDate, dstrTradeInDate, idDataGroup))
   {
	   if(!dstrTradeInDate.empty())
	   {
			validateTradeDate (dstrTradeInDate, idDataGroup);
	   }
	   if( WARNING >= GETCURRENTHIGHESTSEVERITY() )
	   {
		   //do only the to side regulatory validation once the from side is error free.
		   if( WARNING >= doSIFRegulationSpecificValidations(idDataGroup , FROM_TO::FROM ) && !isOneSideTrade(idDataGroup) ) 
			   doSIFRegulationSpecificValidations(idDataGroup , FROM_TO::TO );
	   }
   }

   return GETCURRENTHIGHESTSEVERITY ();
}
//*****************************************************************************
bool Trade::isXferInDateActive (const BFDataGroupId &idDataGroup)
{
   DString xferInDateActive, transType;

   getWorkSession().getOption ( ifds::XferInTradeDat, 
                                 xferInDateActive, 
                                 BF::HOST, 
                                 false);

   bool xferDateActive = xferInDateActive == I_("1") ;

   return xferDateActive;
}
//************************************************************************************************************************
SEVERITY Trade::initPriceTypesList(const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("initPriceTypesList"));

	return GETCURRENTHIGHESTSEVERITY();
}
//************************************************************************************************************************
SEVERITY Trade::validatePendingTradeAllocated(const BFDataGroupId &idDataGroup) //Added for INC0039323
{
   MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, 
                           CLASSNAME, 
 						  I_("validatePendingTradeAllocated"));
	DString fundCode,
			classCode,
			allocation,
			effectiveDate,
			oldEffectiveDate;

	getField (ifds::FromFund, fundCode, idDataGroup);
	getField (ifds::FromClass, classCode, idDataGroup);
	getField (ifds::EffectiveDate, effectiveDate, idDataGroup);
	getField (ifds::EffectiveDate, oldEffectiveDate, BF::HOST);
	getField (ifds::Allocation, allocation, idDataGroup);
	allocation.strip().upperCase();

   //Check if pending trade is allocated and is split
	if (allocation == I_("Y") && 
	   DSTCommonFunctions::CompareDates (effectiveDate, oldEffectiveDate) != DSTCommonFunctions::EQUAL &&
	   !fundCode.empty() &&
        !classCode.empty())
	{
	            getErrMsg ( IFASTERR::PENDING_ALLOCATION_NOT_ALLOWED_TRADE, 
                     CND::ERR_PENDING_ALLOCATION_TRADE, 
                     CND::WAR_PENDING_ALLOCATION_TRADE, 
                     idDataGroup,
                     NULL_STRING);
   }
   return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
bool Trade::isRDSPTradeAccount (const BFDataGroupId &idDataGroup, DString& dstrAccountNum)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("isRDSPTradeAccount"));

	DString taxType;   
	MFAccount *pMFAccount;
	
	dstrAccountNum.strip();  

	if ( getWorkSession().getMFAccount (idDataGroup, dstrAccountNum, pMFAccount ) <= WARNING && pMFAccount)
	{
		pMFAccount->getField( ifds::TaxType, taxType, idDataGroup, false );
		taxType.strip();      
	}

	bool isRDSPAccount = (taxType == RDSP_TAX_TYPE) ? true : false;

	return isRDSPAccount;
}

//******************************************************************************
SEVERITY Trade::validateRDSPTrade (const BFDataGroupId& idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2( CND::IFASTCBO_CONDITION, CLASSNAME, I_( "validateRDSPTrade" ) );

	return GETCURRENTHIGHESTSEVERITY();
}

//***********************************************************************************
SEVERITY Trade::validateRDSPTrade (const BFDataGroupId &idDataGroup, DString& dstrAccountNum)
{
	MAKEFRAMEAUTOPROMOTE2 ( CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateRDSPTrade"));

	DString dstrTransType, dstrFundCode, dstrClassCode, dstrEffectiveDate, dstrDepositType, dstrRedCode, dstrAmount, dstrGRRepayReason, dstrRDSPPaymtDate, dstrFullMoneyOutIndc;   
			
	getField (ifds::TradesTransType, dstrTransType, idDataGroup, false);

	if (isRDSPTradeAccount (idDataGroup, dstrAccountNum))
	{				
		getField (ifds::TradesTransType, dstrTransType, idDataGroup, false);
		getField (ifds::EffectiveDate, dstrEffectiveDate, idDataGroup, false);
		getField (ifds::DepositType, dstrDepositType, idDataGroup, false);
		getField (ifds::RedCode, dstrRedCode, idDataGroup, false);
		getField (ifds::Amount, dstrAmount, idDataGroup, false);
		getField (ifds::GRRepayReason, dstrGRRepayReason, idDataGroup, false);
		getField (ifds::RDSPPaymtDate, dstrRDSPPaymtDate, idDataGroup, false);
		getField (ifds::FullMoneyOutIndc, dstrFullMoneyOutIndc, idDataGroup, false);

		if (hasAllocations (idDataGroup))
		{
			TradeFundAllocList *pTradeFundAllocList = NULL;

			if (getFundAllocationList (pTradeFundAllocList, idDataGroup, false) <= WARNING && pTradeFundAllocList)
			{
				TradeFundAlloc *pTradeFundAlloc = NULL;
				BFObjIter iter (*pTradeFundAllocList, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

				while (!iter.end ()) 
				{
					pTradeFundAlloc = dynamic_cast <TradeFundAlloc*> (iter.getObject ());

					if (pTradeFundAlloc)
					{
						pTradeFundAlloc->getField (ifds::FundCode, dstrFundCode, idDataGroup, false);
						pTradeFundAlloc->getField (ifds::ClassCode, dstrClassCode, idDataGroup, false);						
					}

					++iter;
				}
			}
		}
		else
		{
			getFundField (ifds::FundCode, dstrFundCode, idDataGroup); 
			getFundField (ifds::ClassCode, dstrClassCode, idDataGroup);
		}

		dstrAccountNum.strip();
		dstrFundCode.strip().upperCase();
		dstrFundCode.strip().upperCase();
		dstrFullMoneyOutIndc.strip().upperCase();

		RDSPTradeValidation *pRDSPTradeValidation = new RDSPTradeValidation(*this);
		if (pRDSPTradeValidation->init( dstrAccountNum, 
									    dstrFundCode, 
										dstrClassCode, 
										dstrTransType, 
										dstrEffectiveDate, 
										dstrDepositType, 
										dstrRedCode, 
										dstrAmount, 
										dstrGRRepayReason,
										dstrRDSPPaymtDate,
										dstrFullMoneyOutIndc) > WARNING) 
		{
			delete pRDSPTradeValidation;
			pRDSPTradeValidation = NULL;
		}

		if (pRDSPTradeValidation)
		{
			pRDSPTradeValidation->addConditions(idDataGroup);
		}	
	}	

	return GETCURRENTHIGHESTSEVERITY (); 
}

//******************************************************************************
SEVERITY Trade::validateSuspendedFund (const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2(CND::IFASTCBO_CONDITION, CLASSNAME, I_("validateSuspendedFund"));

	DString strRunMode, 
			strFromFundCode,
			strFromClassCode, 
			strTransType, 
			strDealDate, 
			strDealTime,
			strFundToCode, 
			strClassToCode,
			strDepositType, 
			strRedCode;

	strRunMode = I_("A") ;
	getField (ifds::FromFund, strFromFundCode, idDataGroup);
	getField (ifds::FromClass,strFromClassCode, idDataGroup);
	getField (ifds::TradesTransType, strTransType, idDataGroup);
	getField (ifds::DealDate, strDealDate, idDataGroup);
	getField (ifds::DealTime, strDealTime, idDataGroup);
	getField (ifds::DepositType, strDepositType, idDataGroup);
	getField (ifds::RedCode, strRedCode, idDataGroup);

	FundSuspensionValidation *pFundSuspensionValidation = NULL;
	DString strKey = 
		I_("RunMode=")				+ strRunMode  +
		I_(";FromFundCode=")		+ strFromFundCode +
		I_(";FromClassCode=")       + strFromClassCode +
		I_(";TransType=")			+ strTransType +
		I_(";DealDate=")			+ strDealDate +
		I_(";DealTime=")			+ strDealTime +
		I_(";FundToCode=")			+ NULL_STRING +
		I_(";ClassToCode=")			+ NULL_STRING +
		I_(";DepositType=")			+ strDepositType +
		I_(";RedCode=")				+ strRedCode ;

		pFundSuspensionValidation = 
            dynamic_cast<FundSuspensionValidation*> (getObject (strKey, idDataGroup));

      if (!pFundSuspensionValidation)
      {
         pFundSuspensionValidation = new FundSuspensionValidation (*this);
		 if ( pFundSuspensionValidation->init ( strRunMode, 
												strFromFundCode,
												strFromClassCode, 
												strTransType, 
												strDealDate, 
												strDealTime,
												strFundToCode, 
												strClassToCode,
												strDepositType, 
												strRedCode ) <= WARNING)
         {
            setObject (pFundSuspensionValidation, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
         }
         else
         {
            delete pFundSuspensionValidation;
            pFundSuspensionValidation = NULL;
         }
      }
      if (pFundSuspensionValidation)
      {
         pFundSuspensionValidation->addConditions ();
      }

	return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
bool Trade::isIntraDayPricingEnable(const BFDataGroupId& idDataGroup)
{
   DString strIntraDayPricing;
   getWorkSession().getOption2(ifds::IntraDayPricing,strIntraDayPricing,idDataGroup,false);
   strIntraDayPricing.strip().upperCase();
   return((strIntraDayPricing == I_("Y")? true: false));
}
//********************************************************************************************
SEVERITY Trade::refreshIntradayPricing (const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("refreshIntradayPricing"));
	if(isIntraDayPricingEnable(idDataGroup ) )
	{
		DString strRunMode,
				strFromFund,
				strFromClass,
				strDealDate,
				strDealTime,
				strTradeFromDate,
				dstrTrack,
				dstrPageName,
				dstrTransType,
				dstrPriceCode,
				dstrPriceCodeList,
				strCallingType;
		if(_bInitPending)
			strRunMode = I_("M") ;
		else
			strRunMode = I_("A") ;
		getField (ifds::FromFund, strFromFund, idDataGroup);
		getField (ifds::FromClass,strFromClass, idDataGroup);
		if(strFromFund.empty() || strFromClass.empty())
		{
			return GETCURRENTHIGHESTSEVERITY();
		}
		getField (ifds::DealDate, strDealDate, idDataGroup);
		getField (ifds::DealTime, strDealTime, idDataGroup);
		DString::size_type iPos = strDealTime.find (I_(":"));
		if(iPos != std::string::npos)
		{
			strDealTime.replace(iPos,1,NULL_STRING);
		}
		getField (ifds::EffectiveDate, strTradeFromDate, idDataGroup);		
		getField(ifds::TradesTransType, dstrTransType, idDataGroup, false);
		strCallingType= CALLING_TYPE;
		IntraDayPricing *pIntraDayPricing = NULL;
		DString strKey =
			I_("RunMode=")				+ strRunMode  +
			I_(";Fund=")				+ strFromFund +
			I_(";Class=")				+ strFromClass +
			I_(";DealDate=")			+ strDealDate +
			I_(";DealTime=")			+ strDealTime +
			I_(";TradeDate=")			+ strTradeFromDate +
			I_(";TransType=")			+ dstrTransType +
			I_(";CallingType=")			+ strCallingType ;
		pIntraDayPricing =
				dynamic_cast<IntraDayPricing*> (getObject (strKey, idDataGroup));
		if (!pIntraDayPricing)
		{
			 pIntraDayPricing = new IntraDayPricing (*this);
			 if ( pIntraDayPricing->init ( strRunMode,
											strFromFund,
											strFromClass,
											NULL_STRING,
											NULL_STRING,
											strDealDate	,
											strDealTime	,
											strTradeFromDate,
											NULL_STRING,
											dstrTransType,
											strCallingType) <= WARNING)
			 {
				setObject (pIntraDayPricing, strKey, OBJ_ACTIVITY_NONE, idDataGroup);
			 }
			 else
			 {
				delete pIntraDayPricing;
				pIntraDayPricing = NULL;
			 }
		}
		if(pIntraDayPricing)
		{
			pIntraDayPricing->getField (ifds::PriceCode,dstrPriceCode, idDataGroup, false );
			pIntraDayPricing->getField (ifds::PriceCodeList,dstrPriceCodeList, idDataGroup, false );
			if(dstrPriceCodeList.empty() )
			{
				initPriceTypesList(idDataGroup);
				setFieldNoValidate ( ifds::PricingCode, NULL_STRING, idDataGroup, false,
								false,
								true);
				return GETCURRENTHIGHESTSEVERITY();
			}
			if(_bInitPending)
			{
				getField(ifds::PricingCode,dstrPriceCode,idDataGroup,false);
			}
			fromIntradayPricing(idDataGroup,dstrPriceCode,dstrPriceCodeList);
		}
	}
	return GETCURRENTHIGHESTSEVERITY();
}
//*****************************************************************************************************************
SEVERITY Trade::fromIntradayPricing(const BFDataGroupId &idDataGroup,DString dstrPriceCode,DString  dstrPriceCodeList)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("fromIntradayPricing"));
	DString dstrGroupCodeSubsList, dstrFromPriceTypesList,dstrPriceTypesList;
	BFProperties *pProperties = getFieldProperties(ifds::PricingCode, idDataGroup);
	if(pProperties)
	{
			pProperties->reinitAllSubstValues();
			pProperties->getAllSubstituteValues(dstrGroupCodeSubsList);
	}
	DString dstrBufferName;
	if(!dstrPriceCodeList.empty() )
	{
		setFieldAllSubstituteValues(ifds::PricingCode, idDataGroup, NULL_STRING);
		dstrFromPriceTypesList=dstrPriceCodeList;
		std::list<DString> FromPriceTypesList;
		DString::size_type pos = 0;
		DString dstrFromPriceType ;
		while (dstrFromPriceTypesList != NULL_STRING)
		{
			EXTRACT_VALUE(dstrFromPriceTypesList, dstrFromPriceType);
			CHOP_STRING(dstrFromPriceTypesList);
			FromPriceTypesList.push_back(dstrFromPriceType);
		}
		for( std::list<DString>::iterator itr = FromPriceTypesList.begin();itr != FromPriceTypesList.end();itr++ )
		{
			if(dstrPriceTypesList == NULL_STRING)
			{
				dstrPriceTypesList = *itr ;
			}
			else
			{
				dstrPriceTypesList +=  I_(",") + *itr ;
			}
		}
	}
	else
	{
		dstrPriceTypesList = dstrFromPriceTypesList;
	}
	DString tmpGroupCodeSubsList = dstrGroupCodeSubsList;
	while (tmpGroupCodeSubsList != NULL_STRING)
	{
		DString::size_type pos = 0;
		DString dstrGroupCodeDesc, dstrGroupCode;
		EXTRACT_VALUE_BY_DELIMITER(tmpGroupCodeSubsList, dstrGroupCodeDesc, I_(";"));
		CHOP_STRING2(tmpGroupCodeSubsList, I_(";"));
		EXTRACT_VALUE_BY_DELIMITER(dstrGroupCodeDesc, dstrGroupCode, I_("="));
		dstrGroupCode.stripLeading(I_('0'));
		if (!DSTCommonFunctions::codeInList(dstrGroupCode, dstrPriceTypesList))
		{
			dstrGroupCodeSubsList = removeItemFromSubtList(dstrGroupCodeSubsList, dstrGroupCode);
		}
		setFieldAllSubstituteValues(ifds::PricingCode, idDataGroup, NULL_STRING);
		setFieldAllSubstituteValues(ifds::PricingCode, idDataGroup, dstrGroupCodeSubsList);			
		setFieldNoValidate ( ifds::PricingCode, dstrPriceCode, idDataGroup, false,
							false,
							true);
	}				
	return GETCURRENTHIGHESTSEVERITY();
}

//*****************************************************************************************************************
SEVERITY Trade::hasWaiveGatingFund(const BFDataGroupId &idDataGroup)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("hasWaiveGatingFund"));
	return GETCURRENTHIGHESTSEVERITY();
}
//*****************************************************************************************************************
SEVERITY Trade::setWaiveGatingDropdown(const BFDataGroupId &idDataGroup,DString WaiveGateFlag)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("setWaiveGatingDropdown"));
	if(_bInitPending)
	{
		WaiveGateFlag.strip().upperCase();
		setFieldReadOnly( ifds::GateOverrideIndicator, idDataGroup, false );
		if(WaiveGateFlag== I_("NO") ||WaiveGateFlag== I_("N"))
		{
			setFieldNoValidate ( ifds::GateOverrideIndicator, I_("No"), idDataGroup, false,
								false,
								true);
		}
		else if(WaiveGateFlag== I_("YES") || WaiveGateFlag== I_("Y"))
		{
			setFieldNoValidate ( ifds::GateOverrideIndicator, I_("Yes"), idDataGroup, false,
								false,
								true);
		}
	}
	else if(!WaiveGateFlag.empty())
	{
		setFieldReadOnly( ifds::GateOverrideIndicator, idDataGroup, false );
		setFieldNoValidate ( ifds::GateOverrideIndicator, I_("No"), idDataGroup, false,
								false,
								true);
	}
	if(WaiveGateFlag.empty())
	{
		setFieldReadOnly( ifds::GateOverrideIndicator, idDataGroup, true );
		setFieldNoValidate ( ifds::GateOverrideIndicator, NULL_STRING, idDataGroup, false,
							false,
							true);
	}
	return GETCURRENTHIGHESTSEVERITY();
}

SEVERITY Trade::checkLiqRedFeeExist(const BFDataGroupId &idDataGroup,bool FromFlag)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("checkLiqRedFeeExist"));
	DString strFund,
			strClass,
			LiqRedFeeExist;
	if (FromFlag)
	{
		getField (ifds::FromFund, strFund, idDataGroup);
		getField (ifds::FromClass,strClass, idDataGroup);
	}
	else
	{
		getField (ifds::ToFund, strFund, idDataGroup);
		getField (ifds::ToClass,strClass, idDataGroup);
	}
	FundDetail *pFundDetail = NULL;

	if ( getWorkSession ().getFundDetail ( strFund, 
                                           strClass, 
                                           idDataGroup, 
                                           pFundDetail) && 
											pFundDetail)
	{
		pFundDetail->getField(ifds::LiqRedFeeExist, LiqRedFeeExist, idDataGroup, false);		
		 if(LiqRedFeeExist.stripAll().upperCase() == I_( "Y" ))
		{
			getErrMsg(IFASTERR::FUND_SUBJECT_TO_LIQUIDITY_FEE_MEASURE,
               CND::ERR_FUND_SUBJECT_TO_LIQUIDITY_FEE_MEASURE,
               CND::WARN_FUND_SUBJECT_TO_LIQUIDITY_FEE_MEASURE,
               idDataGroup );
		}
   }
	return GETCURRENTHIGHESTSEVERITY();
}
//******************************************************************************
SEVERITY Trade::getRDSPTransfer (RDSPTransfer *&pRDSPTransfer, const BFDataGroupId &idDataGroup, bool bCreate)
{
	MAKEFRAMEAUTOPROMOTE2 (CND::IFASTCBO_CONDITION, CLASSNAME, I_("getRDSPTransfer"));

	pRDSPTransfer = NULL;

	DString strKey (I_("RDSPTransfer"));
	pRDSPTransfer = dynamic_cast <RDSPTransfer*> (getObject (strKey, idDataGroup));

	if (isRDSPTransferAllowed (idDataGroup))
	{
		DString accountNum, transNum, transType, tradeDate, redCode, depositType;

		getField (ifds::AccountNum, accountNum, idDataGroup);
		getField (ifds::TransNum, transNum, idDataGroup);				
		getField (ifds::TradesTransType, transType, idDataGroup, false);
		getField (ifds::EffectiveDate, tradeDate, idDataGroup, false);
		getField (ifds::DepositType, depositType, idDataGroup,false);
		getField (ifds::RedCode, redCode, idDataGroup, false);
	
		SEVERITY severity = NO_CONDITION;
		bool bSetObject = false;

		if (!pRDSPTransfer && bCreate)
		{
			bSetObject = true;

			pRDSPTransfer = new RDSPTransfer (*this);

			if (isNew() || _bRebook)
			{
				severity = pRDSPTransfer->initNew (idDataGroup, accountNum, transNum, transType, tradeDate, depositType, redCode);
			}
			else
			{
				severity = pRDSPTransfer->init (accountNum, transNum, transType, tradeDate, depositType, redCode);

				DString dstrExtAccount, dstrExtSpecimenPlanNo, dstrNontaxContrib, dstrRollovers, dstrCDSGrant, dstrCDSBond;
				DString dstrCurrYrFMV, dstrPrevYrGrantBond, dstrPrevYrContrib, dstrPrevYrNonTaxRedAmt, dstrPrevYrTaxRedAmt, dstrCurrYrNonTaxRedAmt, dstrCurrYrTaxRedAmt;

				pRDSPTransfer->getField (ifds::ExtAccount, dstrExtAccount, idDataGroup, false);
				pRDSPTransfer->getField (ifds::ExtSpecimenPlanNo, dstrExtSpecimenPlanNo, idDataGroup, false);
				pRDSPTransfer->getField (ifds::NontaxContrib, dstrNontaxContrib, idDataGroup, false);
				pRDSPTransfer->getField (ifds::Rollovers, dstrRollovers, idDataGroup, false);
				pRDSPTransfer->getField (ifds::CDSGrant, dstrCDSGrant, idDataGroup, false);
				pRDSPTransfer->getField (ifds::CDSBond, dstrCDSBond, idDataGroup, false);
				pRDSPTransfer->getField (ifds::CurrYrFMV, dstrCurrYrFMV, idDataGroup, false);
				pRDSPTransfer->getField (ifds::PrevYrGrantBond, dstrPrevYrGrantBond, idDataGroup, false);
				pRDSPTransfer->getField (ifds::PrevYrContrib, dstrPrevYrContrib, idDataGroup, false);
				pRDSPTransfer->getField (ifds::PrevYrNonTaxRedAmt, dstrPrevYrNonTaxRedAmt, idDataGroup, false);
				pRDSPTransfer->getField (ifds::PrevYrTaxRedAmt, dstrPrevYrTaxRedAmt, idDataGroup, false);
				pRDSPTransfer->getField (ifds::CurrYrNonTaxRedAmt, dstrCurrYrNonTaxRedAmt, idDataGroup, false);
				pRDSPTransfer->getField (ifds::CurrYrTaxRedAmt, dstrCurrYrTaxRedAmt, idDataGroup, false);

				setFieldNoValidate (ifds::ExtAccount, dstrExtAccount, idDataGroup, false);
				setFieldNoValidate (ifds::ExtSpecimenPlanNo, dstrExtSpecimenPlanNo, idDataGroup, false);
				setFieldNoValidate (ifds::NontaxContrib, dstrNontaxContrib, idDataGroup, false);
				setFieldNoValidate (ifds::Rollovers, dstrRollovers, idDataGroup, false);
				setFieldNoValidate (ifds::CDSGrant, dstrCDSGrant, idDataGroup, false);
				setFieldNoValidate (ifds::CDSBond, dstrCDSBond, idDataGroup, false);
				setFieldNoValidate (ifds::CurrYrFMV, dstrCurrYrFMV, idDataGroup, false);
				setFieldNoValidate (ifds::PrevYrGrantBond, dstrPrevYrGrantBond, idDataGroup, false);
				setFieldNoValidate (ifds::PrevYrContrib, dstrPrevYrContrib, idDataGroup, false);
				setFieldNoValidate (ifds::PrevYrNonTaxRedAmt, dstrPrevYrNonTaxRedAmt, idDataGroup, false);
				setFieldNoValidate (ifds::PrevYrTaxRedAmt, dstrPrevYrTaxRedAmt, idDataGroup, false);
				setFieldNoValidate (ifds::CurrYrNonTaxRedAmt, dstrCurrYrNonTaxRedAmt, idDataGroup, false);
				setFieldNoValidate (ifds::CurrYrTaxRedAmt, dstrCurrYrTaxRedAmt, idDataGroup, false);
			}
		}

		if (severity <= WARNING && pRDSPTransfer)
		{
			if (severity <= WARNING)
			{
				if (bSetObject)
				{
					setObject (pRDSPTransfer, strKey, OBJ_ACTIVITY_NONE, idDataGroup); 
				}
			}
		else
		{
			delete pRDSPTransfer;
			pRDSPTransfer = NULL;
		}
	}
	}
	else 
	{		
		if (pRDSPTransfer != NULL)
		{
			if (!isNew ())
			{
				BFObjIter bfIter (*pRDSPTransfer, idDataGroup, false, BFObjIter::ITERTYPE::NON_DELETED);

				bfIter.begin();
				while (!bfIter.end())
				{
					bfIter.deleteObject ();
				}
			}
			else
			{
				BFObjIter bfIter (*this, idDataGroup);

				if (bfIter.positionByKey (strKey))
				{
					bfIter.removeObjectFromMap (true);
					pRDSPTransfer = NULL;
				}
			}
		}
	}

	return GETCURRENTHIGHESTSEVERITY();
}

//******************************************************************************
//              Revision Control Entries
//******************************************************************************
/* $Log:   Y:/VCS/BF iFAST/ifastcbo/Trade.cpp-arc  $
 *    Rev 1.1141   10 Aug 2012 13:07:50   if991250
 * Estate Allocation
 * 
 *    Rev 1.1140   Aug 01 2012 18:22:08   wp040133
 * Sync-up IN # 3045437 WO #809628
 * Error symbol but no description on why purchase trade is rejected
 * 
 *    Rev 1.1139   Jul 30 2012 09:08:20   wp040027
 * P0198518 - RDR Functionality - Review Comment incorporated
 * 
 *    Rev 1.1138   Jul 26 2012 10:37:18   wp040027
 * P0198518 - RDR Functionality
 * 
 *    Rev 1.1137   25 Jul 2012 17:49:56   if991250
 * P0186484 : Estate Allocation
 * 
 *    Rev 1.1136   Jul 11 2012 13:21:00   if991250
 * IN2984281 Split commission refresh for GI Attrib changes
 * 
 *    Rev 1.1135   Jul 10 2012 18:22:40   wp040039
 * PETP0201166- SSBG- Fund Broker validation
 * 
 *    Rev 1.1134   Jul 04 2012 15:15:44   wp040133
 * incident# :2988349 ,WO # :788196
 * Sync-up with 12.4 QAv Fix
 * 
 *    Rev 1.1133   Jul 03 2012 21:56:14   popescu
 * IN# 2984281 - iFeeTo is not populated
 * 
 *    Rev 1.1132   Jul 02 2012 10:53:06   kitticha
 * IN2984657 - GIA Rebook - Back-out the code, move to fix on view side.
 * 
 *    Rev 1.1131   Jul 02 2012 19:01:24   wp040132
 * P0199883_FN01_Cancellation Rights - Right To Cancel
 * 
 *    Rev 1.1130   Jun 29 2012 09:18:06   popescu
 * IN# 2984281 - iFeeTo is not populated
 * 
 *    Rev 1.1129   Jun 29 2012 07:17:58   panatcha
 * IN2984657 - GIA Rebook
 * 
 *    Rev 1.1128   Jun 26 2012 17:27:48   if991250
 * DSC Scale at Contract level
 * 
 *    Rev 1.1127   Jun 21 2012 19:01:42   dchatcha
 * IN# 2984281 - iFeeTo is not populated
 * 
 *    Rev 1.1126   Jun 08 2012 19:29:06   dchatcha
 * IN#2924829 - P186479FN05 GuaranteeOverride is still enabled, weird error meesage.
 * 
 *    Rev 1.1125   May 25 2012 16:12:50   dchatcha
 * IN#2924829 - P186479FN05 GuaranteeOverride is still enabled
 * 
 *    Rev 1.1124   May 22 2012 11:39:10   wp040027
 * Sync up: #IN 2873436 - After placing the Redemption trade, in the pending transaction history, valuation date displayed is incorrect.
 * 
 *    Rev 1.1123   May 18 2012 11:14:26   popescu
 * Incident 2959343 - R12.4 P187485-CPF - FKR-Redemption Trade
 * 
 *    Rev 1.1122   May 18 2012 09:42:34   popescu
 * Synch-ups from 12.3 :
 * 2947575 - Applying base commission (SFAC) for exchanges
 * 2889096 - Added "0" value to Comm. Reduction substitution set.
 * Also, remove the KIID flag, and remove the code of 1.1121
 * 
 *    Rev 1.1121   May 10 2012 18:02:38   wp040027
 * PETP0187485 - Trade Entry And Processing
 * 
 *    Rev 1.1120   May 10 2012 17:21:36   popescu
 * P0195754_FN01_ KIID_UCITs - KIID Validation
 * 
 *    Rev 1.1119   May 07 2012 11:18:22   wp040027
 * Sync up: IN2931247 - System errors out on adding a backdated trade and crytallising
 * 
 *    Rev 1.1118   May 07 2012 20:03:20   wp040043
 * P0195754_FN01_ KIID_UCITs - KIID Validation
 * 
 *    Rev 1.1117   May 07 2012 07:38:14   popescu
 * P0186486_FN15_The Source of Funds
 * 
 *    Rev 1.1116   May 04 2012 11:20:08   panatcha
 * P0186486_FN15_The Source of Funds
 * 
 *    Rev 1.1115   Apr 30 2012 07:46:00   wutipong
 * IN2831801 - more fix on trade modification
 * 
 *    Rev 1.1114   Apr 26 2012 17:43:32   if991250
 * Sending SuppressMVA, Suppress Admin fee, GrossNet and TradeAmount to vw 421 in inquiry modes
 * 
 *    Rev 1.1113   Apr 24 2012 21:23:24   wp040039
 * PETP0187485 - Trade Entry And Processing
 * 
 *    Rev 1.1112   Apr 23 2012 11:20:26   jankovii
 * Sync up: IN 2892108 - SOC 63 - Combine Principal and Interest for instructions Maturity and Interest
 * 
 *    Rev 1.1111   Apr 20 2012 03:10:30   panatcha
 * P0186486_FN15_The Source of Funds
 * 
 *    Rev 1.1110   Apr 18 2012 11:09:06   wutipong
 * IN2742442 - back off
 * 
 *    Rev 1.1109   Apr 17 2012 18:26:20   popescu
 * 2901148 - Gurantee Flag Override -synch-up from 12.3
 * 
 *    Rev 1.1108   Apr 11 2012 12:42:02   dchatcha
 * Synch up : IN# 2901157 - Issue on SEG Trade Processing, revise allocation related logics, IN# 2914672 - P0186479 Issues on Guarantee Override field on Trade Entry screen
 * 
 *    Rev 1.1107   Apr 10 2012 16:44:00   if991250
 * Money Out
 * 
 *    Rev 1.1106   Apr 10 2012 04:47:16   panatcha
 * P0186486FN09 - Employee and Agent Account Gap#8A
 * 
 *    Rev 1.1105   Apr 09 2012 23:22:02   panatcha
 * P0186486FN09 - Employee and Agent Account Gap#8A
 * 
 *    Rev 1.1104   Apr 06 2012 19:55:46   wutipong
 * IN2851692 Warning message fund currency
 * 
 *    Rev 1.1103   Apr 06 2012 08:26:24   panatcha
 * P0186486FN09 - Employee and Agent Account Gap#8A
 * 
 *    Rev 1.1102   Apr 04 2012 18:52:08   dchatcha
 * Synch up from few code change from R12.3
 * 
 *    Rev 1.1101   Mar 23 2012 05:58:20   panatcha
 * IN2889368_Next Interest Date display incorrectly
 * 
 *    Rev 1.1100   Mar 22 2012 11:29:36   if991250
 * IN 2892850 GI Pending trade inquiry sends TransNum as TransId in view 421
 * 
 *    Rev 1.1099   Mar 22 2012 09:22:26   if991250
 * IN 2885623 - GI Money Oout
 * 
 *    Rev 1.1098   Mar 22 2012 15:36:02   dchatcha
 * Synch up:P0186484 FN 05 - SEG Trade Processing, transfer validations during fund\class changed.
 * 
 *    Rev 1.1097   Mar 16 2012 13:44:34   dchatcha
 * Synch up: P0186484 FN05 - SEG Trade Processing, new validations.
 * 
 *    Rev 1.1096   Mar 15 2012 18:06:46   if991250
 * IN 2879297: Money Out
 * 
 *    Rev 1.1095   Mar 15 2012 06:56:36   wutipong
 * IN2831801 - Cut off time warning after update the deal time to be earlier than the cut-off time.
 * 
 *    Rev 1.1094   Mar 13 2012 17:51:48   dchatcha
 * P0186484 FN05 - SEG Trade Processing.
 * 
 *    Rev 1.1093   Mar 09 2012 16:41:58   dchatcha
 * P0186484 FN05 - SEG Trade Processing.
 * 
 *    Rev 1.1092   Mar 08 2012 17:47:28   if991250
 * GI Money Out
 * 
 *    Rev 1.1091   Mar 08 2012 12:37:42   jankovii
 * Sync up: IN 2859411 - P0186477_FN02_Interest Instruction-Err displayed on split type 'Amount' instrctn
 * 
 *    Rev 1.1090   Mar 08 2012 10:02:06   if991250
 * GI Money Out
 * 
 *    Rev 1.1089   Mar 05 2012 15:42:36   dchatcha
 * P0186484 FN05 - SEG Trade Processing.
 * 
 *    Rev 1.1088   Mar 05 2012 12:23:30   dchatcha
 * P0186484 FN05 - SEG Trade Processing.
 * 
 *    Rev 1.1087   Feb 23 2012 11:46:12   jankovii
 * IN 2817781- P0186477FN03- Commission Reduction on GI Trading
 * 
 *    Rev 1.1086   Feb 21 2012 13:47:38   jankovii
 * Sync up: IN 2837510 - P0186477 - Maturity Date & Interest Credit Date error on Pending Trade
 * 
 *    Rev 1.1085   Feb 07 2012 17:25:40   wutipong
 * IN2742442 - Update the trade order type to the current batch's when the fund does not have one.
 * 
 *    Rev 1.1084   Feb 03 2012 15:14:52   jankovii
 * Sync up: IN 2826242- Maturity/Interest Instruction on Trading Screen
 * 
 *    Rev 1.1068.1.12   Feb 03 2012 15:13:04   jankovii
 * Sync up: IN 2826242- Maturity/Interest Instruction on Trading Screen
 * 
 *    Rev 1.1068.1.11   Feb 03 2012 15:11:00   jankovii
 * IN 2826242- Maturity/Interest Instruction on Trading Screen
 * 
 *    Rev 1.1083   Feb 01 2012 18:28:42   wp040133
 * Incident 2829449 -R12.3 QA Stability
 * Uncommented the line which has accidently commented while checking for compilation issues.
 * 
 *    Rev 1.1082   Feb 01 2012 18:23:22   wp040133
 *  Incident 2829449 -R12.3 QA Stability 
 *  Removed the dynamic removal of Code 01 N/A  from enablePFCrystalisationFlag function
 *              
 * 
 *    Rev 1.1081   Jan 28 2012 02:34:18   kitticha
 * P0186477 FN03 - Removed the logic abt isGIFund.  1.1080 is not used.
 * 
 *    Rev 1.1080   Jan 27 2012 12:28:08   kitticha
 * P0186477 FN03 - Restore Forced Rate fixed.
 * 
 *    Rev 1.1079   Jan 27 2012 11:27:14   kitticha
 * Sync up - P0186477 FN03 IN2809372 - Estimated Rate is not returned.
 * 
 *    Rev 1.1078   Jan 27 2012 10:22:00   kitticha
 * Sync up - P0186477 FN03 IN2809372 - Estimated Rate is not returned.
 * 
 *    Rev 1.1077   Jan 25 2012 14:01:02   jankovii
 * Sync up: IN 2820320 - Rel12.2 PET0186477 - DIF Trade Entry Screen Issues
 * 
 *    Rev 1.1076   Jan 24 2012 08:09:52   kitticha
 * Sync up R12.2 - P0186477 FN03 IN2801549 - Forced Rate issues.
 * 
 *    Rev 1.1075   Jan 24 2012 16:17:18   dchatcha
 * Synch up : IN# 2809372 - Rel12.2 PET0186477- GIA Attributes screen to be made mandatory
 * 
 *    Rev 1.1074   Jan 23 2012 14:13:42   wp040027
 * P0186774 - MFOP-SOC (Enabling Accountability Code/Backdated Reason for pending trade in aggreagated/Price posted/Price Loaded state)
 * 
 *    Rev 1.1073   Jan 23 2012 12:09:08   jankovii
 * Sync up: IN 2813487 - P0186477FN03 - Cash Sweep DSK Issues
 * 
 *    Rev 1.1072   Jan 20 2012 15:45:38   wp040027
 * P0188394_Performance Fees - Order Entry
 * 
 *    Rev 1.1071   Jan 16 2012 15:40:32   if991250
 * GI Investment Details
 * 
 *    Rev 1.1070   Jan 12 2012 13:41:00   dchatcha
 * Synch up : IN# 2805412 - Rel12.2 PET0186477- GIA Trade Entry - Wire Order# Issue on Direct Trades
 * 
 *    Rev 1.1069   Jan 06 2012 13:39:04   if991250
 * IA money out
 * 
 *    Rev 1.1068   Dec 17 2011 19:43:38   wp040133
 *  P0192479 AFT out bOund Order Ehnacement
 * 
 *    Rev 1.1067   Dec 14 2011 15:43:40   jankovii
 * P0186477 FN03- GIA Maturity/Cash Sweep Instructions
 * 
 *    Rev 1.1066   Dec 13 2011 09:45:44   popescu
 * P0186477/03 - INA Commission Work
 * 
 *    Rev 1.1065   Dec 08 2011 21:48:54   wp040032
 * P0183989 - Money Market Non Receipt
 * 
 *    Rev 1.1064   Dec 07 2011 16:04:46   dchatcha
 * P0186477/FN03 - GIA - Purchase, rewrite logic on modify pending trade by using view 54 instead call to view 241
 * 
 *    Rev 1.1063   Dec 03 2011 13:46:20   dchatcha
 * P0186477/FN03 - GIA - Purchase - build error.
 * 
 *    Rev 1.1062   Dec 03 2011 11:03:42   dchatcha
 * P0186477/FN03 - GIA - Purchase, no longer use record CBO of progressive interest rate list.
 * 
 *    Rev 1.1061   Dec 03 2011 01:26:44   dchatcha
 * P0186477/FN03 - GIA - Purchase
 * 
 *    Rev 1.1060   Dec 01 2011 19:04:04   dchatcha
 * P0186477/FN03 - GIA - Purchase, calling to view 421 and 423
 * 
 *    Rev 1.1059   Nov 30 2011 18:03:24   dchatcha
 * P0186477/FN03 - GIA - Purchase, no need proxy fields and fix several issues found during test
 * 
 *    Rev 1.1058   Nov 30 2011 00:11:38   dchatcha
 * P0186477/FN03 - GIA - Purchase
 * 
 *    Rev 1.1057   Nov 28 2011 23:11:36   popescu
 * INA Commission Work
 * 
 *    Rev 1.1056   Nov 27 2011 19:43:12   popescu
 * INA Commission Work
 * 
 *    Rev 1.1055   Nov 18 2011 04:10:16   wutipong
 * IN2328150 HBP Orders for Non-Canadian Residents
 * 
 *    Rev 1.1054   Nov 11 2011 17:18:16   popescu
 * Seg-Non Seg co-mingling
 * 
 *    Rev 1.1053   Oct 27 2011 10:00:08   wutipong
 * IN2192577 Aggregated trade having different trade date.
 * 
 *    Rev 1.1051   Oct 25 2011 06:06:14   panatcha
 * IN2708311 - New Error Message should be "Beneficiary Address is Missing
 * 
 *    Rev 1.1050   Oct 24 2011 09:32:30   wp040027
 * Sync up: IN 2708695 - Manual response cannot be generated if trade has been aggregated
 * 
 *    Rev 1.1049   Oct 14 2011 12:26:08   panatcha
 * IN2689391 - [update] change field to EAPCESGPaid
 * 
 *    Rev 1.1048   Oct 13 2011 23:28:10   panatcha
 * IN2689391 - PET0185010_FN01: CESG Paid is tracked at the EAP level
 * 
 *    Rev 1.1047   Oct 13 2011 06:48:54   popescu
 * GIA - Trade Entry - prep work
 * 
 *    Rev 1.1046   Oct 06 2011 10:46:24   panatcha
 * P0185010FN01 - Beneficiary Allocations, EAP, LLP Withdrawals
 * 
 *    Rev 1.1045   Sep 23 2011 11:27:42   wp040027
 * Sync up: IN 2670216-Desktop Hard Edits for Transfer transactions-Implement Rule 36 only for Purchase and redemption
 * 
 *    Rev 1.1044   Sep 23 2011 08:58:10   wutipong
 * IN2560903 fixed is removed, as QA resources are fully booked for 12.1. The code will be reapplied to 12.2
 * 
 *    Rev 1.1043   Sep 16 2011 00:10:28   wutipong
 * IN2560903 - revised
 * 
 *    Rev 1.1042   Aug 16 2011 10:56:40   wutipong
 * IN2579232 EZN Bulking Testing -- Sync Up
 * 
 *    Rev 1.1041   Aug 08 2011 10:36:12   wp040027
 * Sync up: P0186774 - Mutual Fund Order Processing - Adding a new code in substitution set.
 * 
 *    Rev 1.1040   Aug 04 2011 11:12:08   wp040027
 * Sync up: P0186774 - Mutual Fund Order Processing
 * 
 *    Rev 1.1039   Jul 27 2011 05:46:48   wutipong
 * IN2560903 - Value Date reverts to default when user submitting trade
 * 
 *    Rev 1.1038   Jul 20 2011 15:29:46   wp040027
 * PET P0186065 - Aggregated Amount Orders via Swift- Implementation of Rule 36 on Fund
 * 
 *    Rev 1.1037   Apr 15 2011 14:58:58   jankovii
 * Sync up: IN 2495248 - Split Commission Issues on DSK
 * 
 *    Rev 1.1036   Apr 11 2011 15:59:00   jankovii
 * Sync up: IN 2475801 - Invalid split commission calculation
 * 
 *    Rev 1.1035   Apr 08 2011 18:44:40   dchatcha
 * P0182590 FN01 - Fund Level Currency Holidays, existing issue, sending tosettlecurrency and frmsettlecurrency to let common module return correct settlement date when trade date has changed.
 * 
 *    Rev 1.1034   Apr 08 2011 04:22:00   kitticha
 * PETP0179308_FN01_IN2487930_Desktop not support EFT Purchase Check paytype.
 * 
 *    Rev 1.1033   Mar 25 2011 14:59:14   jankovii
 * Sync up: IN 2475801 - Invalid split commission calculation
 * 
 *    Rev 1.1032   Mar 14 2011 11:12:18   jankovii
 * Sync up: IN 2458927 - P0181943 - SWIFT XML - Split Commission Exchanges
 * 
 *    Rev 1.1031   Mar 11 2011 10:53:16   kitticha
 * IN2450642 - Modify program to support fund-class hierarchy.
 * 
 *    Rev 1.1030   Mar 11 2011 04:23:36   panatcha
 * IN2393911_WO594056  Bank Charges field not defaulting correctly
 * 
 *    Rev 1.1029   Mar 09 2011 10:41:58   jankovii
 * Sync up: PET181943 FN01 - XMLPhase 2
 * 
 *    Rev 1.1022.1.5   Mar 09 2011 10:39:56   jankovii
 * PET181943 FN01 - XMLPhase 2
 * 
 *    Rev 1.1028   Mar 07 2011 08:30:28   kitticha
 * IN2450642 - Fund validation by default sub paytype & EFT Purchase Cheque.
 * 
 *    Rev 1.1027   Mar 03 2011 11:02:24   dchatcha
 * Synch up: IN#2447057 - R11.3PR-PET0179308FN01-Cannot creat new EFT Purchase bank at trade, force FileProcessing field on trade banking get update when there is a change at trade level. 
 * 
 *    Rev 1.1026   Feb 18 2011 04:39:20   kitticha
 * PET0165541_FN12_IN2385316 - Default the assisted contribution amount for ED 78(same as PW Q1).
 * 
 *    Rev 1.1025   Feb 07 2011 18:49:00   dchatcha
 * Synch up : P0179308 FN01 - Multi Manager Subscription and Direct Debit Payment.
 * 
 *    Rev 1.1024   Jan 31 2011 18:38:48   dchatcha
 * Synch up : P0179308 FN01 - Multi Manager Subscription and Direct Debit Payment.
 * 
 *    Rev 1.1023   Jan 17 2011 02:14:18   wutipong
 * IN2324579 - Invalid Value Date
 * 
 *    Rev 1.1022   Dec 02 2010 15:41:30   jankovii
 * PET171086 FN01 Red Flag Report
 * 
 *    Rev 1.1021   Dec 01 2010 09:38:14   jankovii
 * Synn up: IN 2339847 - Error when enter AIP redemption with code 79 or 80 for Family Plan RESP acct
 * 
 *    Rev 1.1020   Nov 30 2010 00:11:46   kitticha
 * IN#2291872 - Release 99, QESI project. Q1 and Q2 redemption cannot deplete more than balance.
 * 
 *    Rev 1.1019   Nov 26 2010 09:04:36   panatcha
 * P0178201FN01_WaiveDSCforClosedFund
 * 
 *    Rev 1.1018   Nov 22 2010 13:21:16   jankovii
 * PET175778 FN01 - Upstreaming Phase 2
 * 
 *    Rev 1.1017   Nov 04 2010 11:00:02   kitticha
 * IN#2314478 - P173756FN02- No message display when processing transfer.
 * 
 *    Rev 1.1016   Oct 29 2010 05:04:16   kitticha
 * PET0165541 FN03 - QESI Phase3.
 * 
 *    Rev 1.1015   Oct 22 2010 10:57:20   jankovii
 * IN 2297013 - RESP AIP for Joint Account - trade entry issues
 * 
 *    Rev 1.1014   Oct 19 2010 04:29:48   dchatcha
 * Synch up : IN# 2290656 - Tax year shld default to year of trade date when processing manual PW78. Took edit check where resp contribution detail tax year is the same with trade year for redemption code 78,Q1,Q2, and Q3
 * 
 *    Rev 1.1013   Oct 07 2010 11:35:54   jankovii
 * PET0175377 FN01 AIP for Joint RESP Account
 * 
 *    Rev 1.1012   Sep 30 2010 23:32:08   dchatcha
 * Synch up: IN# 2216947 - QESI Phase 2a - cancelling a pending trade on desktop.
 * 
 *    Rev 1.1011   Sep 29 2010 11:32:28   jankovii
 * PET0175377 FN01 - AIP for Joint RESP Account
 * 
 *    Rev 1.1010   Sep 24 2010 14:33:16   jankovii
 * PET0175377 FN01 - AIP for Joint RESP Account
 * 
 *    Rev 1.1009   Sep 21 2010 06:46:30   kitticha
 * PETP0173756 FN02 Don't Bust the Rules - few changes.
 * 
 *    Rev 1.1008   Sep 17 2010 07:57:50   kitticha
 * PETP0173756 FN02 Don't Bust the Rules.
 * 
 *    Rev 1.1007   Sep 01 2010 13:45:28   jankovii
 * IN 2234834 - RESP desktop - Transfer with no specimen and contract #s not rejected by system
 * 
 *    Rev 1.1006   Aug 20 2010 03:02:50   dchatcha
 * IN# 2209529 - User should not be able to add QESI Basic or QESI Increase for current year.
 * 
 *    Rev 1.1005   Jun 28 2010 10:00:46   kitticha
 * in#2123752 - Additional specific error for PSE.
 * 
 *    Rev 1.1004   Jun 25 2010 04:04:04   kitticha
 * IN#2165227 - Validation for PSE fields.
 * 
 *    Rev 1.1003   Jun 24 2010 07:41:44   dchatcha
 * PET0165541 FN09 QESI RESP phase2B - SOC04 - Eligible Transfer on RESP Transfer screen.
 * 
 *    Rev 1.1002   Jun 18 2010 03:23:26   kitticha
 * iN#2123752 - PSE additional fix.
 * 
 *    Rev 1.1001   Jun 11 2010 07:11:46   kitticha
 * PETP0165541 FN02 IN#2123752 - PSE Fix.
 * 
 *    Rev 1.1000   Jun 08 2010 11:02:14   jankovii
 * Sunc up: IN 2124688 - PETP0165541 -  Dep Code 17 - Account Level Override.
 * 
 *    Rev 1.999   Jun 04 2010 04:07:18   kitticha
 * Synch up some QESI missing.
 * 
 *    Rev 1.998   Jun 04 2010 03:58:38   kitticha
 * IN#2123752 - Additional logic and validation for PSE.
 * 
 *    Rev 1.997   Jun 01 2010 04:25:06   dchatcha
 * Synch up from 1.972.1.37 : IN# 2139515 - PET0165541- Missing Grant Repayment Warning for Full Transfer Redeem, remove space character from literal string which is compared with redmption code.
 * 
 *    Rev 1.996   May 27 2010 06:29:58   kitticha
 * PETP0165541 FN02 QESI Phase2.
 * 
 *    Rev 1.995   May 26 2010 08:16:12   kitticha
 * QESI Synch-up for 1.972.1.36 - TaxYear Validation.
 * 
 *    Rev 1.994   May 14 2010 14:54:24   popescu
 * QESI synch-up for 1.972.1.35
 * 
 *    Rev 1.993   May 10 2010 10:25:46   popescu
 * QESI synch-up for 1.972.1.33
 * 
 *    Rev 1.992   May 07 2010 17:00:26   yingz
 * fix IN2104715 - AWD missing from GC & IN2046612 - GETPRICE Persistance issue
 * 
 *    Rev 1.991   Apr 30 2010 17:49:16   popescu
 * Fixed compile error...
 * 
 *    Rev 1.990   Apr 30 2010 17:06:02   popescu
 * RES-QESI Trading - PSE/EAP work - synch-up with 1.972.1.30
 * 
 *    Rev 1.989   Apr 30 2010 16:50:56   popescu
 * RES-QESI Trading - PSE/EAP work - synch-up with 1.972.1.30
 * 
 *    Rev 1.988   Apr 30 2010 08:37:14   dchatcha
 * Fix revision history.
 * 
 *    Rev 1.987   Apr 30 2010 08:22:42   kitticha
 * PET0165541 FN01 QESI RESP Trading - Sync up 1.972.1.29.
 * 
 *    Rev 1.986   Apr 29 2010 11:58:08   kitticha
 * PET0165541 FN01 QESI RESP Trading - 1.972.1.27.
 * 
 *    Rev 1.985   Apr 29 2010 11:11:40   kitticha
 * PET0165541 FN01 QESI RESP Trading - Sync up 1.972.1.25 and 1.972.1.26.
 * 
 *    Rev 1.984   Apr 27 2010 11:15:12   kitticha
 * PET0165541 FN01 QESI RESP Trading - Sync up 1.972.1.24.
 * 
 *    Rev 1.983   Apr 26 2010 14:17:20   kitticha
 * PET0165541 FN01 QESI RESP Trading - Sync up 1.972.1.23.
 * 
 *    Rev 1.982   Apr 22 2010 08:02:48   kitticha
 * PET0165541 FN01 QESI RESP Trading - Sync up 1.972.1.17
 * 
 *    Rev 1.981   Apr 22 2010 07:36:04   dchatcha
 * Fix Compile error.
 * 
 *    Rev 1.980   Apr 22 2010 04:34:34   dchatcha
 * Rel QESI - Synch-up from 1.972.1.16.0
 * 
 *    Rev 1.979   Apr 20 2010 10:30:08   popescu
 * RQESI - Synch-up from 1.972.1.12.0
 * 
 *    Rev 1.978   Apr 19 2010 10:33:54   popescu
 * Rel QESI - synch-ups
 * 
 *    Rev 1.977   Apr 19 2010 09:47:34   popescu
 * RQESI - Synch-up from 1.972.1.11.0
 * 
 *    Rev 1.976   Mar 31 2010 07:35:28   dchatcha
 * Synch up from 1.972.1.8 0 PET165541_FN01_QESI - RESP Gap_Dsk.
 * 
 *    Rev 1.975   Mar 30 2010 01:13:02   dchatcha
 * Synch up from 1.972.1.6 0 PET165541_FN01_QESI - RESP Gap_Dsk - Fix compile error.
 * 
 *    Rev 1.974   Feb 12 2010 09:57:00   dchatcha
 * P0166183 FN03 - CUSIP Rollver, New Purchase like trade type.
 * 
 *    Rev 1.973   Feb 11 2010 22:26:14   wutipong
 * IN1978351 - INS Error Received On Trades  
 * 
 *    Rev 1.972   Jan 29 2010 16:22:56   popescu
 * Incident 1995938 - Unable modify Settlement Date while entering a trade - re-synch of incident 1936159
 * 
 *    Rev 1.971   Jan 25 2010 16:30:56   yingz
 * merge 1.969.1.0 code
 * 
 *    Rev 1.970   Jan 18 2010 15:08:28   wutipong
 * IN1911746 - SG2 - Potential Bug Discovered In The Modify Screen On Pending Trades
 * 
 *    Rev 1.969   Dec 29 2009 14:27:08   popescu
 * Incident 1936159 - refresh of value date and settlement date in pending mode - synch-up
 * 
 *    Rev 1.968   Dec 22 2009 10:16:16   jankovii
 * PET0166095 FN01 Validations on Money Out Transactions
 * 
 *    Rev 1.967   Dec 18 2009 15:57:34   jankovii
 * PET0166095 FN01 Validations on Money Out Transactions
 * 
 *    Rev 1.965   Dec 10 2009 23:20:40   dchatcha
 * PET0166583 FN02 FN03 - Static Verification Phase 2. Core review, move all of logic from Redemption object to Trade object.
 * 
 *    Rev 1.964   Dec 08 2009 14:46:42   popescu
 * In#1737120 - code sync up - and extra fix.
 * 
 *    Rev 1.963   Dec 08 2009 12:13:12   popescu
 * Incident 1936496 - Showstopper Desktop Trade Entry
 * 
 *    Rev 1.962   Dec 02 2009 14:56:44   popescu
 * Prepare the terrain for incident 1780456, which will go in release 98 
 * 
 *    Rev 1.961   Nov 26 2009 14:24:36   popescu
 * Incident 1914638 - Critical - Value Date issue in UAT - Critical
 * 
 *    Rev 1.960   Nov 25 2009 11:08:40   wutipong
 * In#1737120 - code sync up.
 * 
 *    Rev 1.959   Nov 24 2009 15:04:04   jankovii
 * Sync up: IN 1923859 - IFAST desktop prod, trade input not possible.
 * 
 *    Rev 1.958   Nov 23 2009 16:19:20   jankovii
 * PET0166583 FN01 Static Data Changes_Banking information.
 * 
 *    Rev 1.957   Nov 03 2009 14:06:00   yingz
 * fix incident 1890397. support more networkid in Trade::setOtherConfirmTypeDefaultValues method
 * 
 *    Rev 1.956   Oct 23 2009 17:57:22   popescu
 * Incident 1874666 - Rel 95 - PET 156681 FN04 - H4_H6_H8 -Default responsibility date to current date
 * 
 *    Rev 1.955   Oct 20 2009 16:04:38   popescu
 * Incident 1874818 - do not send the currency notification - this causes the trans fee list to refresh when there is no need .
 * 
 *    Rev 1.954   Oct 16 2009 11:59:06   popescu
 * IN# 1628727 - Configuration Issue with iFAST Desktop, Code review.
 * 
 *    Rev 1.953   Oct 02 2009 09:14:40   dchatcha
 * IN# 1628727 - Configuration Issue with iFAST Desktop, Code review.
 * 
 *    Rev 1.952   Oct 01 2009 10:24:00   dchatcha
 * IN# 1628727 - Configuration Issue with iFAST Desktop, Code review.
 * 
 *    Rev 1.951   Sep 30 2009 13:07:50   dchatcha
 * IN# 1628727 - Configuration Issue with iFAST Desktop.
 * 
 *    Rev 1.950   Sep 30 2009 06:53:20   dchatcha
 * IN# 1595165 - Rebooking functionality where contr rcpt was issued not working properly.
 * 
 *    Rev 1.949   Sep 21 2009 17:43:12   popescu
 * Added support for launching the Trading screen if mapping for pruchase and redeem work types exists in the AWD Ini file
 * 
 *    Rev 1.948   Sep 21 2009 16:05:42   popescu
 * Added support for launching the Trading screen if mapping for pruchase and redeem work types exists in the AWD Ini file
 * 
 *    Rev 1.947   Sep 14 2009 09:00:34   popescu
 * Incident 1829401 - Value Date incorrect after changing Settlement Date and Order Type
 * 
 *    Rev 1.946   Aug 26 2009 12:10:58   dchatcha
 * Back dated trade issues of IA, no incident number yet.
 * 
 *    Rev 1.945   17 Aug 2009 10:38:48   popescu
 * IN#1686644 - R92_PET5517_FN94D - cannot save manual FC in Desktop - revised the code a little bit
 * 
 *    Rev 1.944   Aug 17 2009 08:31:34   dchatcha
 * IN#1686644 - R92_PET5517_FN94D - cannot save manual FC in Desktop.
 * 
 *    Rev 1.943   Aug 14 2009 14:09:38   jankovii
 * PET0164824 FN01 - Eiger iShares Orders and ETF Fields
 * 
 *    Rev 1.942   Aug 13 2009 15:56:24   jankovii
 * PET0164824 FN01 - Eiger iShares Orders and ETF Fields
 * 
 *    Rev 1.941   12 Aug 2009 19:56:00   popescu
 * PET0164824 FN01 - Eiger iShares Orders and ETF Fields
 * 
 *    Rev 1.940   12 Aug 2009 17:40:26   popescu
 * PET0164824 FN01 - Eiger iShares Orders and ETF Fields
 * 
 *    Rev 1.939   Aug 11 2009 13:58:36   jankovii
 * PET0164824 FN01 - Eiger iShares Orders and ETF Fields
 * 
 *    Rev 1.938   27 Jul 2009 15:15:02   popescu
 * Project Eiger - P0147738 FN36 - Adding a field to figure out when the multiple settle locations should show up
 * 
 *    Rev 1.937   Jul 16 2009 19:25:20   dchatcha
 * PET156681 FN14 H36 Investor Authorization, Code Review.
 * 
 *    Rev 1.936   29 Jun 2009 17:03:48   popescu
 * PET 156681 - FN 14 - Investor Authorization
 * 
 *    Rev 1.935   29 Jun 2009 16:30:36   popescu
 * Incident  1725375 - fixed the recalculatin of the trade if the order type is flippend back and forth between wire and direct - synch-up
 * 
 *    Rev 1.934   Jun 26 2009 06:53:30   kitticha
 * IN#1738640 - R94 - Country Schedule - Cannot modify TX even when FundFrom and FundTo are same
 * 
 *    Rev 1.933   Jun 25 2009 05:06:44   wutipong
 * IN1680804 -- Prevents trade to have To account as RESP or Family RESP account.
 * 
 *    Rev 1.932   15 Jun 2009 15:27:08   popescu
 * PET157837 FN02 - Country Schedule Daily Non Resident Schedule A
 * 
 *    Rev 1.931   15 Jun 2009 08:19:58   popescu
 * PET157837 FN02 - Country Schedule Daily Non Resident Schedule A - revised the code
 * 
 *    Rev 1.930   12 Jun 2009 12:01:00   popescu
 * PET157837 FN02 - Country Schedule Daily Non Resident Schedule A - revised the code
 * 
 *    Rev 1.929   10 Jun 2009 18:44:10   popescu
 * PET 157825 FN04 Manual RRIF Redemption - fixed a stability testing issue.
 * 
 *    Rev 1.928   10 Jun 2009 18:35:12   popescu
 * PET157837 FN02 - Country Schedule Daily Non Resident Schedule A - revised the code
 * 
 *    Rev 1.927   Jun 09 2009 06:08:56   kitticha
 * PET157837 FN02 - Country Schedule Daily Non Resident Schedule A
 * 
 *    Rev 1.926   May 27 2009 15:13:10   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.925   May 26 2009 15:59:34   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.924   May 26 2009 14:20:56   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.923   May 22 2009 10:35:38   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.922   May 22 2009 10:18:54   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.921   May 20 2009 11:02:26   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.920   May 19 2009 14:23:56   jankovii
 * PET 159770 FN05 Auto Batching.
 * 
 *    Rev 1.919   Apr 30 2009 06:08:12   dchatcha
 * Synch up : IN 1673707 - R93 Regression - mifmarqa - inconsistent error msg.
 * 
 *    Rev 1.918   28 Apr 2009 13:32:12   popescu
 * Incident 1605422 - correctly refresh the value date - synch-up from release 92
 * 
 *    Rev 1.917   Apr 17 2009 10:49:54   jankovii
 * PET 157825 FN04 Manual RRIF Redemption.
 * 
 *    Rev 1.916   Mar 13 2009 00:40:50   wutipong
 * IN1581414 - Issue found while working on Incident 1568480
 * 
 *    Rev 1.915   Mar 11 2009 17:45:52   wutipong
 * IN1358908 AIG Unit Rounding Issue -- restrict user to enter decimal longer than fund unit precision to amount field, if amount type is Units.
 * 
 *    Rev 1.914   26 Jan 2009 15:04:08   popescu
 * Incident 1411814 - fixes related to the refresh of value date
 * 
 *    Rev 1.913   Jan 21 2009 12:02:16   jankovii
 * PET5517_FN94_Foreign Exchange Allocated Capital Gains
 * 
 *    Rev 1.912   Jan 19 2009 18:21:16   wongsakw
 * IN1411814 -- Unable to modify Value Date on Pending Trades (revised)
 * 
 *    Rev 1.911   Dec 23 2008 17:16:26   wongsakw
 * IN1393123 -- Non same day Switches not being settled through cycle autosettlement
 * 
 * More changes based on Serban's suggestion.
 * 
 *    Rev 1.910   Dec 19 2008 17:11:20   wongsakw
 * IN1393123 Non same day switches not being settled through cycle autosettlement
 * 
 *    Rev 1.909   Dec 02 2008 15:13:04   jankovii
 * Sync up: PET 142196 FN01 Federal Restricted LIF and LIRA.
 * 
 *    Rev 1.908   04 Nov 2008 15:41:44   kovacsro
 * R92 - IN#1186158 - GL-652 Redemption Issue - System picking up inactive banking info
 * 
 *    Rev 1.907   06 Oct 2008 13:20:12   kovacsro
 * PET142007  FN01 TFSA
 * 
 *    Rev 1.906   01 Oct 2008 12:06:40   popescu
 * Check in for code  1419539
 * 
 *    Rev 1.905   Sep 11 2008 06:21:38   wongsakw
 * IN 1222816 remove the fix being done in revision rev1.889.1.5 (this revision has been record with incorrect incident number (1121816)).
 * 
 *    Rev 1.904   09 Sep 2008 16:15:12   kovacsro
 * IN#1399886 - using user permission and setting default always to "N"
 * 
 *    Rev 1.903   03 Sep 2008 09:05:08   kovacsro
 * IN#1375331 - RcptStatus
 * 
 *    Rev 1.902   06 Aug 2008 16:05:22   kovacsro
 * Removed the code added in rev. 1.895: IN1307162 Incorrect warning message for transfers with transaction level settlement detail
 * 
 *    Rev 1.901   23 Jul 2008 11:28:20   kovacsro
 * PET0095436_FN01_Rounding (commented out code)
 * 
 *    Rev 1.900   17 Jul 2008 14:22:34   kovacsro
 * PET5517 FN60C Cancellation of Contribution Receipts - Rebooking
 * 
 *    Rev 1.899   Jul 10 2008 05:21:38   wongsakw
 * IN1121816 - Pay Instrcution option field set to 'Redirect to Entity' only if the Pay Type is EFT.
 * 
 *    Rev 1.898   18 Jun 2008 15:12:58   popescu
 * IN 1315727 -- Change the key of the ExchRateList to call view 134 when input parameters are modified.
 * 
 *    Rev 1.897   Jun 17 2008 07:14:30   wongsakw
 * IN 1315727 -- Add code fix to set Amount field to be invalid when ExchRate is changed.
 * 
 *    Rev 1.896   16 Jun 2008 16:48:22   popescu
 * Incident# 1315311 - param the Exact Date input field for view 134 that reads the exchange rates
 * 
 *    Rev 1.895   Jun 16 2008 14:58:12   wongsakw
 * IN1307162 Incorrect warning message for transfers with transaction level settlement detail
 * 
 *    Rev 1.894   Jun 13 2008 16:19:52   wongsakw
 * IN1287034 - Explain how settledate is assigned to direct trades
 * 
 *    Rev 1.893   Jun 09 2008 08:14:16   daechach
 * IN # 1283327 - Trade created with invalid settlement date, Synched up from R85
 * 
 *    Rev 1.892   03 Jun 2008 15:30:40   kovacsro
 * restored rev. 1.889
 * 
 *    Rev 1.889   27 May 2008 15:33:04   kovacsro
 * IN#1053526 - moved warning from Trade Date to Clearing Method field
 * 
 *    Rev 1.888   27 May 2008 13:27:48   kovacsro
 * IN#1053526  - validation for default settlement instructions always needed
 * 
 *    Rev 1.887   May 23 2008 04:25:38   wongsakw
 * IN 108923 Back-Dated Exchanges Being Sticky
 * 
 *    Rev 1.886   May 07 2008 14:21:16   wongsakw
 * IN1218721 Bank information incorrectly Displayed
 * 
 *    Rev 1.885   01 May 2008 13:58:00   kovacsro
 * PET2255 FN47 - New Ontario LIF - finalized
 * 
 *    Rev 1.884   Apr 28 2008 17:31:50   wongsakw
 * Sync up : IN1235049 -- SSIIL iFAST UAT issue - Unsettled Units Redemption Validation fx issue
 * 
 *    Rev 1.883   22 Apr 2008 11:25:18   kovacsro
 * IN#1053526 - fixed the code introduced under IN#1158727&1201541
 * 
 *    Rev 1.882   15 Apr 2008 12:10:20   kovacsro
 * PET2255 FN47 - New Ontario LIF
 * 
 *    Rev 1.881   Mar 26 2008 15:07:14   wongsakw
 * IN 1201541 - Add checking for frClearingMethod. If this field is not empty, the default instruction validation will not be done (since the using instruction is not the default one). 
 * 
 * This will allow user to switch instruction to either non-default instruction, or create an ad-hoc transaction lv instruction.
 * 
 *    Rev 1.880   Mar 11 2008 20:15:50   daechach
 * PET2385FN02&07 - Account Level Settlement Periods and Currency Holiday - Check in for Build.
 * 
 *    Rev 1.879   Feb 27 2008 20:15:08   wongsakw
 * Inc#1158727 Default PayType Transfer with expired sett details : Sync up
 * 
 *    Rev 1.878   Feb 20 2008 09:42:14   jankovii
 * PET 2385 FN06 Bank Details upload.
 * 
 *    Rev 1.877   Jan 29 2008 17:34:02   wongsakw
 * Inc#1158727 -- Default PayType Transfer with expired sett details : move sett instr expiry check to trade date field.
 * 
 *    Rev 1.876   Jan 25 2008 15:47:42   jankovii
 * Sync up IN   1156376 - corrupted banking details.
 * 
 *    Rev 1.875   Jan 21 2008 15:14:02   jankovii
 * IN 1155963 - AXA warning msg.
 * 
 *    Rev 1.874   17 Jan 2008 07:53:16   popescu
 * Incident  - 1152508 - do not set the default pay method if already read at the pay entity level
 * 
 *    Rev 1.873   Jan 10 2008 17:59:22   daechach
 * in#1143330 - Delivery type Direct-ICS
 * 
 *    Rev 1.872   09 Dec 2007 21:26:22   popescu
 * Incident 1109322 - moved iterator outside of the if statement to prevent an infinite loop
 * 
 *    Rev 1.871   Nov 30 2007 16:23:02   jankovii
 * Sync up. IN 1098169 - Mgmt Fee payment option.
 * 
 *    Rev 1.870   Nov 07 2007 12:09:34   daechach
 * PET 5614 FN 01 - Acct Level Override for Clearing Settle Method
 * 
 *    Rev 1.869   Nov 06 2007 10:46:06   jankovii
 * IN 1053528 & 1053527 - SSIIL iFAST UAT issue - Default Pay Type transfer clearing to non-clearing acct.
 * 
 *    Rev 1.868   Oct 30 2007 14:38:52   jankovii
 * IN1053519 - SSIIL iFAST UAT issue - Delivery To field of Settlement Instructions not populated.
 * 
 *    Rev 1.867   Oct 30 2007 11:29:12   jankovii
 * IN 1053527 & 1053528 - SSIIL iFAST UAT issue - Default Pay Type transfer clearing to non-clearing acct.
 * 
 *    Rev 1.866   Oct 24 2007 14:57:04   jankovii
 * IN #1047594 - Fund Level Override not working for manual exchanges.
 * 
 *    Rev 1.865   Oct 12 2007 11:14:18   jankovii
 * IN #1003910 - Transaction Type OR one Single value for all transaction type.
 * 
 *    Rev 1.864   Oct 08 2007 12:16:48   smithdav
 * IN  1005517,1020252 - LRSP logic
 * 
 *    Rev 1.863   Sep 25 2007 12:11:26   jankovii
 * IN #1012154 - Non same day Switch Settlements Testing.
 * 
 *    Rev 1.862   11 Sep 2007 14:43:20   popescu
 * Changed the value of the company code from AIS to ATS
 * 
 *    Rev 1.861   07 Sep 2007 09:50:14   popescu
 * GAP 18 - added manual management fee rebate to manual dividend screen
 * 
 *    Rev 1.860   Sep 07 2007 09:21:56   jankovii
 * IN #936175 - No business day record available.
 * 
 *    Rev 1.859   Sep 05 2007 14:42:18   jankovii
 * IN #953708 - Unable to change Settle Out and Settle In dates at the same time.
 * 
 *    Rev 1.858   Aug 14 2007 18:18:32   smithdav
 * Move to common init and use current datagroup.
 * 
 *    Rev 1.857   Aug 13 2007 11:45:32   smithdav
 * Fix compile error.
 * 
 *    Rev 1.856   Aug 13 2007 11:40:14   smithdav
 * PET 2360 FN.   Customize DeliveryMethod values for AIM
 * 
 *    Rev 1.855   Aug 10 2007 14:10:42   jankovii
 * PET 2360 FN14&FN19 - Management Fee.
 * 
 *    Rev 1.854   Aug 07 2007 15:41:26   jankovii
 * Gaps 14 & 19 PET 2360 -MF.
 * 
 *    Rev 1.853   02 Aug 2007 11:09:28   popescu
 * Incident # 943174 - With this change, the system will work the same way at the Trade Entry screen for users placing trades in Clearing accounts with or without settlement instructions.  
 * The functionality will also be in line with the way bank account details get applied to manual trades in instances where there are no active account level bank details.  
 * 
 * 
 *    Rev 1.852   01 Aug 2007 15:59:16   popescu
 * Incident # 956780 - mgfeerebate should always be direct
 * 
 *    Rev 1.851   27 Jul 2007 16:05:14   popescu
 * Incident 948449 - disabled the last EFT banking records call
 * 
 *    Rev 1.850   24 Jul 2007 20:13:36   popescu
 * GAP 20 -22 AIM
 * 
 *    Rev 1.849   23 Jul 2007 16:50:06   popescu
 * PET 2360 - FN 20 - GAP 20 Soft cap functionality
 * 
 *    Rev 1.848   12 Jul 2007 17:10:08   popescu
 * AIM GAP 2 AMS - added an extra field to trading CloneAcctAMS - used in AllTransfer to copy AMS to the to acct.
 * 
 *    Rev 1.847   Jul 10 2007 16:14:04   jankovii
 * Incident #938455 - settlement currency issue.
 * 
 *    Rev 1.846   15 Jun 2007 14:57:42   popescu
 * Incident# 913230 - matching SINs determine if the account owner are the same - if  CSSStopSINMatch GC is turned on.
 * 
 *    Rev 1.845   Jun 05 2007 13:19:46   jankovii
 * Incident #907787-SSIIL - Bulking and Netting Pay Entity Setup Issue
 * 
 *    Rev 1.844   May 09 2007 16:06:08   jankovii
 * MT54X PET2321 FN03 -Participant Transfer.
 * 
 *    Rev 1.843   May 07 2007 16:51:12   porteanm
 * Incident 847011 - For Partnerworld, OtherConfirmType is now 3 (Create PWLD Confirm).
 * 
 *    Rev 1.842   May 04 2007 13:55:24   jankovii
 * PET 2321 FN01 - MT54X Default Pay Type.
 * 
 *    Rev 1.841   Mar 30 2007 14:07:50   jankovii
 * PET 2292 FN01 - Switch Settlement.
 * 
 *    Rev 1.839   Mar 27 2007 18:42:22   jankovii
 * PET 2292 FN01 - Switch Settlement.
 * 
 *    Rev 1.838   Mar 26 2007 11:08:02   jankovii
 * PET 2292 FN01 - Switch Settlement.
 * 
 *    Rev 1.837   Mar 21 2007 13:25:42   jankovii
 * PET 2292 FN01 - Switch Settlement.
 * 
 *    Rev 1.836   Mar 14 2007 14:41:28   jankovii
 * PET 2292 FN01 - Switch Settlement.
 * 
 *    Rev 1.835   Feb 26 2007 15:38:36   ZHANGCEL
 * Incident #829136 -- Commend out logic to check pair
 * 
 *    Rev 1.834   Dec 20 2006 15:16:20   popescu
 * Incident #780304 -- Initialize date with proper values
 * 
 *    Rev 1.833   Dec 14 2006 16:47:04   ZHANGCEL
 * Incident #780304 -- Clean up a improper comment
 * 
 *    Rev 1.832   Dec 14 2006 14:55:02   ZHANGCEL
 * Incident #780304 -- Fix problem for AllFundTransfer
 * 
 *    Rev 1.831   Nov 09 2006 00:08:20   popescu
 * PET 2281/Fn01 - cloning account - TA  synch-up from rel 73
 * 
 *    Rev 1.830   Nov 02 2006 14:53:04   popescu
 * PET2258 FN01 -- Deal Date Deal Time related changes - modified the way desktop checks if a trade is backdated - now it looks at the NextValDate of the fund, instead of the default trade date - returned by vew 135
 * 
 *    Rev 1.829   Nov 02 2006 11:11:40   popescu
 * PET 2251/01 - added RBCD to Network Order - and few checks
 * 
 *    Rev 1.828   Oct 30 2006 17:06:20   jankovii
 * PET 2185 FN04 - Trade restrictions.
 * 
 *    Rev 1.827   Oct 19 2006 16:00:46   popescu
 *  Incident #697014 -- Fix Death redemtion issue
 * 
 *    Rev 1.826   Oct 19 2006 15:49:38   popescu
 * Incident# 716747 - value date override fix
 * 
 *    Rev 1.825   Oct 19 2006 15:34:54   popescu
 * Incident# 722294 - users will be able to override the trade payment instructions with system cheque
 * 
 *    Rev 1.824   Oct 06 2006 13:38:56   popescu
 * Incident# 729080 - refreshed banking once pending trade settle currency gets changed
 * 
 *    Rev 1.823   Oct 03 2006 22:25:54   popescu
 * Incident #722094 - raise warn msgs if payment instr missing for either pw or id
 * 
 *    Rev 1.822   Sep 30 2006 00:54:34   popescu
 * Incident 720294 - pay entity eff. dates
 * 
 *    Rev 1.821   Sep 22 2006 16:08:28   popescu
 * Incident# 639692 - removed the validation for other confirm type = '2' for network id partnerworld
 * 
 *    Rev 1.820   Sep 18 2006 12:20:44   popescu
 * STP 2217/fn 13 - fix the modify pending trade crash - trade pay instruct.
 * 
 *    Rev 1.819   Sep 18 2006 00:25:34   popescu
 * STP Pet 2217/13
 * 
 *    Rev 1.818   Sep 15 2006 19:43:10   popescu
 * STP 2217/13 - fixes
 * 
 *    Rev 1.817   Sep 13 2006 19:11:22   popescu
 * STP 2192/FN 13
 * 
 *    Rev 1.816   Sep 10 2006 18:00:08   popescu
 * STP 2192/12
 * 
 *    Rev 1.815   Sep 07 2006 21:38:12   popescu
 * STP 2192/02
 * 
 *    Rev 1.814   Sep 05 2006 16:54:20   popescu
 * STP Project 2217/17
 * 
 *    Rev 1.813   Aug 31 2006 13:16:00   popescu
 * Incident# 639692 - change the other confirmation type to Swift Confirm if PWLD network
 * 
 *    Rev 1.812   Aug 29 2006 18:16:00   popescu
 * STP PET 2192 FN10/11 - bulking netting redemption
 * 
 *    Rev 1.811   Jul 20 2006 09:51:26   popescu
 * Incident# 672858 - minor fix for calling view 140 to check whether the trade can be backdated.
 * 
 *    Rev 1.810   Jul 07 2006 13:33:46   fengyong
 * Incident #659311 - Sync up - Add flag tell check backdate trade or not
 * 
 *    Rev 1.809   Jun 14 2006 16:19:50   popescu
 * PET 2102.FN02 Flex 
 * 
 *    Rev 1.808   Jun 14 2006 10:51:58   jankovii
 * PET2102 FN02 - Manulife Flex  Trade/Systematic Entry.
 * 
 *    Rev 1.807   Jun 05 2006 16:05:24   popescu
 * Incident# 632522 - refresh trade date/settle date if deal date and time are changed.
 * 
 *    Rev 1.806   Jun 05 2006 14:46:30   popescu
 * Incident# 632522 - refresh trade date/settle date if deal date and time are changed.
 * 
 *    Rev 1.805   Jun 05 2006 14:34:58   popescu
 * Incident #624726 -- The logic that related with ESGSettle should not get triggered for the Lux market - synch-up release 69/70 version 1.802.1.1
 * 
 *    Rev 1.804   Jun 05 2006 14:31:34   popescu
 * Incident# 617623 - display default warnings and erros on the trade date
 * 
 *    Rev 1.803   May 25 2006 09:39:58   jankovii
 * PET 2102 FN02 - Manulife Flex Trade/Systematic Entry.
* 
 *    Rev 1.802   May 09 2006 11:19:30   popescu
 * Incident# 613854 - ESG custome schedule - clear the errors of view 135 when checking if trade is backdated 
 * 
 *    Rev 1.801   Apr 13 2006 12:10:20   porteanm
 * Incident 591056 - In Pending mode, populate Sender Ref Num when NetworkID changed.
 * 
 *    Rev 1.800   Apr 10 2006 13:41:02   AGUILAAM
 * IN_591225: IDI error string caused by blank ordertype
 * 
 *    Rev 1.799   Apr 04 2006 16:04:16   jankovii
 * PET 1334 Alternative Product.
 * 
 *    Rev 1.798   Mar 31 2006 13:55:14   jankovii
 * PET 1334 - Alternative Product.
 * 
 *    Rev 1.797   Mar 24 2006 14:57:08   popescu
 * Incident# 564040 - CCB 2273 - Clear out the ExtTransNum for rebooks - view will assign it with M+transnum
 * 
 *    Rev 1.796   Mar 24 2006 14:27:10   popescu
 * PET 2126 - EUSD Backdated trade validation.
 * 
 *    Rev 1.795   Mar 22 2006 16:23:14   jankovii
 * EUSD Backdated trade validation.
 * 
 *    Rev 1.794   Mar 20 2006 09:04:34   popescu
 * Incident 563764 - TradeDate/SettleDate validation support for a cancelled transaction - moved the order type assign. before settle date one, in fetchTransNum - to avoid a 135 call with empty logical field - OrderType
 * 
 *    Rev 1.793   Mar 13 2006 13:07:02   porteanm
 * Incident 563764 - TradeDate/SettleDate validation support for a cancelled transaction.
 * 
 *    Rev 1.792   Mar 10 2006 16:35:46   popescu
 * Fix fund field calls - FundCode/ClassCode are not valid fields in the trading module
 * 
 *    Rev 1.791   Mar 10 2006 09:20:28   popescu
 * BPS Performance issue - cached view call 20 and passed params fund/class in as params - more work
 * 
 *    Rev 1.790   Mar 07 2006 17:19:42   zhengcon
 * PET 2017_FN02--Partnerworld MT515 and Acct Level Default, add set external transaction number
 * 
 *    Rev 1.789   Mar 06 2006 14:28:28   popescu
 * PET1334 - FN01 -- Added logic for ESGSettle enhancement - beautify during code review
 * 
 *    Rev 1.788   Mar 02 2006 10:37:32   AGUILAAM
 * IN 5569000 - sync-up from R68. MCHFileIndicator will default to exclude for 3rd party funds.
 * 
 *    Rev 1.787   Mar 01 2006 14:13:22   ZHANGCEL
 * PET1334 - FN01 -- Using TRADETYPE instead of using I_("AW")
 * 
 *    Rev 1.786   Mar 01 2006 14:01:08   ZHANGCEL
 * PET1334 - FN01 -- Move function validateESGSettle to ATWithdraw and ManualDividend cbo.
 * 
 *    Rev 1.785   Feb 28 2006 17:24:02   ZHANGCEL
 * PET1334 - FN01 - Added new function isCashESGSettleElig()
 * 
 *    Rev 1.784   Feb 23 2006 11:39:30   zhengcon
 * PET 2017_FN02--Partnerworld MT515 and Acct Level Default
 * 
 *    Rev 1.783   Feb 21 2006 17:12:06   popescu
 * Incident#547118 - DSK locks and sets to zero the amount field if AmtType selected is one of i) All Free Units (F), ii) Free/NonAge (T), iii) Matured & Free (Y), iv) Matured & ID (X) and v) Matured Units (M).......since these "Amt Type" options are referencing to ALL units and therefore is not a requirement to input a value in the "Amount" field - fixed compilation error
 * 
 *    Rev 1.782   Feb 21 2006 17:06:16   popescu
 * Incident#547118 - DSK locks and sets to zero the amount field if AmtType selected is one of i) All Free Units (F), ii) Free/NonAge (T), iii) Matured & Free (Y), iv) Matured & ID (X) and v) Matured Units (M).......since these "Amt Type" options are referencing to ALL units and therefore is not a requirement to input a value in the "Amount" field. 
 * 
 *    Rev 1.781   Feb 21 2006 10:26:04   zhengcon
 * PET 2017_FN02--Partnerworld MT515 and Acct Level Default
 * 
 *    Rev 1.780   Feb 20 2006 13:03:56   ZHANGCEL
 * PET 1334 - FN1 -- Added new function for the ESG Settlement enhancement
 * 
 *    Rev 1.779   Feb 15 2006 11:41:06   AGUILAAM
 * IN 542806 - sync-up.  MCH and SR Suppress flags should be updateable even for third party funds. Only EXCLUDE allowed for MCH suppress flag since MCH does not apply for third party funds/ aggregated orders.
 * 
 *    Rev 1.778   Feb 15 2006 11:01:08   AGUILAAM
 * IN 540739 - Sync-up from R68. If MCHSRActive, N/A is not a valid option
 * 
 *    Rev 1.777   Feb 15 2006 10:13:42   ZHANGCEL
 * PET 1334 - FN01 -- Add new functions for the ESG money movement 
 * 
 *    Rev 1.776   Jan 20 2006 09:33:50   popescu
 * Incident# 521415 - fixed the isSameAcctOwner method - should read for the 'AccountTo'
 * 
 *    Rev 1.775   Jan 19 2006 13:53:36   AGUILAAM
 * PET1295_FN01: addl enhancements - do not display MCH/SecRec fields if not supported by client
 * 
 *    Rev 1.774   Jan 12 2006 13:48:12   AGUILAAM
 * PET1295_FN01: Trade Suppress Indicator for MCH and SR Files - Trade Entry/Rebook/Trans History
 * 
 *    Rev 1.773   Jan 10 2006 13:25:22   porteanm
 * Incident 514223 - Free/Non Age Amount Type.
 * 
 *    Rev 1.772   Dec 20 2005 14:46:04   jankovii
 * Incident #496604 - Support Vestima Trading for SSBG.
 * 
 *    Rev 1.771   Nov 30 2005 13:51:18   AGUILAAM
 * PET 1228 FN 02 - EUSD Phase 2
 * 
 *    Rev 1.770   Nov 29 2005 15:24:16   AGUILAAM
 * PET_1228_FN02: EUSD Phase 2
 * 
 *    Rev 1.769   Nov 19 2005 15:52:20   popescu
 * BPS Performance issue - cached view call 20 and passed params fund/class in as params
 *    Rev 1.768   Oct 04 2005 11:10:24   ZHANGCEL
 * PET1244 - FN01 - Pass EventTransType to determine whether the SegCapRules needs to involved
 * 
 *    Rev 1.767   Sep 29 2005 18:57:42   popescu
 * Incident# 405610 - added new validation when a bank is cloned. User should not be able to copy a bank if the process date of the transaction (i.e. trade date, systematic effective date), is not between effective date and stop date of the bank instructions record. Also, the process date has to be in the last EFT bank instructions dates range.
 * 
 *    Rev 1.766   Sep 28 2005 18:22:22   popescu
 * Incident # 406322 - bps performance improvement - cached view call 120 - account num validation,  and fixed 'reset' of trade (moved one line from Trade::firstLineInInit to doInit (idatagroup))
 * 
 *    Rev 1.765   Sep 28 2005 11:15:04   ZHANGCEL
 * PET1244 FN01 -- Seg Fund Evolution enhancement
 * 
 *    Rev 1.764   Sep 27 2005 13:53:42   porteanm
 * Incident 395614 - SegFundValidation, super ugly implementation when is too late for a change of design.
 * 
 *    Rev 1.763   Sep 22 2005 20:16:46   AGUILAAM
 * IN 402898 - SplitCommRebookTransID to be used for rebook of single trades; fix for rebook button
 * 
 *    Rev 1.762   Sep 22 2005 12:44:58   popescu
 * Incident # 402898 - dilution should be validated for pending trades
 * 
 *    Rev 1.761   Sep 19 2005 11:17:32   popescu
 * Incident# 399987 - the assignement of the setttlement currency should be done in host, if empty, for non-multi currency environments. - moved the code in 'initRebook', from 'postInitRebook'
 * 
 *    Rev 1.760   Sep 12 2005 13:59:20   popescu
 * Incident #399924 - refresh the fees list for rebooks, pending trades.
 * 
 *    Rev 1.759   Sep 02 2005 11:50:30   ZHANGCEL
 * Incident #394382 -- Fix problem in setExchRate to allow user update ExchRate
 * 
 *    Rev 1.758   Sep 01 2005 14:01:48   popescu
 * Incident# 388632 - trans cancel screen code overhaul
 * 
 *    Rev 1.757   Aug 29 2005 10:35:44   popescu
 * Incident 390388 - wire order number should be blanked out for multiple rebooks
 * 
 *    Rev 1.756   Aug 22 2005 12:40:42   popescu
 * PET 1235/01 fixed rebook/backdated trades
 * 
 *    Rev 1.755   Aug 18 2005 16:50:06   popescu
 * Incident 383839 - fixed 'Unable to post backdated manual dividend'
 * 
 *    Rev 1.754   Aug 17 2005 11:46:00   popescu
 * PET 1235/01 rebook and cancelation - cleaned the code, 
 * 
 *    Rev 1.753   Aug 16 2005 10:54:30   Yingbaol
 *  The original dilution is not applicable to rebook( the issue identified by ourself)
 * 
 *    Rev 1.752   Aug 15 2005 17:13:04   Yingbaol
 * Incident377205: settlement currency issue( reason unadressed ).
 * 
 *    Rev 1.751   Aug 12 2005 10:23:20   Yingbaol
 * Incident 377523 fix accoutable and reason code validation issue. 
 * 
 *    Rev 1.750   Aug 11 2005 10:51:42   Fengyong
 * Incident 373779 - ad condition invalid isin/kwn number for api
 * 
 *    Rev 1.749   Aug 08 2005 09:11:26   Yingbaol
 * PET1235,FN01: fix banking issue
 * 
 *    Rev 1.748   Aug 03 2005 15:47:10   Yingbaol
 * PET1235,FN01: Dilution related changes.
 * 
 *    Rev 1.747   Jul 29 2005 14:35:10   Yingbaol
 * PET1235,FN01: fix some issue for exchange
 * 
 *    Rev 1.746   Jul 26 2005 14:30:20   Yingbaol
 * PEt1235,FN01: fix modpermission
 * 
 *    Rev 1.745   Jul 19 2005 16:56:50   porteanm
 * PET1171 EUSD 1B - Added parameters to init().
 * 
 *    Rev 1.744   Jul 18 2005 16:45:34   Yingbaol
 * PET1235,FN01: Only clear BatchName if view 127 fails.
 * 
 *    Rev 1.743   Jul 18 2005 12:51:48   popescu
 * Incident 358472 - cached fund broker at the trade level - previously the list was only queried for the first 25 records.
 * 
 *    Rev 1.742   Jul 15 2005 16:37:48   Yingbaol
 * PET1235,FN01: add Record ID and adjTransNum to field info
 * 
 *    Rev 1.741   Jul 15 2005 16:10:26   ZHANGCEL
 * PET 1274 FN 03 -- SSII FX File Upload enhancement
 * 
 *    Rev 1.740   Jul 12 2005 16:06:32   AGUILAAM
 * PET 1235 - additional for dilution.
 * 
 *    Rev 1.739   Jul 11 2005 20:14:38   AGUILAAM
 * PET1235_FN01: dilution, part of Rebook/Cancellation
 * 
 *    Rev 1.738   Jul 11 2005 15:29:00   hernando
 * PET1250 FN01 - Added AccountNum to DateValidation.
 * 
 *    Rev 1.737   Jul 08 2005 09:32:28   Yingbaol
 * PET1235,FN01:transaction cancellation rebook
 * 
 *    Rev 1.736   Jul 07 2005 11:30:42   porteanm
 * PET1171 EUSD 1B - Added validateEUSDBackDates().
 * 
 *    Rev 1.735   Jul 06 2005 16:31:42   porteanm
 * PET1171 EUSD 1B - Added validateEUSDBackDates().
 * 
 *    Rev 1.734   Jul 06 2005 12:33:32   AGUILAAM
 * PET_1235: dilution, part of Rebook/Cancellation; partial check-in
 * 
 *    Rev 1.733   Jul 04 2005 19:05:10   popescu
 * Incident # 347073 - split commission is charged on the To side for environments where ROA is applicable.
 * 
 *    Rev 1.732   Jun 30 2005 15:41:10   popescu
 * Incident # 346892 - fee should not be reset when modifying a split commission in pending mode. Clearing the ROAAmount should be done only if the field is available for business
 * 
 *    Rev 1.731   Jun 29 2005 15:56:58   popescu
 * Incident# 273734 - assigned the account holdings currency - subsequent fix
 * 
 *    Rev 1.730   Jun 29 2005 11:57:00   popescu
 * Incident# 342270 - guard the refresh of split commissions with a boolean for fund related changes; save several view calls to 158
 * 
 *    Rev 1.729   Jun 28 2005 16:53:04   popescu
 * Incident# 342270 - disable ROA amount when modifying a pending allocated trade
 * 
 *    Rev 1.728   Jun 24 2005 10:20:38   Yingbaol
 * Incident 341078 clear ROAAmount when user clear From Fund/ToFund
 * 
 *    Rev 1.727   Jun 22 2005 14:09:04   popescu
 * PET 1117/08 - renamed method activestRelatedChanges to thirdPartyFundRelatedChanges
 * 
 *    Rev 1.726   Jun 17 2005 19:28:28   popescu
 * Incident#273734 - settlement currency automatically assigned if all funds held by account are in the same currency. 
 * User stoped from placing a EFT Full Redemption (no fund, zero amount) if the account has non zero holding on funds with different currency.
 * 
 *    Rev 1.725   Jun 15 2005 15:46:04   porteanm
 * PET1024 FN40 - Guarantee Adjustments.
 * 
 *    Rev 1.724   Jun 10 2005 10:35:50   popescu
 * PET 1117/08 - cached the fund fee sponsor model list at the Trade level for better perfomance
 * 
 *    Rev 1.723   Jun 07 2005 15:54:24   AGUILAAM
 * IN 314827 - Settlement Date should not revert back to default after user has specifically modified it.
 * 
 *    Rev 1.722   Jun 02 2005 18:03:30   popescu
 * Incident 301110 - fixed settle date assignement when for an allocated trade
 * 
 *    Rev 1.721   Jun 01 2005 17:40:30   popescu
 * PET 1203/05 - after code review minor changes - mainly formatting and changed getROAFields access to protected
 * 
 *    Rev 1.720   May 30 2005 15:27:22   popescu
 * Incident #315485 - if user does not have permission to place certain types of transactions the choices will not be available on the trade entry screen
 * 
 *    Rev 1.719   May 27 2005 11:48:48   popescu
 * PET 1117/06, no need to notify the change of the amount in doInitWithDefaults values. This causes a refresh of the transfee list if user cancels the screen - no point in doing it - synch-up from 62
 * 
 *    Rev 1.718   May 27 2005 11:46:48   popescu
 * PET 1117/21 - do not call view 267system level settlement locations if settle code is empty
 * 
 *    Rev 1.717   May 27 2005 11:43:04   popescu
 * Incident 243157 - optimized code in commonValidateSettleSource to refer to the cached broker - synch-up from release 62
 * 
 *    Rev 1.716   May 27 2005 11:34:48   popescu
 * PET 1117/08 - new method added to check if the trade broker is a house broker - uses the cached broker, rather then making a new view call
 * 
 *    Rev 1.715   May 27 2005 11:23:02   popescu
 * Incident # 319459 - fixed the Manual Dividend reset issue - removed the ID trans type for normal trades;
 * 
 *    Rev 1.714   May 24 2005 19:32:34   popescu
 * Incident# 317216 - force the 151 view call, split commissions for allocated should not be refreshed to default if modifying a pending trade - synch-up from release 62
 * 
 *    Rev 1.713   May 20 2005 18:59:12   popescu
 * PET 1117/08 - deposit date refresh
 * 
 *    Rev 1.712   May 18 2005 16:47:12   georgeet
 * Synchup for Incident 285519 - Default values for BackdatedReason and Accountable codes are assigned dynamically depending on return value from the vew side.
 * 
 *    Rev 1.711   May 18 2005 09:03:16   yingbaol
 * PET1203,FN01 Commission-Class A enhancement
 *  
 *    Rev 1.710   May 11 2005 16:33:20   porteanm
 * PET1203 FN05 - Class B NAV Share Lots.
 *  
 *    Rev 1.709   May 02 2005 16:50:08   porteanm
 * Incident 298673 - SettleCurrency field required for FCWorksheet.
 * 
 *    Rev 1.708   Apr 26 2005 16:21:32   porteanm
 * Incident 297971 - LSIF code is now open for updates in both add and modify mode.
 * 
 *    Rev 1.707   Apr 20 2005 17:04:52   Fengyong
 * #Incident 291983 syncup - do not issue "Accountability Code is required" for non back date trade.
 * 
 *    Rev 1.706   Apr 18 2005 15:43:26   porteanm
 * Incident 290447 - RESP account validation for new trades.
 * 
 *    Rev 1.705   Apr 15 2005 16:52:04   porteanm
 * Incident 290447 - RESP account validation for new trades.
 * 
 *    Rev 1.704   Apr 14 2005 13:51:02   porteanm
 * Incident 272808/288937 - Amount precision.
 * 
 *    Rev 1.703   Apr 12 2005 09:48:16   popescu
 * Incident# 285519, changed the accountable to 08 
 * 
 *    Rev 1.702   Apr 11 2005 18:10:16   popescu
 * Incident# 285519, set the backdated reason to 17 and accountable to 04 if network id is partnerworld and trade is backdated, synch-up from release 60.0.1
 * 
 *    Rev 1.701   Apr 10 2005 19:14:48   popescu
 * Incident # 280865, if rep is new and should be created do not refresh split commissions
 * 
 *    Rev 1.700   Apr 10 2005 16:09:22   popescu
 * Incident# 261420, allow multiple active bank accounts; raise warning at transaction level if shareholder has more then one active bank account
 * 
 *    Rev 1.699   Apr 07 2005 15:21:42   Fengyong
 * #275807 - Add ExtTransNum relate change function - sync up with 60
 * 
 *    Rev 1.698   Apr 06 2005 11:23:24   popescu
 * Incident # 280371, baycom/WKN/ISIN numbers should be picked-up from to fund/class when modifying a pending trade
 * 
 *    Rev 1.697   Apr 05 2005 12:16:18   Fengyong
 * #279646 -  DVP clearing method available for ED and PW in PUEV account, FOP available for ED, PW, TR, AFTR, EX in PUEV account.
 * 
 *    Rev 1.696   Mar 30 2005 17:40:06   popescu
 * Incident# 271000, default ChargeWDFee should always be set to Y if Redemption fee is to be charged - cycle rule - synch-up from 59 - 1.663.1.19.1.2
 * 
 *    Rev 1.695   Mar 29 2005 18:08:16   popescu
 * Incident# 273841, missed requirment, set the other confirm type to 1-Create PUEV note if fund and account are PUEV capable for an Investro network id.
 * 
 *    Rev 1.694   Mar 24 2005 11:50:06   popescu
 * Incident #272119, rep name shows on trade entry screen
 * 
 *    Rev 1.693   Mar 22 2005 19:13:14   popescu
 * Incident #271383/270388 fix charge of DSC fees.
 * 
 *    Rev 1.692   Mar 22 2005 18:25:50   popescu
 * Incident #271383/270388 fix charge of DSC fees.
 * 
 *    Rev 1.691   Mar 18 2005 09:44:58   popescu
 * PET 1117/56, fixed crash on fund broker validation for non-existing fund broker records
 * 
 *    Rev 1.690   Mar 17 2005 18:37:42   popescu
 * Incident# 262704, fixed sales rep validation and Sales rep does not exist ...messsage, 59, synch-up
 * 
 *    Rev 1.689   Mar 16 2005 14:15:00   popescu
 * Incident# 261395, added blank option to NetworkId field and lock SenderRefNum field if user chooses a blank NetworkId. Otherwise open it for user input.
 * 
 *    Rev 1.688   Mar 15 2005 17:33:12   Fengyong
 * Incident #262042 Sync up - PayType default
 * 
 *    Rev 1.687   Mar 10 2005 12:57:46   porteanm
 * Incident 243157/243387 - SettleSource validation.
 * 
 *    Rev 1.686   Mar 10 2005 12:41:40   porteanm
 * Incident 243157/243387 - SettleSource validation.
 * 
 *    Rev 1.685   Mar 09 2005 07:31:40   popescu
 * PET 1117/56, clean the fee fields before copying new values for cycle processing
 * 
 *    Rev 1.684   Mar 07 2005 10:47:18   popescu
 * Incident# 258640, use IsDateBetween method, synch-up from Release 59.0.5
 * 
 *    Rev 1.683   Mar 04 2005 15:59:30   popescu
 * Incident# 258640, fixed the fund broker effective validation, synch-up from Release 59.0.5
 * 
 *    Rev 1.682   Feb 28 2005 11:31:06   popescu
 * PET 1117 FN56 : Allocation should also check if trade date is a valid trade date. View 135 will ensure it is at least a business date; synch-up from release 59
 * 
 *    Rev 1.681   Feb 17 2005 13:26:08   yingbaol
 * Magic 23778 sync up version 1.663.1.10, fix exchange rate issue
 * 
 *    Rev 1.680   Feb 16 2005 13:37:58   aguilaam
 * incident # 243397 - sync-up from Rel59; moved initialization of LSIFCode for money-out on LSIF funds from Redemption.cpp to Trade.cpp
 * 
 *    Rev 1.679   Feb 15 2005 14:17:22   popescu
 * 244581, when modifying a pending trade apply the permission mode (TransModPerm) down onto TransFeeList only once, first time when the list is created, synch-up from Rel_59.0.3, branch 1.663.1.9
 * 
 *    Rev 1.678   Feb 14 2005 15:59:32   popescu
 * 240425, delay the validation of settle currency after fund/class entry, synch-up from Rel_59, 1.663.1.7
 * 
 *    Rev 1.677   Feb 11 2005 10:01:08   Fengyong
 * PTS10038246 - if ACHProcessor is required, and value is not applied, check default from generic control.
 * 
 *    Rev 1.676   Feb 09 2005 09:54:18   porteanm
 * PTS 10038661 - Skip CashDate validation when CashDate is not applicable.
 * 
 *    Rev 1.675   Feb 08 2005 17:39:56   porteanm
 * PTS 10038661 - Skip CashDate validation when CashDate is not applicable.
 * 
 *    Rev 1.674   Feb 04 2005 14:04:14   popescu
 * 234691, wire order number mandatory and if oder type is wire, rel 59.0.2, synch-up, v 1.663.1.4
 * 
 *    Rev 1.673   Feb 03 2005 12:15:04   popescu
 * 234664, wire order number should be mandatory , sync-up from release 59, branch 1.663.1.3
 * 
 *    Rev 1.672   Feb 03 2005 12:11:30   popescu
 * PET 1117/66, user server context to override TrxnSettCurrRefresh flag. (flag should be 0, in such a case)
 * 
 *    Rev 1.671   Feb 03 2005 11:37:16   Fengyong
 * PET1117 FN66 - Add FundIDType and FundIDValue for Trade API
 * 
 *    Rev 1.670   Feb 01 2005 16:37:54   popescu
 * PET 1117/66/67/68, set default settlement currency from fund on fund currency related changes
 * 
 *    Rev 1.669   Feb 01 2005 11:45:14   popescu
 * PET 1117/66/67/68, API validations for SWIFT/Investro/Pwld
 * 
 *    Rev 1.668   Jan 31 2005 14:38:22   popescu
 * 10038434, fix the fees read only properties based on the mod perm value of a pending trade , Rel 59, synch-up. Rev: 1.663.1.2
 * 
 *    Rev 1.667   Jan 31 2005 13:39:24   popescu
 * PTS 10036396 & 10038010 : Fix settledate override and validation by view 135 using a new validation type; Refresh settlement properly for change of order type and settledate override , synch-up from release 59 Rev 1.663.1.1   
 * 
 *    Rev 1.666   Jan 31 2005 13:16:46   popescu
 * PTS 10038417 : Delay cross edit for Bank and Paytype; Default readonly Accountable and BackDated reason always in doinitwithdefaultvalue; synch-up from release 59,   Rev 1.663.1.0   
 * 
 *    Rev 1.665   Jan 31 2005 12:59:22   popescu
 * PET 1117/66,67
 * 
 *    Rev 1.662   Jan 24 2005 17:44:16   popescu
 * PET 1117/68, SWIFT, Pwld enhancement
 * 
 *    Rev 1.661   Jan 23 2005 13:57:26   popescu
 * PTS 10037346, made exchange available for the user
 * 
 *    Rev 1.660   Jan 20 2005 17:49:20   popescu
 * PTS 10032958, ensured that the settle source validation is triggered by invalidating the 'SettleSource' field if order type is set to Wire, also fixed a typo.
 * 
 *    Rev 1.659   Jan 19 2005 18:14:36   popescu
 * PTS 10038133, should not use default value WIRE for pay type when looking for the list of settle currencies if pay method is not EFT.
 * 
 *    Rev 1.658   Jan 19 2005 17:30:22   popescu
 * PTS 10038609, acquisition does not get refreshed if fund/class gets changed
 * 
 *    Rev 1.657   Jan 18 2005 19:41:54   popescu
 * PTS 10038609, acquisition does not get refreshed if split comm changes to default
 * 
 *    Rev 1.656   Jan 14 2005 18:19:40   popescu
 * PTS 10037395, isFullRedemption - revert the code
 * 
 *    Rev 1.655   Jan 14 2005 11:07:06   popescu
 * PTS 10037724, changed the validation of deal date and compared the value of it with today's date, rather then current bussiness date.
 * 
 *    Rev 1.654   Jan 14 2005 09:54:22   popescu
 * PTS 10037395, isFullRedemption should still have settlement currency required
 * 
 *    Rev 1.653   Jan 13 2005 17:36:42   popescu
 * PET 1117/06, API further changes
 * 
 *    Rev 1.652   Jan 13 2005 11:47:06   popescu
 * PTS 10037724, exchange rate should not be set during pending trade midification, and deal date validation is triggered for new trades
 * 
 *    Rev 1.651   Jan 12 2005 18:52:36   popescu
 * PTS 10037339, allowed user to set Redemption Fee up
 * 
 *    Rev 1.650   Jan 11 2005 16:33:12   Fengyong
 * PET1117/06 - Trade processing - put back babel API fields
 * 
 *    Rev 1.649   Jan 10 2005 16:57:24   popescu
 * PTS 10037295, settle date should be set to current business date for order type direct and a backdated trade
 * 
 *    Rev 1.648   Jan 10 2005 10:38:32   popescu
 * PTS 10037553, fixed fees properties in pending mode and trade reset of the trans type combo
 * 
 *    Rev 1.647   Jan 06 2005 17:20:04   popescu
 * PTS 10037460 , Date validation object should add the conditions on the condition vector
 * 
 *    Rev 1.646   Jan 06 2005 16:12:20   popescu
 * PTS 10037553, added new description to SettledBySet (0-N/A) and set the default for SettledBy to empty string for a new trade
 * 
 *    Rev 1.645   Jan 06 2005 13:57:06   popescu
 * PTS 10037503, trade object set to be dirty immediate after being created
 * 
 *    Rev 1.644   Jan 05 2005 17:54:04   popescu
 * PTS 10037460 , more restrictions to attaching the warning message to the field
 * 
 *    Rev 1.643   Jan 05 2005 17:11:36   popescu
 * PTS 10037460 , attached warning message conditions to the proper field 
 * 
 *    Rev 1.642   Jan 04 2005 17:11:02   popescu
 * PTS 10037456, consider deposit 9 and 10 -bearer certificate when setting the default values for aggregate option
 * 
 *    Rev 1.641   Jan 04 2005 11:06:38   popescu
 * PTS 10037407, corrected field names for exchange fund broker eligibility. also, corrected the error message.
 * 
 *    Rev 1.640   Dec 31 2004 13:38:32   popescu
 * PTS 10037395, settlement currency should be set as required if for redemption the account closes or a full redemption is processed. Also, isFullNotCloseAcctRed method name to isFullRedemption
 * 
 *    Rev 1.639   Dec 30 2004 15:11:08   popescu
 * PTS 10037326, invalidate amount field at trade level, rather then purchase
 * 
 *    Rev 1.638   Dec 30 2004 12:41:22   popescu
 * PTS 10037260, moved check whether fund sponsor fee model  exists at Trade CBO level, and called the validation for redemptions/purchases as well, missed req: PET1117.FN6.R3.7. 0
 * 
 *    Rev 1.637   Dec 30 2004 12:06:22   popescu
 * PET 1117/06, fixes related to accountab code and backdated reason, when booking an allocated trade; 135 cannot be called so default trade date is set to current business date
 * 
 *    Rev 1.637   Dec 30 2004 11:46:56   popescu
 * PET 1117/06, fixes related to accountab code and backdated reason, when booking an allocated trade; 135 cannot be called so default trade date is set to current business date
 * 
 *    Rev 1.636   Dec 29 2004 13:19:04   popescu
 * PTS 10037187, assign FromCurrency field in the base class (Trade) so exch rate can be properly set for pending trades, also wire should always be the default for pay type
 * 
 *    Rev 1.635   Dec 29 2004 11:22:22   popescu
 * PTS 10037302, do not validate amount precision for amount type units
 * 
 *    Rev 1.634   Dec 23 2004 13:36:08   popescu
 * PTS 10037169, do not reset settlement currency when user hits Ok on the Trade Screen dialog
 * 
 *    Rev 1.633   Dec 17 2004 19:19:44   popescu
 * PET 1117/56, in pending mode default bank shlould be retrieved if user switches pay type 
 * 
 *    Rev 1.632   Dec 16 2004 18:49:24   popescu
 * PET 1117/06, reload file proc and currencies if pay method changes. Strip leading zeros from account
 * 
 *    Rev 1.631   Dec 16 2004 12:15:16   popescu
 * PET 1117/06/56, fixed allocations issues for transfers in pending mode, also set of a settle curr if DefSettleCurr-83 is N
 * 
 *    Rev 1.630   Dec 15 2004 19:31:20   popescu
 * PET 1117/06, more fixes for paytype/settle curr/pay method/file processor.
 * 
 *    Rev 1.629   Dec 14 2004 17:39:16   popescu
 * PET 1117/06/56 added validation for trade cut-off date
 * 
 *    Rev 1.628   Dec 14 2004 15:02:30   popescu
 * PET 1117/56, pay method/file proc related changes and fixes
 * 
 *    Rev 1.627   Dec 14 2004 10:00:50   popescu
 * PET 1117/06, refresh fee list in pending mode
 * 
 *    Rev 1.626   Dec 13 2004 17:04:46   YINGBAOL
 * Add setAsDefault into fieldinfo
 * 
 *    Rev 1.625   Dec 13 2004 16:43:04   vadeanum
 * PET 1117/06 settle location setup for pending trade.
 * 
 *    Rev 1.624   Dec 11 2004 13:24:22   popescu
 * PET 1117/06 settle location fixes
 * 
 *    Rev 1.623   Dec 11 2004 11:47:44   popescu
 * PET 1117/56 more fixes, pending trade mods
 * 
 *    Rev 1.622   Dec 10 2004 18:13:42   popescu
 * PET 1117/06, more fixes
 * 
 *    Rev 1.621   Dec 09 2004 22:30:58   popescu
 * PET 11717/06, fees and mod pending trades
 * 
 *    Rev 1.620   Dec 09 2004 12:37:42   popescu
 * PET 1117/56, more fees work /pending trade
 * 
 *    Rev 1.619   Dec 08 2004 21:06:10   popescu
 * PET 1117/06 more fixes
 * 
 *    Rev 1.618   Dec 08 2004 17:50:00   popescu
 * PET 1117/56, modify an aggregated order's pending trades list
 * 
 *    Rev 1.617   Dec 08 2004 14:10:02   popescu
 * PET 1117/06, settle date fixes
 * 
 *    Rev 1.616   Dec 07 2004 21:20:34   popescu
 * PET 1117/06, pending trades/fees fixes, add-ons
 * 
 *    Rev 1.615   Dec 07 2004 02:45:10   popescu
 * PET 1117/56, verify search won't pop-up if alt acct/other ref # search returns one match
 * 
 *    Rev 1.614   Dec 07 2004 01:37:54   popescu
 * PET 1117/56 trades processing/modify trade
 * 
 *    Rev 1.613   Dec 06 2004 10:41:36   popescu
 * PET 1117/56, fees processing
 * 
 *    Rev 1.612   Dec 03 2004 16:25:46   vadeanum
 * PET1117_FN21:  settlement instructions.
 * 
 *    Rev 1.611   Dec 03 2004 15:50:22   popescu
 * PET 1117/56, invalidate the dates
 * 
 *    Rev 1.610   Dec 03 2004 15:07:18   popescu
 * PTS 10035717, stop transfers were not read
 * 
 *    Rev 1.609   Dec 03 2004 10:46:14   popescu
 * PET 1117/06, fees processing
 * 
 *    Rev 1.608   Dec 02 2004 20:59:30   popescu
 * PET 1117/06, more fee fixes
 * 
 *    Rev 1.607   Dec 02 2004 18:23:06   popescu
 * PET 1117/06/56, trades processing/fees processing
 * 
 *    Rev 1.606   Dec 01 2004 19:50:20   popescu
 * PET 1117/06, trades/fees processing, incorporate fees in trades transaction builder, and added method to copy fee values onto the trades fee fields for cycle processing
 * 
 *    Rev 1.605   Dec 01 2004 15:45:04   popescu
 * PET 1117/56 fees processing, calculate the discount rate
 * 
 *    Rev 1.604   Dec 01 2004 11:06:18   popescu
 * PTS 10035976, fixed minor com error
 * 
 *    Rev 1.603   Dec 01 2004 10:47:40   popescu
 * PTS 10036124, synch-up branch 1.576.1.1, default pay type got overridden for purchases
 * 
 *    Rev 1.602   Dec 01 2004 10:23:44   popescu
 * PTS 10035976, 10036351, 10036323 - Set ForceVerify to N , synch-up branch 1.576.1.7
 * 
 *    Rev 1.601   Dec 01 2004 10:18:44   popescu
 * PET 1117/06, restored some of the missing pieces
 * 
 *    Rev 1.600   Nov 30 2004 20:10:10   popescu
 * PET 1117/06
 * 
 *    Rev 1.599   Nov 30 2004 08:43:16   popescu
 * PET 1117/06, more clearing/settle location related stuff
 * 
 *    Rev 1.598   Nov 29 2004 21:27:14   popescu
 * PTS 10034237, check if fund can trade should not be done if fund/class empty
 * 
 *    Rev 1.597   Nov 29 2004 20:30:42   popescu
 * PET 1117/06/56 fees/trades processing
 * 
 *    Rev 1.596   Nov 27 2004 21:19:08   popescu
 * PET 1117/06, trades processing
 * 
 *    Rev 1.595   Nov 26 2004 10:51:08   popescu
 * PTS 10036185,  do no re-set the file processor value if in init pending, synch-up from branch 1.576.1.4, rel 58/58.1
 * 
 *    Rev 1.594   Nov 25 2004 14:59:10   popescu
 * PET 1117/06, settle locations
 * 
 *    Rev 1.593   Nov 25 2004 11:44:12   popescu
 * PET 1117/06, settle locations
 * 
 *    Rev 1.592   Nov 24 2004 21:36:16   popescu
 * PET 1117/06/56. trade processing, settle location
 * 
 *    Rev 1.591   Nov 22 2004 17:47:22   popescu
 * PTS 10032958, minor validation change for OrderSource
 * 
 *    Rev 1.590   Nov 22 2004 16:49:12   popescu
 * PTS 10032958, revisited the validation logic for OrderSource
 * 
 *    Rev 1.589   Nov 22 2004 16:21:00   popescu
 * PTS 10032958, added more order source validation, to be in synch with base
 * 
 *    Rev 1.588   Nov 22 2004 13:09:26   popescu
 * PET 1117/56. fees processing
 * 
 *    Rev 1.587   Nov 19 2004 14:17:28   popescu
 * PET 1117/56 third party processing
 * 
 *    Rev 1.586   Nov 18 2004 14:52:32   YINGBAOL
 * PET1117:performance tunning.
 * 
 *    Rev 1.585   Nov 18 2004 14:00:12   popescu
 * PET 1117/56, validation for fund broker code
 * 
 *    Rev 1.584   Nov 17 2004 16:15:34   popescu
 * PET 1117/06, Trade processing fees
 * 
 *    Rev 1.583   Nov 15 2004 15:15:38   popescu
 * PET 1117/06, .NET synch-up changes
 * 
 *    Rev 1.582   Nov 09 2004 19:23:52   popescu
 * PET 1117/06, trade processing
 * 
 *    Rev 1.581   Nov 09 2004 17:03:54   popescu
 * PTS 10034331, refresh split commisions if broker/branch/sals rep changes
 * 
 *    Rev 1.580   Nov 09 2004 16:50:46   popescu
 * PET 1117/06, Trade processing
 * 
 *    Rev 1.579   Nov 08 2004 12:31:10   popescu
 * PET 1117/06 trade processing
 * 
 *    Rev 1.578   Nov 07 2004 16:19:48   popescu
 * PET 1117/56 read isin/wkn numbers from fund detail via work session
 * 
 *    Rev 1.577   Nov 06 2004 00:42:40   popescu
 * PET 1117/06, synch changes
// 
//    Rev 1.6   Nov 04 2004 17:41:44   popescu
// PET 1117/06, Trade processing
// 
//    Rev 1.5   Nov 02 2004 19:19:36   popescu
// PET 1117/06 Trade processing...
// 
//    Rev 1.4   Oct 28 2004 18:23:56   popescu
// PET 1117/06
// 
//    Rev 1.3   Oct 27 2004 11:27:04   popescu
// PET 1117/06
// 
//    Rev 1.2   Oct 22 2004 19:58:56   popescu
// PET 1117/06, work in progress...
// 
//    Rev 1.1   Oct 21 2004 06:29:22   popescu
// PET 1117/06 - Trade processing work in progress..
// 
//    Rev 1.0   Oct 01 2004 19:30:00   popescu
// Initial revision.
 * 
 *    Rev 1.566   Sep 21 2004 16:02:32   popescu
  * Initial revision.
// 
// 
*/

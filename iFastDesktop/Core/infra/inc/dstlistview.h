// DSTListView.h: interface for the CDSTListView class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DSTLISTVIEW_H__4E0DC28E_95A1_4508_8FF6_CEA7C08271AA__INCLUDED_)
#define AFX_DSTLISTVIEW_H__4E0DC28E_95A1_4508_8FF6_CEA7C08271AA__INCLUDED_

#pragma message( "including "__FILE__ )

/**
 *    COPYRIGHT:
 *
 *    The computer systems, procedures, data bases and
 *    programs created and maintained by DST Systems, Inc.,
 *    are proprietary in nature and as such are confidential.
 *    Any unauthorized use or disclosure of such information
 *    may result in civil liabilities.
 *
 *    Copyright 2000 by DST Systems, Inc.
 */


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef INCLUDED_ATLBASE_H
#define INCLUDED_ATLBASE_H
   #include <atlbase.h>
#endif

#ifndef COMMONPORT_H
   #include "commonport.h"
#endif

#ifndef DDATE_HPP
   #include "DDate.hpp"
#endif

#ifndef MATHSTRING_HPP
   #include "MathString.hpp"
#endif

#undef  DSTGUI_LINKAGE
#ifdef DSTGUI_DLL
   #define DSTGUI_LINKAGE CLASS_EXPORT
#else
   #define DSTGUI_LINKAGE CLASS_IMPORT
#endif

#define NO_SEL          -1
#define NOSORTKEY       -1
#define SORTORDER_NONE  0

typedef enum tagExport_e
{
   EXPORT_EXCEL  = 0,
   EXPORT_HTML   = 1
} Export_e;

typedef enum tagHAlign_e
{
   H_ALIGN_LEFT    = 0,
   H_ALIGN_RIGHT   = 1,
   H_ALIGN_CENTER  = 2
} HAlign_e;

typedef enum tagColType_e
{
   COL_TYPE_DATE           = 0,
   COL_TYPE_FLOAT          = 1,
   COL_TYPE_INTEGER        = 2,
   COL_TYPE_TEXT           = 3,
   COL_TYPE_TEXT_MULTILINE = 4,
   COL_TYPE_TAX_ID         = 5,
   COL_TYPE_SSN            = 6,
   COL_TYPE_MONEY          = 7,
   COL_TYPE_PHONE_NUM      = 8,
   COL_TYPE_PERCENT        = 9,
   COL_TYPE_MATH_STR       = 10,
   COL_TYPE_MATH_STR_MONEY = 11,
   COL_TYPE_PICTURE        = 12,
   COL_TYPE_COMBOBOX       = 13,
   COL_TYPE_CHECKBOX       = 14,
   COL_TYPE_STATIC_TEXT    = 15,
   COL_TYPE_MASK           = 16
   //COL_TYPE_TIME           = 17
} ColType_e;

typedef enum tagColorStyle_e
{
   GREEN_BAR        = 0,
   PINK_BAR         = 1,
   BLUE_BAR         = 2,
   GOLD_BAR         = 3,
   GREY_BAR         = 4,
   DEFAULT_SOLID    = 5,
   WHITE_SOLID      = 6,
   GREY_SOLID       = 7,
   LTGREY_SOLID     = 8,
   BLUE_SOLID       = 9,
   CYAN_SOLID       = 10,
   YELLOW_SOLID     = 11,
   GREEN_SOLID      = 12,
   RED_SOLID        = 13,
   BLACK_SOLID      = 14
} ColorStyle_e;

typedef enum tagTextTipStyle_e
{
   DISABLE_TIPS        = 0,
   SINGLE_CELL_TIPS    = 1,
   SINGLE_LINE_TIPS    = 2,
   MULTI_LINE_TIPS     = 3
} TextTipStyle_e;

typedef enum tagPicType_e
{
   PIC_TYPE_BITMAP = 0,
   PIC_TYPE_ICON   = 1
} PicType_e;

/**@#-*/
//forward declares
class _DSpreadSheet;
class CPOptionData;
class CFilterData;
/**@#+*/

/**
 * Class to implement a DST specialized List View Using FarPoints GridControl
 *
 * This class wraps an FarPoint Spread30 control. Sets up the properties
 * and provides a set of API's that are easier to use for a list control.
 * Adds features like Configurable fly-over text, a Mechanism whereby the
 * list can store user preferences like column positions/size, sorting
 * priorities. Printing, print previewing, List Filtering, User Find, and more.
 *
 */
class DSTGUI_LINKAGE CDSTListView : public CWnd
{

#ifndef DOXYGEN_SHOULD_SKIP_THIS

   DECLARE_DYNCREATE(CDSTListView)
   // Operations
public:

   // Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CDSTListView)
public:
   virtual BOOL DestroyWindow();
   //}}AFX_VIRTUAL

protected:
   //{{AFX_MSG(CDSTListView)
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()

#endif

protected:

public:
   /**
    * Default constructor.
    *
    * @param bMultiSelect - Only chance to set the list to a multi-select list.
    *
    */
   CDSTListView(BOOL bMultiSelect = false);


   /**
    * This method is used to attach an FarPoint SpreadSheet to a CDSTListView object.
    * The CWnd object is first verified to be an SpreadSheet.  It is then set up with the
    * properties that make it a list control.
    *
    * @param wndFPList - CWnd class for an FarPoint SpreadSheet Control generated by the
    *               class wizard.
    *
    * @return True if successfully attached.
   */
   BOOL AttachSheet( CWnd &wndFPList );

   /**
    * Detaches an FarPoint Spreadsheet from the CDSTListView object.
    */
   virtual void DetachSheet();

   /**
    * This method is used internally to process menu and other commands. It Should not
    * be called directly! This is an override from CWnd that this class derives from.
    *
    * @param wParam - Standard WPARAM values.
    * @param lParam - Standard LPARAM values.
    *
    * @return True if command handeled.
    */
   virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

   /**
    * Call this method to restore user preferences such as column widths,
    * list colors, and sort columns. You MUST not call this method until
    * the list columns have been created. This method will try to restore
    * column widths. If the columns have not yet been created, then the user's
    * preference will not be restored.
    *
    * @param pSection - Pointer to a string containing the section the pref is stored.
    * @param pKey - Pointer to a string containing the key to use to retrieve the pref's.
    */
   virtual void RestoreUserPrefs(LPCTSTR pSection, LPCTSTR pKey);

   /**
    * Call this method to Save user preferences such as column widths,
    * list colors, and sort columns. You should call this method in your OnClose, OnDestroy,
    * ExitInstance or other appropriate place before this object is destroyed.
    *
    * @param pSection - Pointer to a string containing the section the pref is stored.
    * @param pKey - Pointer to a string containing the key to use to retrieve the pref's.
    *
    * @see "CWinApp::SetProfileString(strSection, strKey, strDefault)"
    */
   virtual void SaveUserPrefs(LPCTSTR pSection, LPCTSTR pKey);

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from sorting the list.
    *
    * @param bAllow - Set to TRUE to allow user to sort. Default is TRUE;
    *
    * @see GetAllowUserSorting()
    */
   virtual void SetAllowUserSorting(BOOL bAllow = TRUE) {m_bAllowUserSort = bAllow;};

   /**
    * Call this method determine if the user is allowed to sort
    *
    * @return TRUE if the user is allow to sort
    *
    * @see SetAllowUserSorting(BOOL bAllow)
    */
   virtual BOOL GetAllowUserSorting() { return m_bAllowUserSort;};

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from changing list colors through right click menu's.
    *
    * @param bAllow - Set to TRUE to allow user to change colors. Default is TRUE;
    *
    * @see GetAllowUserColor()
    */
   virtual void SetAllowUserColor(BOOL bAllow = TRUE) {m_bAllowUserColor = bAllow;};

   /**
    * Call this method determine if the user is allowed to change colors
    *
    * @return TRUE if the user is allow to change colors
    *
    * @see SetAllowUserColor(BOOL bAllow)
    */
   virtual BOOL GetAllowUserColor() { return m_bAllowUserColor;};

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from accessing filtering through right click menu's.
    *
    * @param bAllow - Set to TRUE to allow user to filter the list through
    * right click menus. Default is TRUE;
    *
    * @see GetAllowUserFiltering()
    */
   virtual void SetAllowUserFiltering(BOOL bAllow = TRUE) {m_bAllowUserFiltering = bAllow;};

   /**
    * Call this method determine if the user is allowed to filter the list through
    * right click menus.
    *
    * @return TRUE if the user is allow to filter the list through
    * right click menus.
    *
    * @see SetAllowUserFiltering(BOOL bAllow)
    */
   virtual BOOL GetAllowUserFiltering() { return m_bAllowUserFiltering;};

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from accessing a find dialog through right click menu's.
    *
    * @param bAllow - Set to TRUE to allow user to access a find dialog through
    * right click menus. Default is TRUE.
    *
    * @see GetAllowUserFind()
    */
   virtual void SetAllowUserFind(BOOL bAllow = TRUE) {m_bAllowUserFind = bAllow;};

   /**
    * Call this method determine if the user is allowed to access a find dialog through
    * right click menus
    *
    * @return TRUE if the user is allow to access a find dialog through
    * right click menus.
    *
    * @see SetAllowUserFind(BOOL bAllow)
    */
   virtual BOOL GetAllowUserFind() { return m_bAllowUserFind;};

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from accessing a column show/hide dialog through right click menu's.
    *
    * @param bAllow - Set to TRUE to allow user to access a column show/hidw dialog through
    * right click menus. Default is TRUE.
    *
    * @see GetAllowUserColumnHide()
    */
   virtual void SetAllowUserColumnHide(BOOL bAllow = TRUE) {m_bAllowUserColumnHide = bAllow;};

   /**
    * Call this method determine if the user is allowed to access a column show/hide dialog through
    * right click menus
    *
    * @return TRUE if the user is allow to access a column show/hide dialog through
    * right click menus.
    *
    * @see SetAllowUserColumnHide(BOOL bAllow)
    */
   virtual BOOL GetAllowUserColumnHide() { return m_bAllowUserColumnHide;};

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from accessing export of Excel or HTML through right click menu's.
    *
    * @param bAllow - Set to TRUE to allow user to access export of Excel or HTML
    * through right click menu's. Default is TRUE.
    *
    * @see GetAllowUserExport()
    */
   virtual void SetAllowUserExport(BOOL bAllow = TRUE) {m_bAllowUserExport = bAllow;};

   /**
    * Call this method determine if the user is allowed to access export of Excel or HTML
    * through right click menu's.
    *
    * @return TRUE if the user is allow to access export of Excel or HTML
    * through right click menu's
    *
    * @see SetAllowUserExport(BOOL bAllow)
    */
   virtual BOOL GetAllowUserExport() { return m_bAllowUserExport;};

   /**
    * Call this method at initialization time or anytime to allow or prevent
    * the user from accessing print preview, page setup, and print through right click menus's.
    *
    * @param bAllow - Set to TRUE to allow user to access print preview, page setup, and print through right click menus's.
    * Default is TRUE.
    *
    * @see GetAllowUserPrint()
    */
   virtual void SetAllowUserPrint(BOOL bAllow = TRUE) {m_bAllowUserPrint = bAllow;};

   /**
    * Call this method determine if the user is allowed to access print preview, page setup,
    * and print through right click menus's.
    *
    * @return TRUE if the user is allow to access print preview, page setup, and print
    * through right click menus's.
    *
    * @see SetAllowUserPrint(BOOL bAllow)
    */
   virtual BOOL GetAllowUserPrint() { return m_bAllowUserPrint;};

   /**
    * Call this method at initialization time or anytime to set the list color style.
    *
    * @param eNewStyle - Enumerated value of available list color styles
    */
   virtual void SetListColorStyle(ColorStyle_e eNewStyle);

   /**
    * Call this method at initialization time or anytime to set the to
    * disable or set one of three tool tip styles.
    *
    * @param eNewStyle - Enumerated value of available tool tip styles.
    */
   virtual void SetTextTipStyle(TextTipStyle_e eNewStyle = DISABLE_TIPS);

   /**
    * In your code accept the message from the FarPoint Spreadsheet for RightClick, then
    * Call this method. This is necessary for the class to display right click menu's.
    *
    * @param ClickType - Single or double click.
    * @param Col - Column index of mouse click
    * @param Row - Row Index of mouse click
    * @param MouseX - X Corrdinate of mouse click
    * @param MouseY - Y Corrdinate of mouse click
    */
   virtual void ProcessRightMouseClick(short ClickType, long Col, long Row, long MouseX, long MouseY);

   /**
    * In your code accept the message from the FarPoint Spreadsheet for Click, then
    * Call this method. This is necessary for the class to perform sorting.
    *
    * @param Col - Column index of mouse click
    * @param Row - Row Index of mouse click
    */
   virtual void ProcessLeftMouseClick(long Col, long Row);

   /**
    * In your code accept the message from the FarPoint Spreadsheet for TextTipFetch, then
    * Call this method. This is necessary for the class to display Text tips.
    *
    * @param Col - Column index of mouse click
    * @param Row - Row Index of mouse click
    * @param MultiLine - Enumeration of text tip style
    * @param TipWidth - Width of the tip
    * @param TipText - Text of the tip
    * @param ShowTip - TRUE to show the tip
    */
   virtual void ProcessTextTip(long Col, long Row, short FAR* MultiLine, long FAR* TipWidth, BSTR FAR* TipText, BOOL FAR* ShowTip);

   /**
    * In your code accept the message from the FarPoint Spreadsheet for MouseDown, then
    * Call this method. This is necessary for the class to provide user feedback when sorting
    *
    * @param Button - Left or Right mouse click
    * @param Shift - Shift key state
    * @param x - X Corrdinate of mouse click
    * @param y - Y Corrdinate of mouse click
    */
   virtual void ProcessMouseDown(short Button, short Shift, long x, long y);

   /**
    * In your code accept the message from the FarPoint Spreadsheet for MouseUp, then
    * Call this method. This is necessary for the class to provide user feedback when sorting
    *
    * @param Button - Left or Right mouse click
    * @param Shift - Shift key state
    * @param x - X Corrdinate of mouse click
    * @param y - Y Corrdinate of mouse click
    */
   virtual void ProcessMouseUp(short Button, short Shift, long x, long y);

   /**
    * Convienence method. Given row item data, return the list index for that row.
    * Rows and Columns use 1 based indexes
    *
    * @param nItemData - Row item data to retrieve the list index for
    * @return List index that contains the item data. -1 if not found.
    */
   virtual long GetListIndex(long nItemData);

   /**
    * Use with a single-select list to get the index of the row selected
    * Rows and Columns use 1 based indexes
    *
    * @return The index of the row selected
    * @see GetSelItemData()
    */
   virtual long GetSelListIndex();

   /**
    * Use with a multi-select list to get the number of rows selected
    *
    * @return The number of items selected in a multi-select list
    * @see GetFirstSelListIndex()
    * @see GetNextSelListIndex()
    * @see GetFirstSelItemData()
    * @see GetNextSelItemData()
    */
   virtual long GetSelectedCount();

   /**
    * Use with a multi-select list in conjunction with GetNextSelListIndex
    * to retrieve the index of the first selected row
    * Rows and Columns use 1 based indexes
    *
    * @return The index of first the selected row
    * @see GetNextSelListIndex()
    * @see GetFirstSelItemData()
    * @see GetNextSelItemData()
    * @see GetSelectedCount()
    */
   virtual long GetFirstSelListIndex();

   /**
    * Use with a multi-select list in conjunction with GetFirstSelListIndex
    * to retrieve the index of the next selected row
    * Rows and Columns use 1 based indexes
    *
    * @return The index of first the selected row
    * @see GetFirstSelListIndex()
    * @see GetFirstSelItemData()
    * @see GetNextSelItemData()
    * @see GetSelectedCount()
    */
   virtual long GetNextSelListIndex();

   /**
    * Use with a single-select list to get the row item data of the row selected
    *
    * @return The item data of the row selected
    * @see GetSelItemIndex()
    */
   virtual long GetSelItemData();

   /**
    * Use with a multi-select list in conjunction with GetNextSelListData
    * to retrieve the item data of the first selected row
    *
    * @return The item data of first the selected row
    * @see GetFirstSelListIndex()
    * @see GetNextSelItemData()
    * @see GetSelectedCount()
    */
   virtual long GetFirstSelItemData();

   /**
    * Use with a multi-select list in conjunction with GetFirstSelListData
    * to retrieve the item data of the next selected row
    *
    * @return The index of first the selected row
    * @see GetFirstSelItemData()
    * @see GetFirstSelListIndex()
    * @see GetSelectedCount()
    */
   virtual long GetNextSelItemData();

   /**
    * Use select the row at the specified list index
    * Rows and Columns use 1 based indexes
    *
    * @param lRowNdx - The list index of the row to select
    */
   virtual void SelectRow(long lRowNdx);

   /**
    * Use to prevent changes made from being display. Such as when filling the list.
    * The list will be invalidated and redrawn when bRedraw is set to TRUE. This maintains
    * a reference count. When the reference count reaches 0 the list is redrawn. This prevents
    * multiple calls from repainting causing flicker. Therefore it is important to match any
    * SetReDraw(FALSE) with a corresponding SetReDraw(TRUE). There is no need to invalidate the
    * window or call UpdateWindow(), this method does it for you.
    *
    * @param bRedraw - If FALSE list refresh is held of. If TRUE any changes are updated if ref count is 0.
    */
   virtual void SetReDraw(BOOL bRedraw = TRUE);

   /**
    * Call this to clear all setting of the spreadsheet. All columns,
    * row and list properties will be reset to default values.
    */
   virtual void ResetList();

   /**
    * Call this to clear all row data. Does not effect columns or other properties.
    */
   virtual void ClearRows();

   /**
    * Adds a column with the specified title and data type.
    * Rows and Columns use 1 based indexes
    *
    * @param pszColName - String containing the name to display in the header.
    * @param eColType - Enumeration of the type of data that this column will contain.
    * @param bHidden - If set to False the column will be hidden.
    * @return The index of the added column or -1 if error.
    */
   virtual long AddColumn(LPCTSTR pszColName,
                          ColType_e eColType = COL_TYPE_TEXT,
                          BOOL bHidden = false);

   /**
    * Inserts a column with the specified title and data type.
    * Rows and Columns use 1 based indexes
    *
    * @param pszColName - String containing the name to display in the header.
    * @param nAtNdx - Index at which to insert the column.
    * @param eColType - Enumeration of the type of data that this column will contain.
    * @param bHidden - If set to False the column will be hidden.
    */
   virtual void InsertColumn(LPCTSTR pszColName,
                             long nAtNdx,
                             ColType_e eColType = COL_TYPE_TEXT,
                             BOOL bHidden = false);

   /**
    * Should be called after either inserting or adding a column to further specify attributes
    * of the column. Use this method for all data types except float or MathString.
    * Rows and Columns use 1 based indexes
    *
    * @param nCol - The index of the column that this applies.
    * @param eAlign - Enumeration of how the data should be alligned.
    * @param lpcszMask - Use only if the ColType_e for this column is COL_TYPE_MASK.
    * @param bForceUpperCase - If True will force all text to upper case.
    * @param bFixed - If True set backgound color to grey.
    */
   virtual void SetColAttributes(long nCol,
                                 HAlign_e eAlign = H_ALIGN_CENTER,
                                 BOOL bFixed = FALSE,
                                 LPCTSTR lpcszMask = NULL,
                                 BOOL bForceUpperCase = FALSE);
   /**
   * Should be called after either inserting or adding a column to further specify attributes
   * of the column. Use this method only with data types float or MathString.
   * Rows and Columns use 1 based indexes
   *
   * @param nCol - The index of the column that this applies.
   * @param eAlign - Enumeration of how the data should be alligned.
   * @param sDecimalPlaces - Specifies the number of decimal places to display.
   * @param bShowSeparator - Sets whether or not to display separators such as 1,000,456
    */
   virtual void SetFloatColAttributes(long nCol,
                                      HAlign_e eAlign = H_ALIGN_CENTER,
                                      short sDecimalPlaces = 2,
                                      BOOL bShowSeparator = FALSE);


   /**
    * Call after a column has been created to change header text and column data type
    * Rows and Columns use 1 based indexes
    *
    * @param nCol - The index of the column that this applies.
    * @param pszColName - String containing the name to display in the header.
    * @param eColType - Enumeration of the type of data that this column will contain.
    */
   virtual void SetColumn(long nCol, CString & rstrColName, ColType_e eColType);

   /**
    * Retrieve an enumeration of the type of data this column contains.
    * Rows and Columns use 1 based indexes
    *
    * @param nCol - The index of the column that this applies.
    * @return Enumeration of the type of data that this column contains.
    */
   virtual ColType_e GetColumnType(long nCol);

   /**
    * Retrieve the name displayed in the column header.
    * Rows and Columns use 1 based indexes
    *
    * @param nCol - The index of the column that this applies.
    * @param rstrColName - return the name used in the column header.
    */
   virtual void GetColumn(long nCol, CString & rstrColName);

   /**
    * Remove a column from the list using the name displayed in the column header.
    *
    * @param rstrColName - The name used in the column header of the column to remove.
    */
   virtual void RemoveColumn(CString & rstrColName);

   /**
    * Remove a column from the list at the specified index.
    * Rows and Columns use 1 based indexes
    *
    * @param nCol - Index of the column to remove.
    */
   virtual void RemoveColumn(long nCol);

   /**
    * Adds a row to the list returning the new rows index.
    * Rows and Columns use 1 based indexes
    *
    * @return Index of the newly added row.
    */
   virtual long AddRow();

   /**
    * Sets the cell at the specified (row, column) to a bitmap or icon.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param unPictResID - Resource ID of the bitmap or icon to display.
    * @param ePicType - Enumeration to specify bitmap or icon. Can be PIC_TYPE_BITMAP or PIC_TYPE_ICON.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, UINT unPictResID, PicType_e ePicType);

   /**
    * Sets the cell at the specified (row, column) to the UN-FORMATTED text specified in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - UN-FORMATTED data to display. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, DString & strData);

   /**
    * Sets the cell at the specified (row, column) to the UN-FORMATTED text specified in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - UN-FORMATTED data to display. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, CString & strData);

   /**
    * Sets the cell at the specified (row, column) to the UN-FORMATTED text specified in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - UN-FORMATTED data to display. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, I_CHAR * strData);

   /**
    * Sets the cell at the specified (row, column) to the long value specified in rlData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rlData - Long value to display.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, long & rlData);

   /**
    * Sets the cell at the specified (row, column) to the DDate value specified in rDData.
    * Column should be of data type COL_TYPE_DATE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rDData - DDate value to display.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, DDate & rDData);

   /**
    * Sets the cell at the specified (row, column) to the double value specified in rfData.
    * Column should be of data type COL_TYPE_FLOAT or COL_TYPE_MONEY.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rfData - double value to display.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, double & rfData);

   /**
    * Sets the cell at the specified (row, column) to the MathString value specified in rmData.
    * Column should be of data type COL_TYPE_MATH_STR or COL_TYPE_MATH_STR_MONEY.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rfData - MathString value to display.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColValue(long nRow, long nCol, MathString & rmData);

   /**
    * Gets the UN-FORMATTED text at the specified (row, column) cell and places it in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - Receives the UN-FORMATTED data. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL GetRowColValue(long nRow, long nCol, DString & strData);

   /**
    * Gets the UN-FORMATTED text at the specified (row, column) cell and places it in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - Receives the UN-FORMATTED data. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL GetRowColValue(long nRow, long nCol, CString & strData);

   /**
    * Gets the UN-FORMATTED long value at the specified (row, column) cell and places it in rlData.
    * Column should be of data type COL_TYPE_INTEGER, COL_TYPE_TAX_ID, COL_TYPE_SSN, COL_TYPE_PHONE_NUM, or COL_TYPE_PERCENT.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rlData - Receives the UN-FORMATTED data.
    * @return TRUE if successful.
    */
   virtual BOOL GetRowColValue(long nRow, long nCol, long & rlData);

   /**
    * Gets the UN-FORMATTED DDate value at the specified (row, column) cell and places it in rDData.
    * Column should be of data type COL_TYPE_DATE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rDData - Receives the DDate value.
    * @return TRUE if successful.
    */
   virtual BOOL GetRowColValue(long nRow, long nCol, DDate & rDData);

   /**
    * Gets the UN-FORMATTED double value at the specified (row, column) cell and places it in rfData.
    * Column should be of data type COL_TYPE_FLOAT or COL_TYPE_MONEY.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rfData - Receives the double value.
    * @return TRUE if sucessful.
    */
   virtual BOOL GetRowColValue(long nRow, long nCol, double & rfData);

   /**
    * Gets the UN-FORMATTED MathString value at the specified (row, column) cell and places it in rmData.
    * Column should be of data type COL_TYPE_MATH_STR or COL_TYPE_MATH_STR_MONEY.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param rmData - Receives the MathString value.
    * @return TRUE if successful.
    */
   virtual BOOL GetRowColValue(long nRow, long nCol, MathString & rmData);

   /**
    * Gets the FORMATTED text at the specified (row, column) cell and places it in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - Receives the FORMATTED data. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
    virtual BOOL GetRowColText(long nRow, long nCol, DString & strData);

   /**
    * Sets the FORMATTED text at the specified (row, column) cell as specified in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - Contains the FORMATTED data. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColText(long nRow, long nCol, DString & strData);

   /**
    * Gets the FORMATTED text at the specified (row, column) cell and places it in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - Receives the FORMATTED data. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL GetRowColText(long nRow, long nCol, CString & strData);

   /**
    * Sets the FORMATTED text at the specified (row, column) cell as specified in strData.
    * Column can be of any data type except COL_TYPE_PICTURE.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param nCol - Index of the column.
    * @param strData - Contains the FORMATTED data. Can be any data type except COL_TYPE_PICTURE.
    * @return TRUE if successful.
    */
   virtual BOOL SetRowColText(long nRow, long nCol, CString & strData);

   /**
    * Removes a row at the specified list index.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @return TRUE if successful.
    */
   virtual BOOL RemoveRow(long nRow);

   /**
    * Sets the item data for the row at the specified list index.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param lData - The item data to set.
    */
   virtual void SetRowItemData(long nRow, long lData);

   /**
    * Gets the item data for the row at the specified list index.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @return The item data previously set for the row.
    */
   virtual long GetRowItemData(long nRow);

   /**
    * Sets a rows visibility. By default all rows are visible when added to the list.
    * Filtering uses this method of hiding rows. Therefore if you set a row as not visible
    * and the user is allowed to use filtering it may become visible again.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @param bVisible - Set to true to make row visible.
    */
   virtual void SetRowVisible(long nRow, BOOL bVisible = true);

   /**
    * Gets a rows visibility. By default all rows are visible when added to the list.
    * Filtering uses this method of hiding rows. Therefore if you set a row as not visible
    * and the user is allowed to use filtering it may become visible again.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Index of the row as returned by AddRow().
    * @return TRUE if the row is visible.
    */
   virtual BOOL GetRowVisible(long nRow);

   /**
    * Returns whether the user is viewing a filtered list.
    * Even though SetAllowUserFiltering() may be set to FALSE you can still provide
    * filtering to the user through your own menu or button. Simply call ShowFilterDialog().
    * This method along with ShowAllRows() will enable you to do that. Otherwise calling these
    * methods is not needed.
    *
    * @return TRUE if list is currently filtered.
    * @see SetAllowUserFiltering(BOOL bAllow)
    * @see GetAllowUserFiltering()
    * @see ShowAllRows()
    * @see ShowFilterDialog()
    */
   virtual BOOL IsListFiltered() { return m_bFilterApplied;};

   /**
    * Shows all hidden rows. Some rows may be hidden if the user is viewing a filtered list.
    * Even though SetAllowUserFiltering() may be set to FALSE you can still provide
    * filtering to the user through your own menu or button. Simply call ShowFilterDialog().
    * This method along with IsListFiltered() will enable you to do that. Otherwise calling these
    * methods is not needed.
    *
    * @see SetAllowUserFiltering(BOOL bAllow)
    * @see GetAllowUserFiltering()
    * @see IsListFiltered()
    * @see ShowFilterDialog()
    */
   virtual void ShowAllRows();

   /**
    * Displays the filter dialog to the user. The user may choose criteria for viewing a filtered list.
    * Even though SetAllowUserFiltering() may be set to FALSE you can still provide
    * filtering to the user through your own menu or button. Simply call ShowFilterDialog().
    * This method along with IsListFiltered() will enable you to do that. Otherwise calling these
    * methods is not needed.
    *
    * @see SetAllowUserFiltering(BOOL bAllow)
    * @see GetAllowUserFiltering()
    * @see IsListFiltered()
    * @see IsListFiltered()
    */
   virtual void ShowFilterDialog();

   /**
    * Displays the find dialog to the user. The user may enter a text string to search for.
    * The selection highlight is moved to the found text or it just beeps.
    * Even though SetAllowUserFind() may be set to FALSE you can still provide
    * find to the user through your own menu or button. Simply call ShowFindDialog().
    *
    * @see SetAllowUserFind(BOOL bAllow)
    * @see GetAllowUserFind()
    */
   virtual void ShowFindDialog();

   /**
    * Displays the Column dialog to the user. The user can select columns to
    * show or hide. Sorry they cannot reorder columns. Just show or hide.
    * Even though SetAllowUserColumnHide() may be set to FALSE you can still provide
    * this functionality to the user through your own menu or button. Simply call ShowColumnDialog().
    *
    * @see SetAllowUserColumnHide(BOOL bAllow)
    * @see SetAllowUserColumnHide()
    */
   void CDSTListView::ShowColumnDialog();

   /**
    * Returns the total number of pages to print.
    * Even though SetAllowUserPrint() may be set to FALSE you can still provide
    * printing to the user through your own menu or button. Simply call ShowPrintPreview()
    * to display the print preview window. Call ShowPrintSetup() to display the page setup dialog.
    * And Call DoPrint() to display the print dialog. The GetTotalPageCount() may change after any one
    * of the calls to the dialogs. Depending on what options the user chooses.
    *
    * @return The total number of pages to print.
    * @see ShowPrintPreview()
    * @see ShowPrintSetup()
    * @see DoPrint()
    */
   virtual long GetTotalPageCount();

   /**
    * Shows the print preview window.
    * Even though SetAllowUserPrint() may be set to FALSE you can still provide
    * printing to the user through your own menu or button. Simply call ShowPrintPreview()
    * to display the print preview window. Call ShowPrintSetup() to display the page setup dialog.
    * And Call DoPrint() to display the print dialog. The GetTotalPageCount() may change after any one
    * of the calls to the dialogs. Depending on what options the user chooses.
    *
    * @see GetTotalPageCount()
    * @see ShowPrintSetup()
    * @see DoPrint()
    */
   virtual void ShowPrintPreview();

   /**
    * Shows the print page setup dialog.
    * Even though SetAllowUserPrint() may be set to FALSE you can still provide
    * printing to the user through your own menu or button. Simply call ShowPrintPreview()
    * to display the print preview window. Call ShowPrintSetup() to display the page setup dialog.
    * And Call DoPrint() to display the print dialog. The GetTotalPageCount() may change after any one
    * of the calls to the dialogs. Depending on what options the user chooses.
    *
    * @see GetTotalPageCount()
    * @see ShowPrintPreview()
    * @see DoPrint()
    */
   virtual void ShowPrintSetup();

   /**
    * Shows the print dialog and performs the print.
    * Even though SetAllowUserPrint() may be set to FALSE you can still provide
    * printing to the user through your own menu or button. Simply call ShowPrintPreview()
    * to display the print preview window. Call ShowPrintSetup() to display the page setup dialog.
    * And Call DoPrint() to display the print dialog. The GetTotalPageCount() may change after any one
    * of the calls to the dialogs. Depending on what options the user chooses.
    *
    * @see GetTotalPageCount()
    * @see ShowPrintPreview()
    * @see ShowPrintSetup()
    */
   virtual void DoPrint();

   /**
    * Displays a file save dialog for the apporpriate file type and exports the file.
    *
    * @param eType - Enumeration of the type of file to export to.
    */
   virtual void ExportList(Export_e eType);

   /**
    * Sorts the list using the current sort column attributes.
    *
    */
   virtual void TableSort();

   /**
    * Searches through the list for lpcszSearch string with the specified criteria. If found the
    * selection highlight is moved to the row where the match is found.
    *
    * @param lpcszSearch - String to search for.
    * @param bMatchCase - TRUE to match the case as specified in the search string
    * @param bMatchFormat - TRUE to ignore formatting in the search.
    * @return TRUE if found.
    */
   virtual BOOL TableFind( LPCTSTR lpcszSearch,
                           BOOL bMatchCase,
                           BOOL bMatchFormat );

   /**
    * Resizes the width of all columns to fit the widest text in that column (including header).
    * Care must be taken of when this method is called. Since the column widths are stored and restored
    * to the registry as user preferences. This should be called after filling the list and before calling
    * RestoreUserPrefs()
    *
    * @see RestoreUserPrefs(LPCTSTR pSection, LPCTSTR pKey)
    * @see SaveUserPrefs(LPCTSTR pSection, LPCTSTR pKey)
    */
   virtual void FitColWidthToText();

   virtual void ShowHelpFarPoint( CWnd *cWnd, short FAR* KeyCode, short Shift );

   /**
    * Creates an edittable text cell at row and column specified and makes
    * lpcszText the initial value.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lpcszText - initial value.
    * @param bLock - TRUE if cell should be locked.
    */
   virtual void MakeEditCell( long nRow, long nCol, LPCTSTR lpcszText = NULL, BOOL bLock = FALSE );

   /**
    * Creates a static non-edittable text cell at row and column specified and makes
    * lpcszText the initial value.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lpcszText - initial value.
    */
   virtual void MakeLabelCell( long nRow, long nCol,
                               LPCTSTR lpcszText = NULL );

   /**
    * Creates a checkbox cell at row and column specified.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param bChecked - TRUE if checkbox should be checked.
    */
   virtual void MakeCheckBoxCell( long nRow, long nCol,
                                  BOOL bChecked = FALSE );

   /**
    * Creates an edit cell at row and column specified
    * with a mask of (999)999-9999.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lpcszText - initial value.
    */
   virtual void MakePhoneNumberCell( long nRow, long nCol,
                                     LPCTSTR lpcszText = NULL );

   /**
    * Creates an edit cell at row and column specified
    * with a mask specified by lpcszMask.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lpcszMask - mask.
    * @param lpcszText - initial value.
    */
   virtual void MakeMaskCell( long nRow, long nCol,
                              LPCTSTR lpcszMask,
                              LPCTSTR lpcszText /* NULL */ );

   /**
    * Creates an integer cell at row and column specified and makes
    * lpcszText the initial value.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lMin - minimum value allowed.
    * @param lMax - maximum value allowed.
    * @param lpcszText - initial value.
    */
   virtual void MakeIntegerCell( long nRow, long nCol,
                                 long lMin,
                                 long lMax,
                                 LPCTSTR lpcszText = NULL );

   /**
    * Creates an integer cell at row and column specified and makes
    * lValue the initial value.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lMin - minimum value allowed.
    * @param lMax - maximum value allowed.
    * @param lValue - initial value.
    */
   virtual void MakeIntegerCell( long nRow, long nCol,
                                 long lMin,
                                 long lMax,
                                 long lValue = 0 );

   /**
    * Creates a float cell at row and column specified and makes
    * lpcszText the initial value.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param dMin - minimum value allowed.
    * @param dMax - maximum value allowed.
    * @param sDecimalPlaces - number of digits after decimal place.
    * @param lpcszText - initial value.
    * @param bSeparator - TRUE if comma's are wanted.
    * @param bMoney - TRUE if dollor sign is wanted.
   */
   virtual void MakeFloatCell( long nRow, long nCol,
                               double dMin,
                               double dMax,
                               short sDecimalPlaces = 2,
                               LPCTSTR lpcszText = NULL,
                               BOOL bSeparator = FALSE,
                               BOOL bMoney = FALSE );

   /**
    * Creates a float cell at row and column specified and makes
    * dValue the initial value.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param dMin - minimum value allowed.
    * @param dMax - maximum value allowed.
    * @param sDecimalPlaces - number of digits after decimal place.
    * @param dValue - initial value.
    * @param bSeparator - TRUE if comma's are wanted.
    * @param bMoney - TRUE if dollor sign is wanted.
    */
   virtual void MakeFloatCell( long nRow, long nCol,
                               double dMin,
                               double dMax,
                               short sDecimalPlaces = 2,
                               double dValue = 0.0,
                               BOOL bSeparator = FALSE,
                               BOOL bMoney = FALSE );

   /**
    * Creates a date cell at row and column specified.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param lpcszText - initial value - current date if NULL.
    * @param bSpin - TRUE if spin button should be displayed.
    */
   virtual void MakeDateCell( long nRow, long nCol,
                              LPCTSTR lpcszText = NULL,
                              BOOL bSpin = FALSE );

   /**
    * Creates a combobox cell at row and column specified.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    * @param bChecked - TRUE if checkbox should be checked.
    */
   virtual void MakeComboBoxCell( long nRow, long nCol,
                                  const CString& csComboList,
                                  LPCTSTR lpcszText = NULL );

   /**
    * Makes nRow the active row.
    *
    * @param nRow - which row.
    */
   virtual void SetRow( long nRow );

   /**
    * Makes nCol the active column.
    *
    * @param nCol - which column.
    */
   virtual void SetCol( long nCol );

   /**
    * Displays the drop-down list for the combobox cell
    * in column nCol for the active row.
    *
    * @param nCol - which column.
    */
   virtual void ShowComboDropDownList( long nCol );

   /**
    * Makes column Col and row Row the active cell.
    *
    * @param nRow - which row.
    * @param nCol - which column.
    */
   virtual void SetActiveCell( long Col, long Row );

protected:
   /**
    * File save dialog. Used to save either *.htm or *.xls files only.
    *
    * @param unMenuOption - #define menu command ID (either *.htm or *.xls).
    * @param rstrFile - Receives the file name chosen.
    * @return TRUE if file is chosen.
    */
   virtual BOOL ChooseFile(UINT unMenuOption, CString & rstrFile);

   /**
    * Sets the options for the FarPoint spreadsheet to make it a list control.
    *
    */
   virtual void SetOptions();

   /**
    * Sets the properties of each cell in a row. Such as data type, alignment, etc.
    * Rows and Columns use 1 based indexes
    *
    * @param nRow - Specifies the row to apply the properties to.
    * @return TRUE if successful.
    */
   virtual BOOL SetCellProperties(long nRow);

   /**
    * Maps a column type enumeration to a FarPoint cell type enumeration.
    *
    * @param eColType - Column type to retrieve the cell type for.
    * @return FarPoint cell type.
    */
   virtual long MapToCellType(ColType_e eColType);

   /**
    * Sets the column header bitmaps for sorting (primary, secondary, and tertiary).
    *
    */
   virtual void UpdateColBitmaps();

   /**
    * Perform a sort of the list with the passed parameters.
    * Rows and Columns use 1 based indexes
    *
    * @param nSortBy - FarPoint enumeration. Either SS_SORT_BY_ROW or SS_SORT_BY_COL. Always row in list.
    * @param nStartAt - Index to start the sort.
    * @param nFirstKey - Primary sort index (column or row). Always row in list.
    * @param nFirstOrder - Primary sort order. Either ascending or descending.
    * @param nSecondKey - Secondary sort index (column or row). Always row in list.
    * @param nSecondOrder - Secondary sort order. Either ascending or descending.
    * @param nThirdKey - Tertiary sort index (column or row). Always row in list.
    * @param nThirdOrder - Tertiary sort order. Either ascending or descending.
    */
   virtual void TableSort( int nSortBy,
                           int nStartAt,
                           int nFirstKey,
                           int nFirstOrder,
                           int nSecondKey      = NOSORTKEY,
                           int nSecondOrder    = SORTORDER_NONE,
                           int nThirdKey       = NOSORTKEY,
                           int nThirdOrder     = SORTORDER_NONE );


private:
   CWnd*          m_pCWnd;
   _DSpreadSheet* m_pSpread;
   CFilterData*   m_pFilterData;
   long           m_multiNdx;
   long           m_nColNdx;
   BOOL           m_bMultiSel;
   CPtrArray      m_aColInfo;
   BOOL           m_bAllowUserColor;
   BOOL           m_bAllowUserSort;
   BOOL           m_bAllowUserFiltering;
   BOOL           m_bAllowUserFind;
   BOOL           m_bAllowUserColumnHide;
   BOOL           m_bAllowUserExport;
   BOOL           m_bAllowUserPrint;
   ColorStyle_e   m_eBackStyle;
   TextTipStyle_e m_eTipStyle;
   BOOL           m_bFilterApplied;
   CPOptionData*  m_pPrintOptions;
   int            m_nRedrawCount;

   BOOL         m_bButtonDown;
   int          m_nClickedCol;
   int          m_nFirstKey;
   int          m_nFirstOrder;
   int          m_nSecondKey;
   int          m_nSecondOrder;
   int          m_nThirdKey;
   int          m_nThirdOrder;
   CComPtr<IPictureDisp> m_pPicFirst;
   CComPtr<IPictureDisp> m_pPicSecond;
   CComPtr<IPictureDisp> m_pPicThird;


};

#endif // !defined(AFX_DSTLISTVIEW_H__4E0DC28E_95A1_4508_8FF6_CEA7C08271AA__INCLUDED_)

//************************************************************************
//              Revision Control Entries
//************************************************************************
//
// Name:
//    %PM%
//    %PID%
//
// Description:
//    %PD%
//
// Design Parts:
//    %PIRP%
//
// Last Changed:
//    %PO%  -  %PRT%
//
// Changes:
//    %PLA%
//
//
// $Log:   Y:/VCS/iFastAWD/inc/dstlistview.h-arc  $
//
//   Rev 1.0   28 Jan 2008 13:31:26   kovacsro
//Initial revision.
//
//   Rev 1.0   Jul 05 2001 16:13:16   DT21858
// 
//
//   Rev 1.4   Feb 16 2001 13:29:14   DT21858
//fix for unicode
//
//   Rev 1.3   15 Dec 2000 11:38:20   dt14177
//fixed problem generating html files
